declare module "src/api/Branding" {
    /**
     * @typedef {Object} BrandingOptions
     * @property {string} smallLogoImage URL to the image to use as the applications logo.
     * This logo will appear on every screen and when clicked will launch the about dialog.
     * @property {string} aboutHtml Custom content for the about screen. When defined the
     * supplied content will be inserted at the start of the about dialog, and the default
     * Open MCT splash logo will be suppressed.
     */
    /**
     * Set branding options for the application. These will override certain visual elements
     * of the application and allow for customization of the application.
     * @param {BrandingOptions} options
     */
    export default function Branding(options: BrandingOptions, ...args: any[]): {};
    export type BrandingOptions = {
        /**
         * URL to the image to use as the applications logo.
         * This logo will appear on every screen and when clicked will launch the about dialog.
         */
        smallLogoImage: string;
        /**
         * Custom content for the about screen. When defined the
         * supplied content will be inserted at the start of the about dialog, and the default
         * Open MCT splash logo will be suppressed.
         */
        aboutHtml: string;
    };
}
declare module "src/api/Editor" {
    export default class Editor extends EventEmitter<string | symbol, any> {
        constructor(openmct: any);
        editing: boolean;
        openmct: any;
        /**
         * Initiate an editing session. This will start a transaction during
         * which any persist operations will be deferred until either save()
         * or finish() are called.
         */
        edit(): void;
        /**
         * @returns {boolean} true if the application is in edit mode, false otherwise.
         */
        isEditing(): boolean;
        /**
         * Save any unsaved changes from this editing session. This will
         * end the current transaction.
         */
        save(): Promise<void>;
        /**
         * End the currently active transaction and discard unsaved changes.
         */
        cancel(): Promise<any>;
    }
    import { EventEmitter } from "eventemitter3";
}
declare module "src/api/annotation/AnnotationAPI" {
    /**
     * @typedef {Object} Tag
     * @property {string} key a unique identifier for the tag
     * @property {string} backgroundColor eg. "#cc0000"
     * @property {string} foregroundColor eg. "#ffffff"
     */
    /**
     * @typedef {import('openmct').DomainObject} DomainObject
     */
    /**
     * @typedef {import('openmct').Identifier} Identifier
     */
    /**
     * @typedef {import('openmct').OpenMCT} OpenMCT
     */
    /**
     * An interface for interacting with annotations of domain objects.
     * An annotation of a domain object is an operator created object for the purposes
     * of further describing data in plots, notebooks, maps, etc. For example, an annotation
     * could be a tag on a plot notating an interesting set of points labeled SCIENCE. It could
     * also be set of notebook entries the operator has tagged DRIVING when a robot monitored by OpenMCT
     * about rationals behind why the robot has taken a certain path.
     * Annotations are discoverable using search, and are typically rendered in OpenMCT views to bring attention
     * to other users.
     * @class AnnotationAPI
     * @extends {EventEmitter}
     */
    export default class AnnotationAPI extends EventEmitter<string | symbol, any> {
        /**
         * @param {OpenMCT} openmct
         */
        constructor(openmct: OpenMCT);
        openmct: import("src/MCT").MCT;
        availableTags: {};
        namespaceToSaveAnnotations: string;
        ANNOTATION_TYPES: Readonly<{
            NOTEBOOK: "NOTEBOOK";
            GEOSPATIAL: "GEOSPATIAL";
            PIXEL_SPATIAL: "PIXEL_SPATIAL";
            TEMPORAL: "TEMPORAL";
            PLOT_SPATIAL: "PLOT_SPATIAL";
        }>;
        ANNOTATION_TYPE: string;
        ANNOTATION_LAST_CREATED: string;
        /**
         * Creates an annotation on a given domain object (e.g., a plot) and a set of targets (e.g., telemetry objects)
         * @typedef {Object} CreateAnnotationOptions
         * @property {string} name a name for the new annotation (e.g., "Plot annnotation")
         * @property {DomainObject} domainObject the domain object this annotation was created with
         * @property {ANNOTATION_TYPES} annotationType the type of annotation to create (e.g., PLOT_SPATIAL)
         * @property {Tag[]} tags tags to add to the annotation, e.g., SCIENCE for science related annotations
         * @property {string} contentText Some text to add to the annotation, e.g. ("This annotation is about science")
         * @property {Array<Object>} targets The targets ID keystrings and their specific properties.
         * For plots, this will be a bounding box, e.g.: {keyString: "d8385009-789d-457b-acc7-d50ba2fd55ea", maxY: 100, minY: 0, maxX: 100, minX: 0}
         * For notebooks, this will be an entry ID, e.g.: {entryId: "entry-ecb158f5-d23c-45e1-a704-649b382622ba"}
         * @property {DomainObject[]} targetDomainObjects the domain objects this annotation points to (e.g., telemetry objects for a plot)
         */
        /**
         * @param {CreateAnnotationOptions} options
         * @returns {Promise<DomainObject>} a promise which will resolve when the domain object
         *          has been created, or be rejected if it cannot be saved
         */
        create({ name, domainObject, annotationType, tags, contentText, targets, targetDomainObjects }: {
            /**
             * a name for the new annotation (e.g., "Plot annnotation")
             */
            name: string;
            /**
             * the domain object this annotation was created with
             */
            domainObject: DomainObject;
            /**
             * the type of annotation to create (e.g., PLOT_SPATIAL)
             */
            annotationType: ANNOTATION_TYPES;
            /**
             * tags to add to the annotation, e.g., SCIENCE for science related annotations
             */
            tags: Tag[];
            /**
             * Some text to add to the annotation, e.g. ("This annotation is about science")
             */
            contentText: string;
            /**
             * The targets ID keystrings and their specific properties.
             * For plots, this will be a bounding box, e.g.: {keyString: "d8385009-789d-457b-acc7-d50ba2fd55ea", maxY: 100, minY: 0, maxX: 100, minX: 0}
             * For notebooks, this will be an entry ID, e.g.: {entryId: "entry-ecb158f5-d23c-45e1-a704-649b382622ba"}
             */
            targets: Array<any>;
            /**
             * the domain objects this annotation points to (e.g., telemetry objects for a plot)
             */
            targetDomainObjects: DomainObject[];
        }): Promise<DomainObject>;
        /**
         * Defines a new tag
         * @param {string} tagKey a unique identifier for the tag
         * @param {Tag} tagsDefinition the definition of the tag to add
         */
        defineTag(tagKey: string, tagsDefinition: Tag): void;
        /**
         * Sets the namespace to save new annotations to
         * @param {string} namespace the namespace to save new annotations to
         */
        setNamespaceToSaveAnnotations(namespace: string): void;
        /**
         * Checks if a domain object is an annotation
         * @param {DomainObject} domainObject the domainObject in question
         * @returns {boolean} Returns true if the domain object is an annotation
         */
        isAnnotation(domainObject: DomainObject): boolean;
        /**
         * Gets the available tags that have been loaded
         * @returns {Tag[]} Returns an array of the available tags that have been loaded
         */
        getAvailableTags(): Tag[];
        /**
         * Gets annotations for a given domain object identifier
         * @param {Identifier} domainObjectIdentifier - The domain object identifier to use to search for annotations. For example, a telemetry object identifier.
         * @param {AbortSignal} [abortSignal] - An abort signal to cancel the search
         * @returns {Promise<DomainObject[]>} Returns a promise that resolves to an array of annotations that match the search query
         */
        getAnnotations(domainObjectIdentifier: Identifier, abortSignal?: AbortSignal | undefined): Promise<DomainObject[]>;
        /**
         * Deletes (marks as deleted) the given annotations
         * @param {DomainObject[]} annotations - An array of annotations to delete (set _deleted to true)
         */
        deleteAnnotations(annotations: DomainObject[]): void;
        /**
         * Undeletes (marks as not deleted) the given annotation
         * @param {DomainObject} annotation - An annotation to undelete (set _deleted to false)
         */
        unDeleteAnnotation(annotation: DomainObject): void;
        /**
         * Gets tags from the given annotations
         * @param {DomainObject[]} annotations - The annotations to get tags from
         * @param {boolean} [filterDuplicates=true] - Whether to filter out duplicate tags
         * @returns {Tag[]} An array of tags from the given annotations
         */
        getTagsFromAnnotations(annotations: DomainObject[], filterDuplicates?: boolean | undefined): Tag[];
        /**
         * Searches for tags matching the given query
         * @param {string} query - A query to match against tags
         * @param {AbortSignal} [abortSignal] - An optional abort signal to stop the query
         * @returns {Promise<AnnotationResult[]>} A promise that resolves to an array of matching annotation results
         */
        searchForTags(query: string, abortSignal?: AbortSignal | undefined): Promise<{
            /**
             * - The name of the annotation
             */
            name: string;
            /**
             * - The type of the object (always 'annotation')
             */
            type: string;
            /**
             * - The identifier of the annotation
             */
            identifier: {
                key: string;
                namespace: string;
            };
            /**
             * - Array of tag keys associated with the annotation
             */
            tags: string[];
            /**
             * - Whether the annotation is marked as deleted
             */
            _deleted: boolean;
            /**
             * - The type of the annotation
             */
            annotationType: ANNOTATION_TYPES;
            /**
             * - The text content of the annotation
             */
            contentText: string;
            /**
             * - The original context path of the annotation
             */
            originalContextPath: string;
            /**
             * - Array of targets for the annotation
             */
            targets: {
                /**
                 * - The key string of the target
                 */
                keyString: string;
                /**
                 * - Additional properties depending on the annotation type
                 */
                additionalProperties?: any;
            }[];
            /**
             * - Full tag models including metadata
             */
            fullTagModels: Tag[];
            /**
             * - Array of tag keys that matched the search query
             */
            matchingTagKeys: string[];
            /**
             * - Array of target models with additional information
             */
            targetModels: {
                /**
                 * - The original path of the target object
                 */
                originalPath: import('openmct').DomainObject[];
                /**
                 * - Additional properties of the target domain object
                 */
                additionalProperties?: any;
            }[];
        }[]>;
        /**
         * Adds a comparator function for a given annotation type.
         * The comparator functions will be used to determine if two annotations
         * have the same target.
         * @param {ANNOTATION_TYPES} annotationType
         * @param {(t1, t2) => boolean} comparator
         */
        addTargetComparator(annotationType: ANNOTATION_TYPES, comparator: (t1: any, t2: any) => boolean): void;
        /**
         * Compare two sets of targets to see if they are equal. First checks if
         * any targets comparators evaluate to true, then falls back to a deep
         * equality check.
         * @param {ANNOTATION_TYPES} annotationType
         * @param {*} targets
         * @param {*} otherTargets
         * @returns true if the targets are equal, false otherwise
         */
        areAnnotationTargetsEqual(annotationType: ANNOTATION_TYPES, targets: any, otherTargets: any): boolean;
        #private;
    }
    export type Tag = {
        /**
         * a unique identifier for the tag
         */
        key: string;
        /**
         * eg. "#cc0000"
         */
        backgroundColor: string;
        /**
         * eg. "#ffffff"
         */
        foregroundColor: string;
    };
    export type DomainObject = import("openmct").DomainObject;
    export type Identifier = import("openmct").Identifier;
    export type OpenMCT = import("openmct").OpenMCT;
    import { EventEmitter } from "eventemitter3";
    /**
     * AnnotationType
     */
    type ANNOTATION_TYPES = string;
    /**
     * @readonly
     * @enum {string} AnnotationType
     * @property {string} NOTEBOOK The notebook annotation type
     * @property {string} GEOSPATIAL The geospatial annotation type
     * @property {string} PIXEL_SPATIAL The pixel-spatial annotation type
     * @property {string} TEMPORAL The temporal annotation type
     * @property {string} PLOT_SPATIAL The plot-spatial annotation type
     */
    const ANNOTATION_TYPES: Readonly<{
        NOTEBOOK: "NOTEBOOK";
        GEOSPATIAL: "GEOSPATIAL";
        PIXEL_SPATIAL: "PIXEL_SPATIAL";
        TEMPORAL: "TEMPORAL";
        PLOT_SPATIAL: "PLOT_SPATIAL";
    }>;
    export {};
}
declare module "src/api/objects/object-utils" {
    /*****************************************************************************
     * Open MCT, Copyright (c) 2014-2024, United States Government
     * as represented by the Administrator of the National Aeronautics and Space
     * Administration. All rights reserved.
     *
     * Open MCT is licensed under the Apache License, Version 2.0 (the
     * "License"); you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     * http://www.apache.org/licenses/LICENSE-2.0.
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
     * License for the specific language governing permissions and limitations
     * under the License.
     *
     * Open MCT includes source code licensed under additional open source
     * licenses. See the Open Source Licenses file (LICENSES.md) included with
     * this source code distribution or the Licensing information page available
     * at runtime from the About dialog for additional information.
     *****************************************************************************/
    /**
     * Utility for checking if a thing is an Open MCT Identifier.
     * @private
     */
    export function isIdentifier(thing: any): boolean;
    /**
     * Utility for checking if a thing is a key string.  Not perfect.
     * @private
     */
    export function isKeyString(thing: any): boolean;
    /**
     * Convert a keyString into an Open MCT Identifier, ex:
     * 'scratch:root' ==> {namespace: 'scratch', key: 'root'}
     *
     * Idempotent.
     *
     * @param keyString
     * @returns identifier
     */
    export function parseKeyString(keyString: any): any;
    /**
     * Convert an Open MCT Identifier into a keyString, ex:
     * {namespace: 'scratch', key: 'root'} ==> 'scratch:root'
     *
     * Idempotent
     *
     * @param identifier
     * @returns keyString
     */
    export function makeKeyString(identifier: any): any;
    /**
     * Convert a new domain object into an old format model, removing the
     * identifier and converting the composition array from Open MCT Identifiers
     * to old format keyStrings.
     *
     * @param domainObject
     * @returns oldFormatModel
     */
    export function toOldFormat(model: any): any;
    /**
     * Convert an old format domain object model into a new format domain
     * object.  Adds an identifier using the provided keyString, and converts
     * the composition array to utilize Open MCT Identifiers.
     *
     * @param model
     * @param keyString
     * @returns domainObject
     */
    export function toNewFormat(model: any, keyString: any): any;
    /**
     * Compare two Open MCT Identifiers, returning true if they are equal.
     *
     * @param identifier
     * @param otherIdentifier
     * @returns Boolean true if identifiers are equal.
     */
    export function identifierEquals(a: any, b: any): boolean;
    /**
     * Compare two domain objects, return true if they're the same object.
     * Equality is determined by identifier.
     *
     * @param domainObject
     * @param otherDomainOBject
     * @returns Boolean true if objects are equal.
     */
    export function objectEquals(a: any, b: any): boolean;
    export function refresh(oldObject: any, newObject: any): void;
}
declare module "src/api/composition/CompositionProvider" {
    /**
     * @typedef {import('openmct').DomainObject} DomainObject
     */
    /**
     * @typedef {import('openmct').Identifier} Identifier
     */
    /**
     * @typedef {import('./CompositionAPI').default} CompositionAPI
     */
    /**
     * @typedef {import('openmct').OpenMCT} OpenMCT
     */
    /**
     * A CompositionProvider provides the underlying implementation of
     * composition-related behavior for certain types of domain object.
     *
     * By default, a composition provider will not support composition
     * modification.  You can add support for mutation of composition by
     * defining `add` and/or `remove` methods.
     *
     * If the composition of an object can change over time-- perhaps via
     * server updates or mutation via the add/remove methods, then one must
     * trigger events as necessary.
     *
     */
    export default class CompositionProvider {
        /**
         * @param {OpenMCT} publicAPI
         * @param {CompositionAPI} compositionAPI
         */
        constructor(publicAPI: OpenMCT, compositionAPI: CompositionAPI);
        get listeningTo(): {};
        get establishTopicListener(): () => void;
        get publicAPI(): import("src/MCT").MCT;
        /**
         * Check if this provider should be used to load composition for a
         * particular domain object.
         * @method appliesTo
         * @param {DomainObject} domainObject the domain object
         *        to check
         * @returns {boolean} true if this provider can provide composition for a given domain object
         */
        appliesTo(domainObject: DomainObject): boolean;
        /**
         * Load any domain objects contained in the composition of this domain
         * object.
         * @param {DomainObject} domainObject the domain object
         *        for which to load composition
         * @returns {Promise<Identifier[]>} a promise for
         *          the Identifiers in this composition
         */
        load(domainObject: DomainObject): Promise<Identifier[]>;
        /**
         * Attach listeners for changes to the composition of a given domain object.
         * Supports `add` and `remove` events.
         *
         * @param {DomainObject} domainObject to listen to
         * @param {string} event the event to bind to, either `add` or `remove`.
         * @param {Function} callback callback to invoke when event is triggered.
         * @param {any} [context] to use when invoking callback.
         */
        on(domainObject: DomainObject, event: string, callback: Function, context?: any): void;
        /**
         * Remove a listener that was previously added for a given domain object.
         * event name, callback, and context must be the same as when the listener
         * was originally attached.
         *
         * @param {DomainObject} domainObject to remove listener for
         * @param {string} event event to stop listening to: `add` or `remove`.
         * @param {Function} callback callback to remove.
         * @param {any} context of callback to remove.
         */
        off(domainObject: DomainObject, event: string, callback: Function, context: any): void;
        /**
         * Remove a domain object from another domain object's composition.
         *
         * This method is optional; if not present, adding to a domain object's
         * composition using this provider will be disallowed.
         *
         * @param {DomainObject} domainObject the domain object
         *        which should have its composition modified
         * @param {Identifier} childId the domain object to remove
         */
        remove(domainObject: DomainObject, childId: Identifier): void;
        /**
         * Add a domain object to another domain object's composition.
         *
         * This method is optional; if not present, adding to a domain object's
         * composition using this provider will be disallowed.
         *
         * @param {DomainObject} parent the domain object
         *        which should have its composition modified
         * @param {Identifier} childId the domain object to add
         */
        add(parent: DomainObject, childId: Identifier): void;
        /**
         * @param {DomainObject} parent
         * @param {Identifier} childId
         * @returns {boolean}
         */
        includes(parent: DomainObject, childId: Identifier): boolean;
        /**
         * @param {DomainObject} domainObject
         * @param {number} oldIndex
         * @param {number} newIndex
         * @returns
         */
        reorder(domainObject: DomainObject, oldIndex: number, newIndex: number): void;
        topicListener: (() => void) | undefined;
        #private;
    }
    export type DomainObject = import("openmct").DomainObject;
    export type Identifier = import("openmct").Identifier;
    export type CompositionAPI = import("src/api/composition/CompositionAPI").default;
    export type OpenMCT = import("openmct").OpenMCT;
}
declare module "src/api/composition/CompositionCollection" {
    /*****************************************************************************
     * Open MCT, Copyright (c) 2014-2024, United States Government
     * as represented by the Administrator of the National Aeronautics and Space
     * Administration. All rights reserved.
     *
     * Open MCT is licensed under the Apache License, Version 2.0 (the
     * "License"); you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     * http://www.apache.org/licenses/LICENSE-2.0.
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
     * License for the specific language governing permissions and limitations
     * under the License.
     *
     * Open MCT includes source code licensed under additional open source
     * licenses. See the Open Source Licenses file (LICENSES.md) included with
     * this source code distribution or the Licensing information page available
     * at runtime from the About dialog for additional information.
     *****************************************************************************/
    /**
     * @typedef {import('openmct').DomainObject} DomainObject
     */
    /**
     * @typedef {import('./CompositionAPI').default} CompositionAPI
     */
    /**
     * @typedef {import('../../../openmct').OpenMCT} OpenMCT
     */
    /**
     * @typedef {Object} ListenerMap
     * @property {Array.<any>} add
     * @property {Array.<any>} remove
     * @property {Array.<any>} load
     * @property {Array.<any>} reorder
     */
    /**
     * A CompositionCollection represents the list of domain objects contained
     * by another domain object. It provides methods for loading this
     * list asynchronously, modifying this list, and listening for changes to
     * this list.
     *
     * Usage:
     * ```javascript
     *  var myViewComposition = MCT.composition.get(myViewObject);
     *  myViewComposition.on('add', addObjectToView);
     *  myViewComposition.on('remove', removeObjectFromView);
     *  myViewComposition.load(); // will trigger `add` for all loaded objects.
     *  ```
     */
    export default class CompositionCollection {
        /**
         * @constructor
         * @param {DomainObject} domainObject the domain object
         *        whose composition will be contained
         * @param {import('./CompositionProvider').default} provider the provider
         *        to use to retrieve other domain objects
         * @param {OpenMCT} publicAPI the composition API, for
         *        policy checks
         */
        constructor(domainObject: DomainObject, provider: import('./CompositionProvider').default, publicAPI: OpenMCT);
        domainObject: import("src/api/objects/ObjectAPI").DomainObject;
        onProviderAdd: (childId: import('openmct').Identifier) => DomainObject;
        onProviderRemove: (child: DomainObject) => void;
        returnMutables: boolean | undefined;
        /**
         * Listen for changes to this composition.  Supports 'add', 'remove', and
         * 'load' events.
         *
         * @param {string} event event to listen for, either 'add', 'remove' or 'load'.
         * @param {(...args: any[]) => void} callback to trigger when event occurs.
         * @param {any} [context] to use when invoking callback, optional.
         */
        on(event: string, callback: (...args: any[]) => void, context?: any): void;
        /**
         * Remove a listener.  Must be called with same exact parameters as
         * `off`.
         *
         * @param {string} event
         * @param {(...args: any[]) => void} callback
         * @param {any} [context]
         */
        off(event: string, callback: (...args: any[]) => void, context?: any): void;
        /**
         * Add a domain object to this composition.
         *
         * A call to [load]{@link module:openmct.CompositionCollection#load}
         * must have resolved before using this method.
         *
         * **TODO:** Remove `skipMutate` parameter.
         *
         * @param {DomainObject} child the domain object to add
         * @param {boolean} skipMutate
         * **Intended for internal use ONLY.**
         * true if the underlying provider should not be updated.
         */
        add(child: DomainObject, skipMutate: boolean): void;
        /**
         * Load the domain objects in this composition.
         *
         * @param {AbortSignal} [abortSignal]
         * @returns {Promise.<Array.<DomainObject>>} a promise for
         *          the domain objects in this composition
         * @name load
         */
        load(abortSignal?: AbortSignal | undefined): Promise<Array<DomainObject>>;
        /**
         * Remove a domain object from this composition.
         *
         * A call to [load]{@link module:openmct.CompositionCollection#load}
         * must have resolved before using this method.
         *
         * **TODO:** Remove `skipMutate` parameter.
         *
         * @param {DomainObject} child the domain object to remove
         * @param {boolean} skipMutate
         * **Intended for internal use ONLY.**
         * true if the underlying provider should not be updated.
         * @name remove
         */
        remove(child: DomainObject, skipMutate: boolean): void;
        /**
         * Reorder the domain objects in this composition.
         *
         * A call to [load]{@link module:openmct.CompositionCollection#load}
         * must have resolved before using this method.
         *
         * @param {number} oldIndex
         * @param {number} newIndex
         * @name remove
         */
        reorder(oldIndex: number, newIndex: number, _skipMutate: any): void;
        /**
         * Destroy mutationListener
         */
        _destroy(): void;
        #private;
    }
    export type DomainObject = import("openmct").DomainObject;
    export type CompositionAPI = import("src/api/composition/CompositionAPI").default;
    export type OpenMCT = import("openmct").OpenMCT;
    export type ListenerMap = {
        add: Array<any>;
        remove: Array<any>;
        load: Array<any>;
        reorder: Array<any>;
    };
}
declare module "src/api/composition/DefaultCompositionProvider" {
    /**
     * @typedef {import('openmct').DomainObject} DomainObject
     */
    /**
     * @typedef {import('openmct').Identifier} Identifier
     */
    /**
     * @typedef {import('./CompositionAPI').default} CompositionAPI
     */
    /**
     * @typedef {import('../../../openmct').OpenMCT} OpenMCT
     */
    /**
     * A CompositionProvider provides the underlying implementation of
     * composition-related behavior for certain types of domain object.
     *
     * By default, a composition provider will not support composition
     * modification.  You can add support for mutation of composition by
     * defining `add` and/or `remove` methods.
     *
     * If the composition of an object can change over time-- perhaps via
     * server updates or mutation via the add/remove methods, then one must
     * trigger events as necessary.
     * @extends CompositionProvider
     */
    export default class DefaultCompositionProvider extends CompositionProvider {
    }
    export type DomainObject = import("openmct").DomainObject;
    export type Identifier = import("openmct").Identifier;
    export type CompositionAPI = import("src/api/composition/CompositionAPI").default;
    export type OpenMCT = import("openmct").OpenMCT;
    import CompositionProvider from "src/api/composition/CompositionProvider";
}
declare module "src/api/composition/CompositionAPI" {
    /**
     * @typedef {import('./CompositionProvider').default} CompositionProvider
     */
    /**
     * @typedef {import('openmct').DomainObject} DomainObject
     */
    /**
     * @typedef {import('../../../openmct').OpenMCT} OpenMCT
     */
    /**
     * An interface for interacting with the composition of domain objects.
     * The composition of a domain object is the list of other domain objects
     * it "contains" (for instance, that should be displayed beneath it
     * in the tree.)
     * @constructor
     */
    export default class CompositionAPI {
        /**
         * @param {OpenMCT} publicAPI
         */
        constructor(publicAPI: OpenMCT);
        /** @type {CompositionProvider[]} */
        registry: CompositionProvider[];
        /** @type {CompositionPolicy[]} */
        policies: ((containingObject: DomainObject, containedObject: DomainObject) => boolean)[];
        /** @type {OpenMCT} */
        publicAPI: OpenMCT;
        /**
         * Add a composition provider.
         *
         * Plugins can add new composition providers to change the loading
         * behavior for certain domain objects.
         *
         * @method addProvider
         * @param {CompositionProvider} provider the provider to add
         */
        addProvider(provider: CompositionProvider): void;
        /**
         * Retrieve the composition (if any) of this domain object.
         *
         * @method get
         * @param {DomainObject} domainObject
         * @returns {CompositionCollection | undefined}
         */
        get(domainObject: DomainObject): CompositionCollection | undefined;
        /**
         * A composition policy is a function which either allows or disallows
         * placing one object in another's composition.
         *
         * Open MCT's policy model requires consensus, so any one policy may
         * reject composition by returning false. As such, policies should
         * generally be written to return true in the default case.
         *
         * @callback CompositionPolicy
         * @param {DomainObject} containingObject the object which
         *        would act as a container
         * @param {DomainObject} containedObject the object which
         *        would be contained
         * @returns {boolean} false if this composition should be disallowed
         */
        /**
         * Add a composition policy. Composition policies may disallow domain
         * objects from containing other domain objects.
         *
         * @method addPolicy
         * @param {CompositionPolicy} policy
         *        the policy to add
         */
        addPolicy(policy: (containingObject: DomainObject, containedObject: DomainObject) => boolean): void;
        /**
         * Check whether or not a domain object is allowed to contain another
         * domain object.
         *
         * @private
         * @method checkPolicy
         * @param {DomainObject} container the object which
         *        would act as a container
         * @param {DomainObject} containee the object which
         *        would be contained
         * @returns {boolean} false if this composition should be disallowed
         * @param {CompositionPolicy} policy
         *        the policy to add
         */
        private checkPolicy;
        /**
         * Check whether or not a domainObject supports composition
         *
         * @param {DomainObject} domainObject
         * @returns {boolean} true if the domainObject supports composition
         */
        supportsComposition(domainObject: DomainObject): boolean;
    }
    export type CompositionProvider = import("src/api/composition/CompositionProvider").default;
    export type DomainObject = import("openmct").DomainObject;
    export type OpenMCT = import("openmct").OpenMCT;
    import CompositionCollection from "src/api/composition/CompositionCollection";
}
declare module "src/api/faultmanagement/FaultManagementAPI" {
    /*****************************************************************************
     * Open MCT, Copyright (c) 2014-2024, United States Government
     * as represented by the Administrator of the National Aeronautics and Space
     * Administration. All rights reserved.
     *
     * Open MCT is licensed under the Apache License, Version 2.0 (the
     * "License"); you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     * http://www.apache.org/licenses/LICENSE-2.0.
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
     * License for the specific language governing permissions and limitations
     * under the License.
     *
     * Open MCT includes source code licensed under additional open source
     * licenses. See the Open Source Licenses file (LICENSES.md) included with
     * this source code distribution or the Licensing information page available
     * at runtime from the About dialog for additional information.
     *****************************************************************************/
    export default class FaultManagementAPI {
        /**
         * @param {import("openmct").OpenMCT} openmct
         */
        constructor(openmct: import("openmct").OpenMCT);
        openmct: import("src/MCT").MCT;
        /**
         * @param {*} provider
         */
        addProvider(provider: any): void;
        provider: any;
        /**
         * @returns {boolean}
         */
        supportsActions(): boolean;
        /**
         * @param {import('openmct').DomainObject} domainObject
         * @returns {Promise.<FaultAPIResponse[]>}
         */
        request(domainObject: import('openmct').DomainObject): Promise<FaultAPIResponse[]>;
        /**
         * @param {import('openmct').DomainObject} domainObject
         * @param {Function} callback
         * @returns {Function} unsubscribe
         */
        subscribe(domainObject: import('openmct').DomainObject, callback: Function): Function;
        /**
         * @param {Fault} fault
         * @param {*} ackData
         */
        acknowledgeFault(fault: Fault, ackData: any): any;
        /**
         * @param {Fault} fault
         * @param {*} shelveData
         * @returns {Promise.<T>}
         */
        shelveFault(fault: Fault, shelveData: any): Promise<T>;
    }
    export type TriggerValueInfo = {
        value: number;
        rangeCondition: string;
        monitoringResult: string;
    };
    export type CurrentValueInfo = {
        value: number;
        rangeCondition: string;
        monitoringResult: string;
    };
    export type Fault = {
        acknowledged: boolean;
        currentValueInfo: CurrentValueInfo;
        id: string;
        name: string;
        namespace: string;
        seqNum: number;
        severity: string;
        shelved: boolean;
        shortDescription: string;
        triggerTime: string;
        triggerValueInfo: TriggerValueInfo;
    };
    export type FaultAPIResponse = {
        type: string;
        fault: Fault;
    };
}
declare module "src/api/forms/FormController" {
    /** @type {Record<string, import('vue').Component>} */
    export const DEFAULT_CONTROLS_MAP: Record<string, import("node_modules/vue/dist/vue").Component>;
    export default class FormControl {
        /**
         * @param {OpenMCT} openmct
         */
        constructor(openmct: OpenMCT);
        /** @type {Record<string, ControlViewProvider>} */
        controls: Record<string, ControlViewProvider>;
        openmct: typeof import("openmct");
        /**
         * @param {string} controlName
         * @param {ControlViewProvider} controlViewProvider
         */
        addControl(controlName: string, controlViewProvider: ControlViewProvider): void;
        /**
         * @param {string} controlName
         * @returns {ControlViewProvider | undefined}
         */
        getControl(controlName: string): ControlViewProvider | undefined;
        /**
         * @private
         */
        private _addDefaultFormControls;
        /**
         * @private
         * @param {string} control
         * @returns {ControlViewProvider}
         */
        private _getControlViewProvider;
    }
    export type OpenMCT = typeof import("openmct");
    export type ControlViewProvider = {
        show: (element: HTMLElement, model: any, onChange: Function) => any;
        destroy: () => void;
    };
}
declare module "src/api/forms/FormsAPI" {
    /**
     * The FormsAPI provides methods for creating and managing forms in Open MCT.
     */
    export default class FormsAPI {
        /**
         * Creates an instance of FormsAPI.
         * @param {import('openmct').OpenMCT} openmct - The Open MCT API
         */
        constructor(openmct: import('openmct').OpenMCT);
        openmct: import("src/MCT").MCT;
        formController: FormController;
        /**
         * Control View Provider definition for a form control
         * @typedef ControlViewProvider
         * @property {function} show a function renders view in place of given element
         *   This function accepts element, model and onChange function
         *   element - html element (place holder) to render a row view
         *   model - row data for rendering name, value etc for given row type
         *   onChange - an onChange event callback function to keep track of any change in value
         * @property {function} destroy a callback function when a vue component gets destroyed
         */
        /**
         * Create a new form control definition with a formControlViewProvider
         *      this formControlViewProvider is used inside form overlay to show/render a form row
         *
         * @param {string} controlName a form structure, array of section
         * @param {ControlViewProvider} controlViewProvider
         */
        addNewFormControl(controlName: string, controlViewProvider: {
            /**
             * a function renders view in place of given element
             * This function accepts element, model and onChange function
             * element - html element (place holder) to render a row view
             * model - row data for rendering name, value etc for given row type
             * onChange - an onChange event callback function to keep track of any change in value
             */
            show: Function;
            /**
             * a callback function when a vue component gets destroyed
             */
            destroy: Function;
        }): void;
        /**
         * Get a ControlViewProvider for a given/stored form controlName
         *
         * @param {string} controlName a form structure, array of section
         * @return {ControlViewProvider}
         */
        getFormControl(controlName: string): {
            /**
             * a function renders view in place of given element
             * This function accepts element, model and onChange function
             * element - html element (place holder) to render a row view
             * model - row data for rendering name, value etc for given row type
             * onChange - an onChange event callback function to keep track of any change in value
             */
            show: Function;
            /**
             * a callback function when a vue component gets destroyed
             */
            destroy: Function;
        };
        /**
         * Section definition for formStructure
         * @typedef Section
         * @property {Object} name Name of the section to display on Form
         * @property {string} cssClass class name for styling section
         * @property {array<Row>} rows collection of rows inside a section
         */
        /**
         * Row definition for Section
         * @typedef Row
         * @property {string} control represents type of row to render
         *     eg:autocomplete,composite,datetime,file-input,locator,numberfield,select,textarea,textfield
         * @property {string} cssClass class name for styling this row
         * @property {import('openmct').DomainObject} domainObject object to be used by row
         * @property {string} key id for this row
         * @property {string} name Name of the row to display on Form
         * @property {import('openmct').DomainObject} parent parent object to be used by row
         * @property {boolean} required is this row mandatory
         * @property {function} validate a function to validate this row on any changes
         */
        /**
         * Show form inside an Overlay dialog with given form structure
         * @param {Array<Section>} formStructure a form structure, array of section
         * @param {Object} options
         * @param {() => void} [options.onChange] a callback function when any changes detected
         * @returns {Promise<Object>} A promise that resolves with the form data when saved, or rejects when cancelled
         */
        showForm(formStructure: {
            /**
             * Name of the section to display on Form
             */
            name: any;
            /**
             * class name for styling section
             */
            cssClass: string;
            /**
             * collection of rows inside a section
             */
            rows: array<{
                /**
                 * represents type of row to render
                 * eg:autocomplete,composite,datetime,file-input,locator,numberfield,select,textarea,textfield
                 */
                control: string;
                /**
                 * class name for styling this row
                 */
                cssClass: string;
                /**
                 * object to be used by row
                 */
                domainObject: import('openmct').DomainObject;
                /**
                 * id for this row
                 */
                key: string;
                /**
                 * Name of the row to display on Form
                 */
                name: string;
                /**
                 * parent object to be used by row
                 */
                parent: import('openmct').DomainObject;
                /**
                 * is this row mandatory
                 */
                required: boolean;
                /**
                 * a function to validate this row on any changes
                 */
                validate: Function;
            }>;
        }[], { onChange }?: {
            onChange?: (() => void) | undefined;
        }): Promise<any>;
        /**
         * Show form as a child of the element provided with given form structure
         *
         * @param {Array<Section>} formStructure a form structure, array of section
         * @param {Object} options
         * @param {HTMLElement} options.element Parent Element to render a Form
         * @param {() => void} [options.onChange] a callback function when any changes detected
         * @returns {Promise<Object>} A promise that resolves with the form data when saved, or rejects when cancelled
         */
        showCustomForm(formStructure: {
            /**
             * Name of the section to display on Form
             */
            name: any;
            /**
             * class name for styling section
             */
            cssClass: string;
            /**
             * collection of rows inside a section
             */
            rows: array<{
                /**
                 * represents type of row to render
                 * eg:autocomplete,composite,datetime,file-input,locator,numberfield,select,textarea,textfield
                 */
                control: string;
                /**
                 * class name for styling this row
                 */
                cssClass: string;
                /**
                 * object to be used by row
                 */
                domainObject: import('openmct').DomainObject;
                /**
                 * id for this row
                 */
                key: string;
                /**
                 * Name of the row to display on Form
                 */
                name: string;
                /**
                 * parent object to be used by row
                 */
                parent: import('openmct').DomainObject;
                /**
                 * is this row mandatory
                 */
                required: boolean;
                /**
                 * a function to validate this row on any changes
                 */
                validate: Function;
            }>;
        }[], { element, onChange }?: {
            element: HTMLElement;
            onChange?: (() => void) | undefined;
        }): Promise<any>;
    }
    import FormController from "src/api/forms/FormController";
}
declare module "src/utils/vueWrapHtmlElement" {
    /**
     * Compatibility wrapper for wrapping an HTMLElement in a Vue component.
     *
     * @param {HTMLElement} element
     * @returns {import('vue').Component}
     */
    export default function vueWrapHtmlElement(element: HTMLElement): import("node_modules/vue/dist/vue").Component;
}
declare module "src/api/indicators/SimpleIndicator" {
    export default SimpleIndicator;
    class SimpleIndicator extends EventEmitter<string | symbol, any> {
        constructor(openmct: any);
        openmct: any;
        element: any;
        priority: any;
        textElement: any;
        click(event: any): void;
        text(text: any): any;
        textValue: any;
        description(description: any): any;
        descriptionValue: any;
        iconClass(iconClass: any): any;
        iconClassValue: any;
        statusClass(statusClass: any, ...args: any[]): any;
        statusClassValue: any;
        getElement(): any;
    }
    import { EventEmitter } from "eventemitter3";
}
declare module "src/api/indicators/IndicatorAPI" {
    export default IndicatorAPI;
    /**
     * The Indicator API is used to add indicators to the Open MCT UI.
     * An indicator appears in the top navigation bar and can be used to
     * display information or trigger actions.
     *
     * @extends EventEmitter
     */
    class IndicatorAPI extends EventEmitter<string | symbol, any> {
        constructor(openmct: any);
        /** @type {import('../../../openmct.js').OpenMCT} */
        openmct: import("openmct").OpenMCT;
        indicatorObjects: any[];
        getIndicatorObjectsByPriority(): any[];
        simpleIndicator(): SimpleIndicator;
        /**
         * @typedef {import('vue').Component} VueComponent
         */
        /**
         * @typedef {Object} Indicator
         * @property {HTMLElement} [element] - The HTML element of the indicator. Optional if using vueComponent.
         * @property {VueComponent|Promise<VueComponent>} [vueComponent] - The Vue component for the indicator. Optional if using element.
         * @property {string} key - The unique key for the indicator.
         * @property {number} priority - The priority of the indicator (default: -1).
         */
        /**
         * Adds an indicator to the API.
         *
         * @param {Indicator} indicator - The indicator object to add.
         *
         * @description
         * The indicator object is a simple object with two main attributes:
         * - 'element': An HTMLElement (optional if using vueComponent).
         * - 'priority': An integer specifying its order in the layout. Lower priority
         *   places the element further to the right. If undefined, defaults to -1.
         *
         * A convenience function `.simpleIndicator()` is provided to create a default
         * Open MCT indicator that can be passed to `.add(indicator)`. This indicator
         * exposes functions for customizing its appearance and behavior.
         *
         * Example usage:
         * ```
         * const myIndicator = openmct.indicators.simpleIndicator();
         * openmct.indicators.add(myIndicator);
         *
         * myIndicator.text("Hello World!");
         * myIndicator.iconClass("icon-info");
         * ```
         *
         * For Vue components, pass the component directly as the 'vueComponent'
         * attribute. This can be a Vue component or a promise resolving to a
         * Vue component for asynchronous rendering.
         */
        add(indicator: {
            /**
             * - The HTML element of the indicator. Optional if using vueComponent.
             */
            element?: HTMLElement | undefined;
            /**
             * - The Vue component for the indicator. Optional if using element.
             */
            vueComponent?: import("vue").Component<any, any, any, import("vue").ComputedOptions, import("vue").MethodOptions, {}, any> | Promise<import("vue").Component<any, any, any, import("vue").ComputedOptions, import("vue").MethodOptions, {}, any>> | undefined;
            /**
             * - The unique key for the indicator.
             */
            key: string;
            /**
             * - The priority of the indicator (default: -1).
             */
            priority: number;
        }): void;
    }
    import { EventEmitter } from "eventemitter3";
    import SimpleIndicator from "src/api/indicators/SimpleIndicator";
}
declare module "src/api/menu/menu" {
    /**
     * Enum for menu placement options.
     */
    export type MENU_PLACEMENT = string;
    export namespace MENU_PLACEMENT {
        let TOP: string;
        let TOP_LEFT: string;
        let TOP_RIGHT: string;
        let BOTTOM: string;
        let BOTTOM_LEFT: string;
        let BOTTOM_RIGHT: string;
        let LEFT: string;
        let RIGHT: string;
    }
    export default Menu;
    export type MenuOptions = {
        /**
         * - Callback function to be called when the menu is destroyed.
         */
        onDestroy?: (() => void) | undefined;
    };
    /**
     * Class representing a menu.
     * @extends EventEmitter
     */
    class Menu extends EventEmitter<string | symbol, any> {
        /**
         * Create a menu.
         * @param {MenuOptions} options - The options for the menu.
         */
        constructor(options: MenuOptions);
        options: MenuOptions;
        /**
         * Dismiss the menu.
         */
        dismiss(): void;
        /**
         * Show the menu.
         */
        show(): void;
        /**
         * Show the menu component.
         */
        showMenu(): void;
        /**
         * Show the super menu component.
         */
        showSuperMenu(): void;
        destroy: any;
        el: any;
    }
    import { EventEmitter } from "eventemitter3";
}
declare module "src/api/menu/MenuAPI" {
    export default MenuAPI;
    export type MenuOptions = {
        /**
         * - Class for popup menu
         */
        menuClass?: string | undefined;
        /**
         * - Placement for menu relative to click
         */
        placement?: string | undefined;
        /**
         * - callback function: invoked when menu is destroyed
         */
        onDestroy?: (() => void) | undefined;
    };
    export type Action = import("openmct").Action;
    /**
     * The MenuAPI allows the addition of new context menu actions, and for the context menu to be launched from
     * custom HTML elements.
     */
    class MenuAPI {
        /**
         * @param {import('openmct').OpenMCT} openmct
         */
        constructor(openmct: import('openmct').OpenMCT);
        openmct: import("src/MCT").MCT;
        menuPlacement: {
            TOP: string;
            TOP_LEFT: string;
            TOP_RIGHT: string;
            BOTTOM: string;
            BOTTOM_LEFT: string;
            BOTTOM_RIGHT: string;
            LEFT: string;
            RIGHT: string;
        };
        /**
         * Show popup menu
         * @param {number} x - x-coordinates for popup
         * @param {number} y - y-coordinates for popup
         * @param {Action[]|Action[][]} items - collection of actions or collection of groups of actions
         * @param {MenuOptions} [menuOptions] - The options for Menu
         */
        showMenu(x: number, y: number, items: Action[] | Action[][], menuOptions?: MenuOptions | undefined): void;
        /**
         * Show popup menu with description of item on hover
         * @param {number} x - x-coordinates for popup
         * @param {number} y - y-coordinates for popup
         * @param {Action[]|Action[][]} actions - collection of actions or collection of groups of actions
         * @param {MenuOptions} [menuOptions] - The options for Menu
         */
        showSuperMenu(x: number, y: number, actions: Action[] | Action[][], menuOptions?: MenuOptions | undefined): void;
        /**
         * Clear the menu component
         * @private
         */
        private _clearMenuComponent;
        /**
         * Show object menu
         * @param {import('openmct').ObjectPath} objectPath - The object path
         * @param {number} x - x-coordinates for popup
         * @param {number} y - y-coordinates for popup
         * @param {string[]} actionsToBeIncluded - Actions to be included in the menu
         * @private
         */
        private _showObjectMenu;
        /**
         * Convert actions to menu items
         * @param {Action[]} actions - collection of actions
         * @param {import('openmct').ObjectPath} objectPath - The object path
         * @param {import('openmct').ViewProvider} view - The view provider
         * @returns {Action[]}
         */
        actionsToMenuItems(actions: Action[], objectPath: import('openmct').ObjectPath, view: import('openmct').ViewProvider): Action[];
        menuComponent: Menu | undefined;
        /**
         * Create a menu component
         * @param {number} x - x-coordinates for popup
         * @param {number} y - y-coordinates for popup
         * @param {Action[]|Action[][]} actions - collection of actions or collection of groups of actions
         * @param {MenuOptions} menuOptions - The options for Menu
         * @private
         */
        private _createMenuComponent;
    }
    import Menu from "src/api/menu/menu";
}
declare module "src/api/notifications/NotificationAPI" {
    /**
     * The notification service is responsible for informing the user of
     * events via the use of banner notifications.
     * @extends EventEmitter
     */
    export default class NotificationAPI extends EventEmitter<string | symbol, any> {
        /**
         * @constructor
         */
        constructor();
        /** @type {Notification[]} */
        notifications: Notification[];
        /** @type {{severity: "info" | "alert" | "error"}} */
        highest: {
            severity: "info" | "alert" | "error";
        };
        /**
         * A context in which to hold the active notification and a
         * handle to its timeout.
         * @type {Notification | undefined}
         */
        activeNotification: Notification | undefined;
        /**
         * Info notifications are low priority informational messages for the user. They will be auto-destroy after a brief
         * period of time.
         * @param {string} message The message to display to the user
         * @param {NotificationOptions} [options] The notification options
         * @returns {Notification}
         */
        info(message: string, options?: NotificationOptions | undefined): Notification;
        /**
         * Present an alert to the user.
         * @param {string} message The message to display to the user.
         * @param {NotificationOptions} [options] The notification options
         * @returns {Notification}
         */
        alert(message: string, options?: NotificationOptions | undefined): Notification;
        /**
         * Present an error message to the user
         * @param {string} message The error message to display
         * @param {NotificationOptions} [options] The notification options
         * @returns {Notification}
         */
        error(message: string, options?: NotificationOptions | undefined): Notification;
        /**
         * Create a new progress notification. These notifications will contain a progress bar.
         * @param {string} message The message to display
         * @param {number | null} progressPerc A value between 0 and 100, or null.
         * @param {string} [progressText] Text description of progress (eg. "10 of 20 objects copied").
         * @returns {Notification}
         */
        progress(message: string, progressPerc: number | null, progressText?: string | undefined): Notification;
        /**
         * Dismiss all active notifications.
         */
        dismissAllNotifications(): void;
        /**
         * Minimize a notification. The notification will still be available
         * from the notification list. Typically notifications with a
         * severity of 'info' should not be minimized, but rather
         * dismissed.
         *
         * @private
         * @param {Notification | undefined} notification The notification to minimize
         */
        private _minimize;
        /**
         * Completely removes a notification. This will dismiss it from the
         * message banner and remove it from the list of notifications.
         * Typically only notifications with a severity of info should be
         * dismissed. If you're not sure whether to dismiss or minimize a
         * notification, use {@link NotificationAPI#_dismissOrMinimize}.
         *
         * @private
         * @param {Notification | undefined} notification The notification to dismiss
         */
        private _dismiss;
        /**
         * Depending on the severity of the notification will selectively
         * dismiss or minimize where appropriate.
         *
         * @private
         * @param {Notification | undefined} notification The notification to dismiss or minimize
         */
        private _dismissOrMinimize;
        /**
         * Sets the highest severity notification.
         * @private
         */
        private _setHighestSeverity;
        /**
         * Notifies the user of an event. If there is a banner notification
         * already active, then it will be dismissed or minimized automatically,
         * and the provided notification displayed in its place.
         *
         * @private
         * @param {NotificationModel} notificationModel The notification to display
         * @returns {Notification} the provided notification decorated with
         * functions to dismiss or minimize
         */
        private _notify;
        activeTimeout: NodeJS.Timeout | undefined;
        /**
         * Creates a new notification object.
         * @private
         * @param {NotificationModel} notificationModel The model for the notification
         * @returns {Notification}
         */
        private _createNotification;
        /**
         * Sets the active notification.
         * @private
         * @param {Notification | undefined} notification The notification to set as active
         */
        private _setActiveNotification;
        /**
         * Selects the next notification to be displayed.
         * @private
         * @returns {Notification | undefined}
         */
        private _selectNextNotification;
    }
    export type NotificationProperties = {
        /**
         * Dismiss the notification
         */
        dismiss: () => void;
        /**
         * The Notification model
         */
        model: NotificationModel;
        /**
         * Update the progress of the notification
         */
        progress?: ((progressPerc: number, progressText: string) => void) | undefined;
    };
    export type Notification = EventEmitter & NotificationProperties;
    export type NotificationLink = {
        /**
         * The function to be called when the link is clicked
         */
        onClick: () => void;
        /**
         * A CSS class name to style the link
         */
        cssClass: string;
        /**
         * The text to be displayed for the link
         */
        text: string;
    };
    export type NotificationOptions = {
        /**
         * Milliseconds to wait before automatically dismissing the notification
         */
        autoDismissTimeout?: number | undefined;
        /**
         * Allows for a notification to be minimized into the indicator by default
         */
        minimized?: boolean | undefined;
        /**
         * A link for the notification
         */
        link?: NotificationLink | undefined;
    };
    /**
     * A representation of a banner notification.
     */
    export type NotificationModel = {
        /**
         * The message to be displayed by the notification
         */
        message: string;
        /**
         * The progress of some ongoing task. Should be a number between 0 and 100, or 'unknown'.
         */
        progress?: number | "unknown" | undefined;
        /**
         * A message conveying progress of some ongoing task.
         */
        progressText?: string | undefined;
        /**
         * The severity of the notification.
         */
        severity?: "error" | "alert" | "info" | undefined;
        /**
         * The time at which the notification was created. Should be a string in ISO 8601 format.
         */
        timestamp?: string | undefined;
        /**
         * Whether or not the notification has been minimized
         */
        minimized?: boolean | undefined;
        /**
         * Whether the notification should be automatically dismissed after a short period of time.
         */
        autoDismiss?: boolean | undefined;
        /**
         * The notification options
         */
        options: NotificationOptions;
    };
    import { EventEmitter } from "eventemitter3";
}
declare module "src/api/objects/ConflictError" {
    /*****************************************************************************
     * Open MCT, Copyright (c) 2014-2024, United States Government
     * as represented by the Administrator of the National Aeronautics and Space
     * Administration. All rights reserved.
     *
     * Open MCT is licensed under the Apache License, Version 2.0 (the
     * "License"); you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     * http://www.apache.org/licenses/LICENSE-2.0.
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
     * License for the specific language governing permissions and limitations
     * under the License.
     *
     * Open MCT includes source code licensed under additional open source
     * licenses. See the Open Source Licenses file (LICENSES.md) included with
     * this source code distribution or the Licensing information page available
     * at runtime from the About dialog for additional information.
     *****************************************************************************/
    /**
     * Represents an error that occurs when there is a conflict (409) while trying to
     * persist an object.
     * This class extends the built-in Error class.
     */
    export default class ConflictError extends Error {
    }
}
declare module "src/api/objects/InMemorySearchProvider" {
    export default InMemorySearchProvider;
    class InMemorySearchProvider {
        /**
         * A search service which searches through domain objects in
         * the filetree without using external search implementations.
         *
         * @constructor
         * @param {Object} openmct
         */
        constructor(openmct: any);
        /**
         * Maximum number of concurrent index requests to allow.
         */
        MAX_CONCURRENT_REQUESTS: number;
        /**
         * If max results is not specified in query, use this as default.
         */
        DEFAULT_MAX_RESULTS: number;
        openmct: any;
        indexedIds: {};
        indexedCompositions: {};
        idsToIndex: any[];
        pendingIndex: {};
        pendingRequests: number;
        worker: SharedWorker | null;
        /**
         * If we don't have SharedWorkers available (e.g., iOS)
         */
        localIndexedDomainObjects: {};
        localIndexedAnnotationsByDomainObject: {};
        localIndexedAnnotationsByTag: {};
        pendingQueries: {};
        /**
         * Handle messages from the worker.
         * @private
         */
        private onWorkerMessage;
        /**
         * Handle error messages from the worker.
         * @private
         */
        private onWorkerMessageError;
        /**
         * A local version of the same SharedWorker function
         * if we don't have SharedWorkers available (e.g., iOS)
         *
         * Gets search results from the indexedItems based on provided search
         * input. Returns matching results from indexedItems
         */
        localSearchForObjects(queryId: any, searchInput: any, maxResults: any): void;
        /**
         * A local version of the same SharedWorker function
         * if we don't have SharedWorkers available (e.g., iOS)
         */
        localSearchForAnnotations(queryId: any, searchInput: any, maxResults: any): void;
        /**
         * A local version of the same SharedWorker function
         * if we don't have SharedWorkers available (e.g., iOS)
         */
        localSearchForTags(queryId: any, matchingTagKeys: any, maxResults: any): void;
        onAnnotationCreation(annotationObject: any): void;
        onCompositionAdded(newDomainObjectToIndex: any): void;
        onCompositionRemoved(domainObjectToRemoveIdentifier: any): void;
        onerror: (event: any) => void;
        startIndexing(): void;
        searchTypes: any;
        supportedSearchTypes: any[] | undefined;
        indexAnnotations(): void;
        /**
         * @private
         */
        private getIntermediateResponse;
        search(query: any, searchType: any): Promise<any>;
        supportsSearchType(searchType: any): boolean;
        /**
         * Handle errors from the worker.
         * @private
         */
        private onWorkerError;
        /**
         * @private
         */
        private startSharedWorker;
        /**
         * Schedule an id to be indexed at a later date.  If there are less
         * pending requests than the maximum allowed, this will kick off an indexing request.
         * This is done only when indexing first begins and we need to index a lot of objects.
         *
         * @private
         * @param {identifier} id to be indexed.
         */
        private scheduleForIndexing;
        /**
         * If there are less pending requests than concurrent requests, keep
         * firing requests.
         *
         * @private
         */
        private keepIndexing;
        onNameMutation(domainObject: any, name: any): void;
        /**
         * Pass a domainObject to the worker to be indexed.
         * If the object has composition, schedule those ids for later indexing.
         * Watch for object changes and re-index object and children if so
         *
         * @private
         * @param domainObject a domainObject
         */
        private index;
        /**
         * Pulls an id from the indexing queue, loads it from the model service,
         * and indexes it.  Upon completion, tells the provider to keep
         * indexing.
         *
         * @private
         */
        private beginIndexRequest;
        localIndexTags(keyString: any, objectToIndex: any, model: any): void;
        localIndexAnnotation(objectToIndex: any, model: any): void;
        /**
         * A local version of the same SharedWorker function
         * if we don't have SharedWorkers available (e.g., iOS)
         */
        localIndexItem(keyString: any, model: any): void;
        destroyObservers(observers: any): void;
        #private;
    }
}
declare module "src/api/objects/InterceptorRegistry" {
    export default class InterceptorRegistry {
        interceptors: any[];
        /**
         * @interface InterceptorDef
         * @property {function} appliesTo function that determines if this interceptor should be called for the given identifier/object
         * @property {function} invoke function that transforms the provided domain object and returns the transformed domain object
         * @property {function} priority the priority for this interceptor. A higher number returned has more weight than a lower number
         */
        /**
         * Register a new object interceptor.
         *
         * @param {module:openmct.InterceptorDef} interceptorDef the interceptor to add
         * @method addInterceptor
         */
        addInterceptor(interceptorDef: any): void;
        /**
         * Retrieve all interceptors applicable to a domain object.
         * @method getInterceptors
         * @returns [module:openmct.InterceptorDef] the registered interceptors for this identifier/object
         */
        getInterceptors(identifier: any, object: any): any[];
    }
}
declare module "src/api/objects/MutableDomainObject" {
    export default MutableDomainObject;
    /**
     * Wraps a domain object to keep its model synchronized with other instances of the same object.
     *
     * Creating a MutableDomainObject will automatically register listeners to keep its model in sync. As such, developers
     * should be careful to destroy MutableDomainObject in order to avoid memory leaks.
     *
     * All Open MCT API functions that provide objects will provide MutableDomainObjects where possible, except
     * `openmct.objects.get()`, and will manage that object's lifecycle for you. Calling `openmct.objects.getMutable()`
     * will result in the creation of a new MutableDomainObject and you will be responsible for destroying it
     * (via openmct.objects.destroy) when you're done with it.
     */
    export type MutableDomainObject = any;
    /**
     * Wraps a domain object to keep its model synchronized with other instances of the same object.
     *
     * Creating a MutableDomainObject will automatically register listeners to keep its model in sync. As such, developers
     * should be careful to destroy MutableDomainObject in order to avoid memory leaks.
     *
     * All Open MCT API functions that provide objects will provide MutableDomainObjects where possible, except
     * `openmct.objects.get()`, and will manage that object's lifecycle for you. Calling `openmct.objects.getMutable()`
     * will result in the creation of a new MutableDomainObject and you will be responsible for destroying it
     * (via openmct.objects.destroy) when you're done with it.
     *
     * @typedef MutableDomainObject
     */
    class MutableDomainObject {
        static createMutable(object: any, mutationTopic: any): any;
        static mutateObject(object: any, path: any, value: any): void;
        constructor(eventEmitter: any);
        $observe(path: any, callback: any): any;
        $set(path: any, value: any): void;
        $refresh(model: any): void;
        $on(event: any, callback: any): () => any;
        $destroy(): void;
    }
}
declare module "src/api/objects/RootObjectProvider" {
    export default instance;
    export type Identifier = import("openmct").Identifier;
    export type RootObject = {
        /**
         * - The identifier of the root object.
         */
        identifier: Identifier;
        /**
         * - The name of the root object.
         */
        name: string;
        /**
         * - The type of the root object.
         */
        type: string;
        /**
         * - The composition of the root object.
         */
        composition: Identifier[];
    };
    export type RootRegistry = {
        /**
         * - A method that returns a promise resolving to an array of root identifiers.
         */
        getRoots: () => Promise<Identifier[]>;
    };
    /**
     * Creates or returns an instance of RootObjectProvider.
     * @param {RootRegistry} rootRegistry - The registry containing root objects.
     * @returns {RootObjectProvider} An instance of RootObjectProvider.
     */
    function instance(rootRegistry: RootRegistry): RootObjectProvider;
    /*****************************************************************************
     * Open MCT, Copyright (c) 2014-2024, United States Government
     * as represented by the Administrator of the National Aeronautics and Space
     * Administration. All rights reserved.
     *
     * Open MCT is licensed under the Apache License, Version 2.0 (the
     * "License"); you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     * http://www.apache.org/licenses/LICENSE-2.0.
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
     * License for the specific language governing permissions and limitations
     * under the License.
     *
     * Open MCT includes source code licensed under additional open source
     * licenses. See the Open Source Licenses file (LICENSES.md) included with
     * this source code distribution or the Licensing information page available
     * at runtime from the About dialog for additional information.
     *****************************************************************************/
    /**
     * Provides the root object for the Open MCT application.
     */
    class RootObjectProvider {
        /**
         * @param {RootRegistry} rootRegistry - The registry containing root objects.
         */
        constructor(rootRegistry: RootRegistry);
        rootRegistry: RootRegistry | undefined;
        rootObject: {
            identifier: {
                key: string;
                namespace: string;
            };
            name: string;
            type: string;
            composition: never[];
        } | undefined;
        /**
         * Updates the name of the root object.
         * @param {string} name - The new name for the root object.
         */
        updateName(name: string): void;
        /**
         * Retrieves the root object with updated composition.
         * @returns {Promise<RootObject>} A promise that resolves to the root object.
         */
        get(): Promise<RootObject>;
    }
}
declare module "src/api/objects/RootRegistry" {
    /**
     * Registry for managing root items in Open MCT.
     */
    export default class RootRegistry {
        /**
         * @param {OpenMCT} openmct - The Open MCT instance.
         */
        constructor(openmct: OpenMCT);
        /** @type {Array<RootItemEntry>} */
        _rootItems: Array<RootItemEntry>;
        /** @type {OpenMCT} */
        _openmct: OpenMCT;
        /**
         * Get all registered root items.
         * @returns {Promise<Array<Identifier>>} A promise that resolves to an array of root item identifiers.
         */
        getRoots(): Promise<Array<Identifier>>;
        /**
         * Add a root item to the registry.
         * @param {RootItemInput} rootItem - The root item to add.
         * @param {number} [priority] - The priority of the root item.
         */
        addRoot(rootItem: RootItemInput, priority?: number | undefined): void;
        /**
         * Validate a root item.
         * @param {RootItemInput} rootItem - The root item to validate.
         * @returns {boolean} True if the root item is valid, false otherwise.
         * @private
         */
        private _isValid;
    }
    export type RootItemEntry = {
        /**
         * - The priority of the root item.
         */
        priority: number;
        /**
         * - A function that returns a promise resolving to a root item or an array of root items.
         */
        provider: () => Promise<Identifier | Identifier[]>;
    };
    export type Identifier = import("openmct").Identifier;
    export type RootItemInput = Identifier | Identifier[] | (() => Promise<Identifier | Identifier[]>);
    export type OpenMCT = import("openmct").OpenMCT;
}
declare module "src/api/objects/Transaction" {
    /*****************************************************************************
     * Open MCT, Copyright (c) 2014-2024, United States Government
     * as represented by the Administrator of the National Aeronautics and Space
     * Administration. All rights reserved.
     *
     * Open MCT is licensed under the Apache License, Version 2.0 (the
     * "License"); you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     * http://www.apache.org/licenses/LICENSE-2.0.
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
     * License for the specific language governing permissions and limitations
     * under the License.
     *
     * Open MCT includes source code licensed under additional open source
     * licenses. See the Open Source Licenses file (LICENSES.md) included with
     * this source code distribution or the Licensing information page available
     * at runtime from the About dialog for additional information.
     *****************************************************************************/
    /**
     * Represents a transaction for managing changes to domain objects.
     */
    export default class Transaction {
        /**
         * @param {import('./ObjectAPI').default} objectAPI - The object API instance.
         */
        constructor(objectAPI: import('./ObjectAPI').default);
        /** @type {Record<string, DomainObject>} */
        dirtyObjects: Record<string, DomainObject>;
        /** @type {import('./ObjectAPI').default} */
        objectAPI: import("src/api/objects/ObjectAPI").default;
        /**
         * Adds an object to the transaction.
         * @param {DomainObject} object - The object to add.
         */
        add(object: DomainObject): void;
        /**
         * Cancels the transaction and reverts changes.
         * @returns {Promise<void[]>}
         */
        cancel(): Promise<void[]>;
        /**
         * Commits the transaction and saves changes.
         * @returns {Promise<void[]>}
         */
        commit(): Promise<void[]>;
        /**
         * Creates a promise for handling a dirty object.
         * @template T
         * @param {DomainObject} object - The dirty object.
         * @param {(object: DomainObject, ...args: any[]) => Promise<T>} action - The action to perform.
         * @param {...any} args - Additional arguments for the action.
         * @returns {Promise<T>}
         */
        createDirtyObjectPromise<T>(object: DomainObject, action: (object: DomainObject, ...args: any[]) => Promise<T>, ...args: any[]): Promise<T>;
        /**
         * Retrieves a dirty object by its identifier.
         * @param {Identifier} identifier - The object identifier.
         * @returns {DomainObject | undefined}
         */
        getDirtyObject(identifier: Identifier): DomainObject | undefined;
        /**
         * Clears the transaction and refreshes objects.
         * @returns {Promise<void[]>}
         * @private
         */
        private _clear;
    }
    export type DomainObject = import("openmct").DomainObject;
    export type Identifier = import("openmct").Identifier;
}
declare module "src/api/objects/ObjectAPI" {
    /**
     * Uniquely identifies a domain object.
     * @typedef {Object} Identifier
     * @property {string} namespace the namespace to/from which this domain object should be loaded/stored.
     * @property {string} key a unique identifier for the domain object within that namespace
     */
    /**
     * A domain object is an entity of relevance to a user's workflow, that should appear as a distinct and meaningful object within the user interface.
     * @typedef {Object} DomainObject
     * @property {Identifier} identifier a key/namespace pair which uniquely identifies this domain object
     * @property {string} type the type of domain object
     * @property {string} name the human-readable name for this domain object
     * @property {string} [creator] the user name of the creator of this domain object
     * @property {number} [modified] the time, in milliseconds since the UNIX epoch, at which this domain object was last modified
     * @property {Identifier[]} [composition] if present, this will be used by the default composition provider to load domain objects
     * @property {Record<string, any>} [configuration] A key-value map containing configuration settings for this domain object.
     */
    /**
     * @readonly
     * @enum {string} SEARCH_TYPES
     * @property {string} OBJECTS Search for objects
     * @property {string} ANNOTATIONS Search for annotations
     * @property {string} TAGS Search for tags
     */
    /**
     * Utilities for loading, saving, and manipulating domain objects.
     */
    export default class ObjectAPI {
        /**
         * @param {any} typeRegistry
         * @param {any} openmct
         */
        constructor(typeRegistry: any, openmct: any);
        typeRegistry: any;
        SEARCH_TYPES: Readonly<{
            OBJECTS: "OBJECTS";
            ANNOTATIONS: "ANNOTATIONS";
            TAGS: "TAGS";
        }>;
        eventEmitter: EventEmitter<string | symbol, any>;
        providers: {};
        rootRegistry: RootRegistry;
        inMemorySearchProvider: InMemorySearchProvider;
        rootProvider: any;
        cache: {};
        interceptorRegistry: InterceptorRegistry;
        SYNCHRONIZED_OBJECT_TYPES: string[];
        errors: {
            Conflict: typeof ConflictError;
        };
        /**
         * Retrieve the provider for a given identifier.
         * @param {Identifier} identifier
         * @returns {ObjectProvider | RootObjectProvider}
         */
        getProvider(identifier: Identifier): ObjectProvider | typeof RootObjectProvider;
        /**
         * Get an active transaction instance
         * @returns {Transaction} a transaction object
         */
        getActiveTransaction(): Transaction;
        /**
         * Get the root-level object.
         * @returns {Promise<DomainObject>} a promise for the root object
         */
        getRoot(): Promise<DomainObject>;
        /**
         * Register a new object provider for a particular namespace.
         *
         * @param {string} namespace the namespace for which to provide objects
         * @param {ObjectProvider} provider the provider which will handle loading domain objects from this namespace
         */
        addProvider(namespace: string, provider: ObjectProvider): void;
        /**
         * Get a domain object.
         *
         * @param {Identifier | string} identifier the identifier for the domain object to load
         * @param {AbortSignal} [abortSignal] (optional) signal to abort fetch requests
         * @param {boolean} [forceRemote=false] defaults to false. If true, will skip cached and
         *          dirty/in-transaction objects use and the provider.get method
         * @returns {Promise<DomainObject>} a promise which will resolve when the domain object
         *          has been saved, or be rejected if it cannot be saved
         */
        get(identifier: Identifier | string, abortSignal?: AbortSignal | undefined, forceRemote?: boolean | undefined): Promise<DomainObject>;
        /**
         * Search for domain objects.
         *
         * Object providersSearches and combines results of each object provider search.
         * Objects without search provided will have been indexed
         * and will be searched using the fallback in-memory search.
         * Search results are asynchronous and resolve in parallel.
         *
         * @param {string} query the term to search for
         * @param {AbortController.signal} [abortSignal] (optional) signal to cancel downstream fetch requests
         * @param {string} [searchType=this.SEARCH_TYPES.OBJECTS] the type of search as defined by SEARCH_TYPES
         * @returns {Promise<DomainObject>[]} an array of promises returned from each object provider's search function, each resolving to domain objects matching the provided search query and options
         */
        search(query: string, abortSignal?: any, searchType?: string | undefined): Promise<DomainObject>[];
        /**
         * Will fetch object for the given identifier, returning a version of the object that will automatically keep
         * itself updated as it is mutated. Before using this function, you should ask yourself whether you really need it.
         * The platform will provide mutable objects to views automatically if the underlying object can be mutated. The
         * platform will manage the lifecycle of any mutable objects that it provides. If you use `getMutable` you are
         * committing to managing that lifecycle yourself. `.destroy` should be called when the object is no longer needed.
         *
         * @param {Identifier} identifier the identifier of the object to fetch
         * @returns {Promise<MutableDomainObject>} a promise that will resolve with a MutableDomainObject if the object can be mutated
         */
        getMutable(identifier: Identifier): Promise<MutableDomainObject>;
        /**
         * This function is for cleaning up a mutable domain object when you're done with it.
         * You only need to use this if you retrieved the object using `getMutable()`. If the object was provided by the
         * platform (eg. passed into a `view()` function) then the platform is responsible for its lifecycle.
         * @param {MutableDomainObject} domainObject the mutable domain object to destroy
         */
        destroyMutable(domainObject: MutableDomainObject): void;
        delete(): void;
        isPersistable(idOrKeyString: any): boolean;
        isMissing(domainObject: any): boolean;
        /**
         * Save this domain object in its current state.
         *
         * @param {DomainObject} domainObject the domain object to save
         * @returns {Promise} a promise which will resolve when the domain object has been saved, or be rejected if it cannot be saved
         */
        save(domainObject: DomainObject): Promise<any>;
        /**
         * After entering into edit mode, creates a new instance of Transaction to keep track of changes in Objects
         *
         * @returns {Transaction} a new Transaction that was just created
         */
        startTransaction(): Transaction;
        transaction: Transaction | null | undefined;
        /**
         * Clear instance of Transaction
         */
        endTransaction(): void;
        /**
         * Add a root-level object.
         * @param {module:openmct.ObjectAPI~Identifier|array|function} identifier an identifier or
         *        an array of identifiers for root level objects, or a function that returns a
         *        promise for an identifier or an array of root level objects.
         * @param {module:openmct.PriorityAPI~priority|Number} priority a number representing
         *        this item(s) position in the root object's composition (example: order in object tree).
         *        For arrays, they are treated as blocks.
         * @method addRoot
         */
        addRoot(identifier: any, priority: any): void;
        /**
         * Register an object interceptor that transforms a domain object requested via module:openmct.ObjectAPI.get
         * The domain object will be transformed after it is retrieved from the persistence store
         * The domain object will be transformed only if the interceptor is applicable to that domain object as defined by the InterceptorDef
         *
         * @param {module:openmct.InterceptorDef} interceptorDef the interceptor definition to add
         * @method addGetInterceptor
         */
        addGetInterceptor(interceptorDef: any): void;
        /**
         * Invoke interceptors if applicable for a given domain object.
         * @private
         */
        private applyGetInterceptors;
        /**
         * Return relative url path from a given object path
         * eg: #/browse/mine/cb56f6bf-c900-43b7-b923-2e3b64b412db/6e89e858-77ce-46e4-a1ad-749240286497/....
         * @param {Array<DomainObject>} objectPath
         * @returns {string} relative url for object
         */
        getRelativePath(objectPath: Array<DomainObject>): string;
        /**
         * Return path of telemetry objects in the object composition
         * @param {Object} identifier the identifier for the domain object to query for
         * @param {Object} [telemetryIdentifier] the specific identifier for the telemetry
         *  to look for in the composition, uses first object in composition otherwise
         * @returns {Array} path of telemetry object in object composition
         */
        getTelemetryPath(identifier: any, telemetryIdentifier?: any): any[];
        /**
         * Modify a domain object and save.
         * @param {DomainObject} domainObject the object to mutate
         * @param {string} path the property to modify
         * @param {*} value the new value for this property
         */
        mutate(domainObject: DomainObject, path: string, value: any): void;
        /**
         * Create a mutable domain object from an existing domain object.
         * @param {DomainObject} domainObject the object to make mutable
         * @returns {MutableDomainObject} a mutable domain object that will automatically sync
         */
        toMutable(domainObject: DomainObject): MutableDomainObject;
        /**
         * Updates a domain object based on its latest persisted state. Note that this will mutate the provided object.
         * @param {DomainObject} domainObject an object to refresh from its persistence store
         * @param {boolean} [forceRemote=false] defaults to false. If true, will skip cached and
         *          dirty/in-transaction objects use and the provider.get method
         * @returns {Promise<DomainObject>} the provided object, updated to reflect the latest persisted state of the object.
         */
        refresh(domainObject: DomainObject, forceRemote?: boolean | undefined): Promise<DomainObject>;
        /**
         * Determine if the object can be mutated.
         * @param {Identifier} identifier An object identifier
         * @returns {boolean} true if the object can be mutated, otherwise returns false
         */
        supportsMutation(identifier: Identifier): boolean;
        /**
         * Observe changes to a domain object.
         * @param {DomainObject} domainObject the object to observe
         * @param {string} path the property to observe
         * @param {Function} callback a callback to invoke when new values for this property are observed.
         * @returns {() => void} a function to unsubscribe from the updates
         */
        observe(domainObject: DomainObject, path: string, callback: Function): () => void;
        /**
         * @param {module:openmct.ObjectAPI~Identifier} identifier
         * @returns {string} A string representation of the given identifier, including namespace and key
         */
        makeKeyString(identifier: any): string;
        /**
         * @param {string} keyString A string representation of the given identifier, that is, a namespace and key separated by a colon.
         * @returns {module:openmct.ObjectAPI~Identifier} An identifier object
         */
        parseKeyString(keyString: string): any;
        /**
         * Given any number of identifiers, will return true if they are all equal, otherwise false.
         * @param {module:openmct.ObjectAPI~Identifier[]} identifiers
         */
        areIdsEqual(...identifiers: any): any;
        /**
         * Given an original path check if the path is reachable via root
         * @param {Array<DomainObject>} originalPath an array of path objects to check
         * @returns {boolean} whether the domain object is reachable
         */
        isReachable(originalPath: Array<DomainObject>): boolean;
        /**
         * Given an identifier, constructs the original path by walking up its parents
         * @param {Identifier} identifier
         * @param {Array<DomainObject>} path an array of path objects
         * @param {AbortSignal} abortSignal (optional) signal to abort fetch requests
         * @returns {Promise<Array<DomainObject>>} a promise containing an array of domain objects
         */
        getOriginalPath(identifier: Identifier, path?: Array<DomainObject>, abortSignal?: AbortSignal): Promise<Array<DomainObject>>;
        /**
         * Parse and construct an `objectPath` from a `navigationPath`.
         *
         * A `navigationPath` is a string of the form `"/browse/<keyString>/<keyString>/..."` that is used
         * by the Open MCT router to navigate to a specific object.
         *
         * Throws an error if the `navigationPath` is malformed.
         *
         * @param {string} navigationPath
         * @returns {DomainObject[]} objectPath
         */
        getRelativeObjectPath(navigationPath: string): DomainObject[];
        /**
         * Check if the object is a link based on its path
         * @param {DomainObject} domainObject the DomainObject to check
         * @param {Array<DomainObject>} objectPath the object path to check
         * @returns {boolean} true if the object path is a link, otherwise false
         */
        isObjectPathToALink(domainObject: DomainObject, objectPath: Array<DomainObject>): boolean;
        /**
         * Check if a transaction is active
         * @returns {boolean} true if a transaction is active, otherwise false
         */
        isTransactionActive(): boolean;
        #private;
    }
    /**
     * Uniquely identifies a domain object.
     */
    export type Identifier = {
        /**
         * the namespace to/from which this domain object should be loaded/stored.
         */
        namespace: string;
        /**
         * a unique identifier for the domain object within that namespace
         */
        key: string;
    };
    /**
     * A domain object is an entity of relevance to a user's workflow, that should appear as a distinct and meaningful object within the user interface.
     */
    export type DomainObject = {
        /**
         * a key/namespace pair which uniquely identifies this domain object
         */
        identifier: Identifier;
        /**
         * the type of domain object
         */
        type: string;
        /**
         * the human-readable name for this domain object
         */
        name: string;
        /**
         * the user name of the creator of this domain object
         */
        creator?: string | undefined;
        /**
         * the time, in milliseconds since the UNIX epoch, at which this domain object was last modified
         */
        modified?: number | undefined;
        /**
         * if present, this will be used by the default composition provider to load domain objects
         */
        composition?: Identifier[] | undefined;
        /**
         * A key-value map containing configuration settings for this domain object.
         */
        configuration?: Record<string, any> | undefined;
    };
    /**
     * SEARCH_TYPES
     */
    export type ObjectAPI = string;
    import { EventEmitter } from "eventemitter3";
    import RootRegistry from "src/api/objects/RootRegistry";
    import InMemorySearchProvider from "src/api/objects/InMemorySearchProvider";
    import InterceptorRegistry from "src/api/objects/InterceptorRegistry";
    import ConflictError from "src/api/objects/ConflictError";
    import RootObjectProvider from "src/api/objects/RootObjectProvider";
    import Transaction from "src/api/objects/Transaction";
    import MutableDomainObject from "src/api/objects/MutableDomainObject";
}
declare module "src/api/overlays/Overlay" {
    export default Overlay;
    class Overlay extends EventEmitter<string | symbol, any> {
        constructor({ buttons, autoHide, dismissible, element, onDestroy, onDismiss, size }?: {
            buttons: any;
            autoHide?: boolean | undefined;
            dismissible?: boolean | undefined;
            element: any;
            onDestroy: any;
            onDismiss: any;
            size: any;
        });
        container: HTMLDivElement;
        autoHide: boolean;
        dismissible: boolean;
        destroy: any;
        dismiss(): void;
        notifyAndDismiss(): void;
        /**
         * @private
         **/
        private show;
    }
    import { EventEmitter } from "eventemitter3";
}
declare module "src/api/overlays/Dialog" {
    export default Dialog;
    class Dialog extends Overlay {
        constructor({ iconClass, message, title, hint, timestamp, ...options }: {
            [x: string]: any;
            iconClass: any;
            message: any;
            title: any;
            hint: any;
            timestamp: any;
        });
    }
    import Overlay from "src/api/overlays/Overlay";
}
declare module "src/api/overlays/ProgressDialog" {
    export default ProgressDialog;
    class ProgressDialog extends Overlay {
        constructor({ progressPerc, progressText, iconClass, message, title, hint, timestamp, ...options }: {
            [x: string]: any;
            progressPerc: any;
            progressText: any;
            iconClass: any;
            message: any;
            title: any;
            hint: any;
            timestamp: any;
        });
        updateProgress(progressPerc: any, progressText: any): void;
    }
    import Overlay from "src/api/overlays/Overlay";
}
declare module "src/api/overlays/Selection" {
    export default Selection;
    class Selection extends Overlay {
        constructor({ iconClass, title, message, selectionOptions, onChange, currentSelection, ...options }: {
            [x: string]: any;
            iconClass: any;
            title: any;
            message: any;
            selectionOptions: any;
            onChange: any;
            currentSelection: any;
        });
    }
    import Overlay from "src/api/overlays/Overlay";
}
declare module "src/api/overlays/OverlayAPI" {
    export default OverlayAPI;
    export type OverlayOptions = {
        /**
         * - The DOM Element to be inserted or shown in the overlay.
         */
        element: HTMLElement;
        /**
         * - The preferred size of the overlay.
         */
        size: 'large' | 'small' | 'fit';
        /**
         * - Optional array of button objects, each with 'label' and 'callback' properties.
         */
        buttons?: {
            label: string;
            callback: Function;
        }[] | undefined;
        /**
         * - Callback to be called when the overlay is destroyed.
         */
        onDestroy: Function;
        /**
         * - Whether the overlay can be dismissed by pressing 'esc' or clicking outside of it. Defaults to true.
         */
        dismissible?: boolean | undefined;
    };
    export type DialogOptions = {
        /**
         * - The title to use for the dialog
         */
        title: string;
        /**
         * - Class to apply to icon that is shown on dialog
         */
        iconClass: string;
        /**
         * - Text that indicates a current message
         */
        message: string;
        /**
         * - A list of buttons with label and callback properties that will be added to the dialog.
         */
        buttons: Array<{
            label: string;
            callback: Function;
        }>;
    };
    export type ProgressDialogOptions = {
        /**
         * - The initial progress value (0-100) or null for anonymous progress
         */
        progressPerc: number | null;
        /**
         * - The initial text to be shown under the progress bar
         */
        progressText: string;
        /**
         * - A list of buttons with label and callback properties that will be added to the dialog.
         */
        buttons: Array<{
            label: string;
            callback: Function;
        }>;
    };
    export type SelectionOptions = {
        /**
         * - The options for the selection overlay
         */
        options: any;
    };
    /**
     * The OverlayAPI is responsible for pre-pending templates to
     * the body of the document, which is useful for displaying templates
     * which need to block the full screen.
     */
    class OverlayAPI {
        activeOverlays: any[];
        /**
         * Dismisses the last overlay
         * @private
         */
        private dismissLastOverlay;
        /**
         * Shows an overlay
         * @private
         * @param {Overlay} overlay - The overlay to show
         */
        private showOverlay;
        /**
         * Creates and displays an overlay with the specified options.
         * @param {OverlayOptions} options - The configuration options for the overlay.
         * @returns {Overlay} An instance of the Overlay class.
         */
        overlay(options: OverlayOptions): Overlay;
        /**
         * Displays a blocking (modal) dialog. This dialog can be used for
         * displaying messages that require the user's immediate attention.
         * @param {DialogOptions} options - Defines options for the dialog
         * @returns {Dialog} An object with a dismiss function that can be called from the calling code to dismiss/destroy the dialog
         */
        dialog(options: DialogOptions): Dialog;
        /**
         * Displays a blocking (modal) progress dialog. This dialog can be used for
         * displaying messages that require the user's attention, and show progress
         * @param {ProgressDialogOptions} options - Defines options for the dialog
         * @returns {ProgressDialog} An object with a dismiss function that can be called from the calling code
         * to dismiss/destroy the dialog and an updateProgress function that takes progressPercentage(Number 0-100)
         * and progressText (string)
         */
        progressDialog(options: ProgressDialogOptions): ProgressDialog;
        /**
         * Creates and displays a selection overlay
         * @param {SelectionOptions} options - The options for the selection overlay
         * @returns {Selection} The created Selection instance
         */
        selection(options: SelectionOptions): Selection;
    }
    import Overlay from "src/api/overlays/Overlay";
    import Dialog from "src/api/overlays/Dialog";
    import ProgressDialog from "src/api/overlays/ProgressDialog";
    import Selection from "src/api/overlays/Selection";
}
declare module "src/api/priority/PriorityAPI" {
    export default PRIORITIES;
    /*****************************************************************************
     * Open MCT, Copyright (c) 2014-2024, United States Government
     * as represented by the Administrator of the National Aeronautics and Space
     * Administration. All rights reserved.
     *
     * Open MCT is licensed under the Apache License, Version 2.0 (the
     * "License"); you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     * http://www.apache.org/licenses/LICENSE-2.0.
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
     * License for the specific language governing permissions and limitations
     * under the License.
     *
     * Open MCT includes source code licensed under additional open source
     * licenses. See the Open Source Licenses file (LICENSES.md) included with
     * this source code distribution or the Licensing information page available
     * at runtime from the About dialog for additional information.
     *****************************************************************************/
    const PRIORITIES: Readonly<{
        HIGH: 1000;
        DEFAULT: 0;
        LOW: -1000;
    }>;
}
declare module "src/api/status/StatusAPI" {
    /**
     * Get, set, and observe statuses for Open MCT objects. A status is a string
     * that represents the current state of an object.
     *
     * @extends EventEmitter
     */
    export default class StatusAPI extends EventEmitter<string | symbol, any> {
        /**
         * Constructs a new instance of the StatusAPI class.
         * @param {OpenMCT} openmct - The Open MCT application instance.
         */
        constructor(openmct: OpenMCT);
        _openmct: import("src/MCT").MCT;
        /** @type {Record<string, Status>} */
        _statusCache: Record<string, Status>;
        /**
         * Retrieves the status of the object with the given identifier.
         * @param {Identifier} identifier - The identifier of the object.
         * @returns {Status | undefined} The status of the object, or undefined if the object's status is not cached.
         */
        get(identifier: Identifier): Status | undefined;
        /**
         * Sets the status of the object with the given identifier.
         * @param {Identifier} identifier - The identifier of the object.
         * @param {Status} status - The new status value for the object.
         */
        set(identifier: Identifier, status: Status): void;
        /**
         * Observes the status of the object with the given identifier, and calls the provided callback
         * function whenever the status changes.
         * @param {Identifier} identifier - The identifier of the object.
         * @param {(value: any) => void} callback - The function to be called whenever the status changes.
         * @returns {() => void} A function that can be called to stop observing the status.
         */
        observe(identifier: Identifier, callback: (value: any) => void): () => void;
        /**
         * Deletes the status of the object with the given identifier.
         * @param {Identifier} identifier - The identifier of the object.
         */
        delete(identifier: Identifier): void;
    }
    export type OpenMCT = import("openmct").OpenMCT;
    export type Identifier = import("openmct").Identifier;
    export type Status = string;
    import { EventEmitter } from "eventemitter3";
}
declare module "src/plugins/displayLayout/CustomStringFormatter" {
    export default class CustomStringFormatter {
        constructor(openmct: any, valueMetadata: any, itemFormat: any);
        openmct: any;
        itemFormat: any;
        valueMetadata: any;
        format(datum: any): any;
        setFormat(itemFormat: any): void;
    }
}
declare module "src/api/telemetry/WebSocketWorker" {
    /*****************************************************************************
     * Open MCT Web, Copyright (c) 2014-2024, United States Government
     * as represented by the Administrator of the National Aeronautics and Space
     * Administration. All rights reserved.
     *
     * Open MCT Web is licensed under the Apache License, Version 2.0 (the
     * "License"); you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     * http://www.apache.org/licenses/LICENSE-2.0.
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
     * License for the specific language governing permissions and limitations
     * under the License.
     *
     * Open MCT Web includes source code licensed under additional open source
     * licenses. See the Open Source Licenses file (LICENSES.md) included with
     * this source code distribution or the Licensing information page available
     * at runtime from the About dialog for additional information.
     *****************************************************************************/
    export default function installWorker(): void;
}
declare module "src/api/telemetry/BatchingWebSocket" {
    export default BatchingWebSocket;
    /**
     * Describes the strategy to be used when batching WebSocket messages
     */
    export type BatchingStrategy = {
        /**
         * a function that accepts a single
         * argument - the raw message received from the websocket. Every message
         * received will be evaluated against this function so it should be performant.
         * Note also that this function is executed in a worker, so it must be
         * completely self-contained with no external dependencies. The function
         * should return `true` if the message should be batched, and `false` if not.
         */
        shouldBatchMessage: Function;
        /**
         * a function that accepts a
         * single argument - the raw message received from the websocket. Only messages
         * where `shouldBatchMessage` has evaluated to true will be passed into this
         * function. The function should return a unique value on which to batch the
         * messages. For example a telemetry, channel, or parameter identifier.
         */
        getBatchIdFromMessage: Function;
    };
    class BatchingWebSocket extends EventTarget {
        constructor(openmct: any);
        /**
         * Will establish a WebSocket connection to the provided url
         * @param {string} url The URL to connect to
         */
        connect(url: string): void;
        /**
         * Send a message to the WebSocket.
         * @param {any} message The message to send. Can be any type supported by WebSockets.
         * See https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send#data
         */
        sendMessage(message: any): void;
        /**
         * Set the strategy used to both decide which raw messages to batch, and how to group
         * them.
         * @param {BatchingStrategy} strategy The batching strategy to use when evaluating
         * raw messages from the WebSocket.
         */
        setBatchingStrategy(strategy: BatchingStrategy): void;
        /**
         * @param {number} maxBatchSize the maximum length of a batch of messages. For example,
         * the maximum number of telemetry values to batch before dropping them
         * Note that this is a fail-safe that is only invoked if performance drops to the
         * point where Open MCT cannot keep up with the amount of telemetry it is receiving.
         * In this event it will sacrifice the oldest telemetry in the batch in favor of the
         * most recent telemetry. The user will be informed that telemetry has been dropped.
         *
         * This should be set appropriately for the expected data rate. eg. If telemetry
         * is received at 10Hz for each telemetry point, then a minimal combination of batch
         * size and rate is 10 and 1000 respectively. Ideally you would add some margin, so
         * 15 would probably be a better batch size.
         */
        setMaxBatchSize(maxBatchSize: number): void;
        setMaxBatchWait(wait: any): void;
        /**
         * Disconnect the associated WebSocket. Generally speaking there is no need to call
         * this manually.
         */
        disconnect(): void;
        start: number | undefined;
        #private;
    }
}
declare module "src/api/telemetry/DefaultMetadataProvider" {
    /**
     * This is the default metadata provider; for any object with a "telemetry"
     * property, this provider will return the value of that property as the
     * telemetry metadata.
     *
     * This provider also implements legacy support for telemetry metadata
     * defined on the type.  Telemetry metadata definitions on type will be
     * depreciated in the future.
     */
    export default class DefaultMetadataProvider {
        constructor(openmct: any);
        openmct: any;
        /**
         * Applies to any domain object with a telemetry property, or whose type
         * definition has a telemetry property.
         */
        supportsMetadata(domainObject: any): boolean;
        /**
         * Returns telemetry metadata for a given domain object.
         */
        getMetadata(domainObject: any): any;
        /**
         * @private
         */
        private typeHasTelemetry;
    }
}
declare module "src/api/time/constants" {
    export namespace TIME_CONTEXT_EVENTS {
        let bounds: string;
        let clock: string;
        let timeSystem: string;
        let clockOffsets: string;
        let tick: string;
        let modeChanged: string;
        let boundsChanged: string;
        let clockChanged: string;
        let timeSystemChanged: string;
        let clockOffsetsChanged: string;
    }
    export const REALTIME_MODE_KEY: "realtime";
    export const FIXED_MODE_KEY: "fixed";
    export namespace MODES {
        export { FIXED_MODE_KEY as fixed };
        export { REALTIME_MODE_KEY as realtime };
    }
}
declare module "src/api/telemetry/constants" {
    /*****************************************************************************
     * Open MCT, Copyright (c) 2014-2024, United States Government
     * as represented by the Administrator of the National Aeronautics and Space
     * Administration. All rights reserved.
     *
     * Open MCT is licensed under the Apache License, Version 2.0 (the
     * "License"); you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     * http://www.apache.org/licenses/LICENSE-2.0.
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
     * License for the specific language governing permissions and limitations
     * under the License.
     *
     * Open MCT includes source code licensed under additional open source
     * licenses. See the Open Source Licenses file (LICENSES.md) included with
     * this source code distribution or the Licensing information page available
     * at runtime from the About dialog for additional information.
     *****************************************************************************/
    export const TIMESYSTEM_KEY_WARNING: "All telemetry metadata must have a telemetry value with a key that matches the key of the active time system.";
    export const TIMESYSTEM_KEY_NOTIFICATION: "Telemetry metadata does not match the active time system.";
    export const LOADED_ERROR: "Telemetry Collection has already been loaded.";
}
declare module "src/utils/clock/DefaultClock" {
    /**
     * A {@link openmct.TimeAPI.Clock} that updates the temporal bounds of the
     * application based on values provided by a ticking clock.
     * @constructor
     */
    export default class DefaultClock extends EventEmitter<string | symbol, any> {
        constructor();
        key: string;
        cssClass: string;
        name: string;
        description: string;
        tick(tickValue: any): void;
        lastTick: any;
        /**
         * Register a listener for the clock. When it ticks, the
         * clock will provide the time from the configured endpoint
         *
         * @override
         * @param {string | symbol} event the event to listen for
         * @param {Function} fn the function to call when the event is emitted
         * @param {*} [context] the context to use for the function call
         * @returns {this} a function for deregistering the provided listener
         */
        override on(event: string | symbol, fn: Function, context?: any): this;
        /**
         * Register a listener for the clock. When it ticks, the
         * clock will provide the current local system time
         *
         * @override
         * @param {string | symbol} event the event to listen for
         * @param {Function} [fn] the function to call when the event is emitted
         * @param {*} [context] the context to use for the function call
         * @param {boolean} [once]
         * @returns {this}
         */
        override off(event: string | symbol, fn?: Function | undefined, context?: any, once?: boolean | undefined): this;
        stop(): void;
        start(): void;
        /**
         * @returns {number} The most recent value provided for a clock tick
         */
        currentValue(): number;
    }
    import { EventEmitter } from "eventemitter3";
}
declare module "src/api/time/GlobalTimeContext" {
    export default GlobalTimeContext;
    export type TimeConductorBounds = import("src/api/time/TimeAPI").TimeConductorBounds;
    /**
     * @typedef {import('./TimeAPI').TimeConductorBounds} TimeConductorBounds
     */
    /**
     * The GlobalContext handles getting and setting time of the openmct application in general.
     * Views will use this context unless they specify an alternate/independent time context
     */
    class GlobalTimeContext extends TimeContext {
        toi: any;
        /**
         * Get or set the start and end time of the time conductor. Basic validation
         * of bounds is performed.
         *
         * @param {TimeConductorBounds} newBounds
         * @throws {Error} Validation error
         * @returns {TimeConductorBounds}
         * @override
         */
        override bounds(newBounds: TimeConductorBounds, ...args: any[]): TimeConductorBounds;
        /**
         * Update bounds based on provided time and current offsets
         * @param {number} timestamp A time from which bounds will be calculated
         * using current offsets.
         * @override
         */
        override tick(timestamp: number, ...args: any[]): void;
        /**
         * Get or set the Time of Interest. The Time of Interest is a single point
         * in time, and constitutes the temporal focus of application views. It can
         * be manipulated by the user from the time conductor or from other views.
         * The time of interest can effectively be unset by assigning a value of
         * 'undefined'.
         * @param newTOI
         * @returns {number} the current time of interest
         */
        timeOfInterest(newTOI: any, ...args: any[]): number;
    }
    import TimeContext from "src/api/time/TimeContext";
}
declare module "src/api/time/TimeAPI" {
    export default TimeAPI;
    export type TimeContext = import("src/api/time/TimeContext").default;
    export type TimeConductorBounds = import("src/api/time/TimeContext").TimeConductorBounds;
    export type ClockOffsets = import("src/api/time/TimeContext").ClockOffsets;
    /**
     * A TimeSystem provides meaning to the values returned by the TimeAPI. Open
     * MCT supports multiple different types of time values, although all are
     * intrinsically represented by numbers, the meaning of those numbers can
     * differ depending on context.
     *
     * A default time system is provided by Open MCT in the form of the {@link UTCTimeSystem },
     * which represents integer values as ms in the Unix epoch. An example of
     * another time system might be "sols" for a Martian mission. TimeSystems do
     * not address the issue of converting between time systems.
     */
    export type TimeSystem = {
        /**
         * A unique identifier
         */
        key: string;
        /**
         * A human-readable descriptor
         */
        name: string;
        /**
         * Specify a css class defining an icon for
         * this time system. This will be visible next to the time system in the
         * menu in the Time Conductor
         */
        cssClass?: string | undefined;
        /**
         * The key of a format to use when displaying
         * discrete timestamps from this time system
         */
        timeFormat: string;
        /**
         * The key of a format to use when
         * displaying a duration or relative span of time in this time system.
         */
        durationFormat?: string | undefined;
    };
    /**
     * @typedef {import('./TimeContext.js').default} TimeContext
     */
    /**
     * @typedef {import('./TimeContext.js').TimeConductorBounds} TimeConductorBounds
     */
    /**
     * @typedef {import('./TimeContext.js').ClockOffsets} ClockOffsets
     */
    /**
     * A TimeSystem provides meaning to the values returned by the TimeAPI. Open
     * MCT supports multiple different types of time values, although all are
     * intrinsically represented by numbers, the meaning of those numbers can
     * differ depending on context.
     *
     * A default time system is provided by Open MCT in the form of the {@link UTCTimeSystem},
     * which represents integer values as ms in the Unix epoch. An example of
     * another time system might be "sols" for a Martian mission. TimeSystems do
     * not address the issue of converting between time systems.
     *
     * @typedef {Object} TimeSystem
     * @property {string} key A unique identifier
     * @property {string} name A human-readable descriptor
     * @property {string} [cssClass] Specify a css class defining an icon for
     * this time system. This will be visible next to the time system in the
     * menu in the Time Conductor
     * @property {string} timeFormat The key of a format to use when displaying
     * discrete timestamps from this time system
     * @property {string} [durationFormat] The key of a format to use when
     * displaying a duration or relative span of time in this time system.
     */
    /**
     * The public API for setting and querying the temporal state of the
     * application. The concept of time is integral to Open MCT, and at least
     * one {@link TimeSystem}, as well as some default time bounds must be
     * registered and enabled via {@link TimeAPI.addTimeSystem} and
     * {@link TimeAPI.timeSystem} respectively for Open MCT to work.
     *
     * Time-sensitive views will typically respond to changes to bounds or other
     * properties of the time conductor and update the data displayed based on
     * the temporal state of the application. The current time bounds are also
     * used in queries for historical data.
     *
     * The TimeAPI extends the GlobalTimeContext which in turn extends the TimeContext/EventEmitter class. A number of events are
     * fired when properties of the time conductor change, which are documented
     * below.
     *
     * @class
     * @extends {GlobalTimeContext}
     */
    class TimeAPI extends GlobalTimeContext {
        constructor(openmct: any);
        openmct: any;
        independentContexts: Map<any, any>;
        /**
         * Register a new time system. Once registered it can activated using
         * {@link TimeAPI.timeSystem}, and can be referenced via its key in [Time Conductor configuration](@link https://github.com/nasa/openmct/blob/master/API.md#time-conductor).
         * @param {TimeSystem} timeSystem A time system object.
         */
        addTimeSystem(timeSystem: TimeSystem): void;
        /**
         * @returns {TimeSystem[]}
         */
        getAllTimeSystems(): TimeSystem[];
        /**
         * Clocks provide a timing source that is used to
         * automatically update the time bounds of the data displayed in Open MCT.
         *
         * @typedef {Object} Clock
         * @property {string} key A unique identifier
         * @property {string} name A human-readable name. The name will be used to
         * represent this clock in the Time Conductor UI
         * @property {string} description A longer description, ideally identifying
         * what the clock ticks on.
         * @property {function} currentValue Returns the last value generated by a tick, or a default value
         * if no ticking has yet occurred
         * @see {LocalClock}
         */
        /**
         * Register a new Clock.
         * @param {Clock} clock
         */
        addClock(clock: {
            /**
             * A unique identifier
             */
            key: string;
            /**
             * A human-readable name. The name will be used to
             * represent this clock in the Time Conductor UI
             */
            name: string;
            /**
             * A longer description, ideally identifying
             * what the clock ticks on.
             */
            description: string;
            /**
             * Returns the last value generated by a tick, or a default value
             * if no ticking has yet occurred
             */
            currentValue: Function;
        }): void;
        /**
         * @returns {Clock[]}
         */
        getAllClocks(): {
            /**
             * A unique identifier
             */
            key: string;
            /**
             * A human-readable name. The name will be used to
             * represent this clock in the Time Conductor UI
             */
            name: string;
            /**
             * A longer description, ideally identifying
             * what the clock ticks on.
             */
            description: string;
            /**
             * Returns the last value generated by a tick, or a default value
             * if no ticking has yet occurred
             */
            currentValue: Function;
        }[];
        /**
         * Get or set an independent time context which follows the TimeAPI timeSystem,
         * but with different offsets for a given domain object
         * @param {string} key The identifier key of the domain object these offsets are set for
         * @param {ClockOffsets | TimeConductorBounds} value This maintains a sliding time window of a fixed width that automatically updates
         * @param {key | string} clockKey the real time clock key currently in use
         */
        addIndependentContext(key: string, value: ClockOffsets | TimeConductorBounds, clockKey: string | string): () => void;
        /**
         * Get the independent time context which follows the TimeAPI timeSystem,
         * but with different offsets.
         * @param {string} key The identifier key of the domain object these offsets
         * @returns {IndependentTimeContext} The independent time context
         */
        getIndependentContext(key: string): IndependentTimeContext;
        /**
         * Get the a timeContext for a view based on it's objectPath. If there is any object in the objectPath with an independent time context, it will be returned.
         * Otherwise, the global time context will be returned.
         * @param {Array} objectPath The view's objectPath
         * @returns {TimeContext | GlobalTimeContext} The time context
         */
        getContextForView(objectPath: any[]): TimeContext | GlobalTimeContext;
    }
    import GlobalTimeContext from "src/api/time/GlobalTimeContext";
}
declare module "src/api/time/TimeContext" {
    export default TimeContext;
    export type Clock = import("src/utils/clock/DefaultClock").default;
    export type TimeSystem = import("src/api/time/TimeAPI").TimeSystem;
    export type TimeConductorBounds = {
        /**
         * The start time displayed by the time conductor
         * in ms since epoch. Epoch determined by currently active time system
         */
        start: number;
        /**
         * The end time displayed by the time conductor in ms
         * since epoch.
         */
        end: number;
    };
    /**
     * Clock offsets are used to calculate temporal bounds when the system is
     * ticking on a clock source.
     */
    export type ClockOffsets = {
        /**
         * A time span relative to the current value of the
         * ticking clock, from which start bounds will be calculated. This value must
         * be < 0. When a clock is active, bounds will be calculated automatically
         * based on the value provided by the clock, and the defined clock offsets.
         */
        start: number;
        /**
         * A time span relative to the current value of the
         * ticking clock, from which end bounds will be calculated. This value must
         * be >= 0.
         */
        end: number;
    };
    export type ValidationResult = {
        /**
         * Result of the validation - true or false.
         */
        valid: boolean;
        /**
         * An error message if valid is false.
         */
        message: string;
    };
    /**
     * The time conductor mode.
     */
    export type Mode = 'fixed' | 'realtime';
    export type Bounds = {
        start: number;
        end: number;
    };
    /**
     * @typedef {import('../../utils/clock/DefaultClock.js').default} Clock
     */
    /**
     * @typedef {import('./TimeAPI.js').TimeSystem} TimeSystem
     */
    /**
     * @typedef {Object} TimeConductorBounds
     * @property {number } start The start time displayed by the time conductor
     * in ms since epoch. Epoch determined by currently active time system
     * @property {number} end The end time displayed by the time conductor in ms
     * since epoch.
     */
    /**
     * Clock offsets are used to calculate temporal bounds when the system is
     * ticking on a clock source.
     *
     * @typedef {Object} ClockOffsets
     * @property {number} start A time span relative to the current value of the
     * ticking clock, from which start bounds will be calculated. This value must
     * be < 0. When a clock is active, bounds will be calculated automatically
     * based on the value provided by the clock, and the defined clock offsets.
     * @property {number} end A time span relative to the current value of the
     * ticking clock, from which end bounds will be calculated. This value must
     * be >= 0.
     */
    /**
     * @typedef {Object} ValidationResult
     * @property {boolean} valid Result of the validation - true or false.
     * @property {string} message An error message if valid is false.
     */
    /**
     * @typedef {'fixed' | 'realtime'} Mode The time conductor mode.
     */
    /**
     * @class TimeContext
     * @extends EventEmitter
     */
    class TimeContext extends EventEmitter<string | symbol, any> {
        constructor();
        /**
         * The time systems available to the TimeAPI.
         * @type {Map<string, TimeSystem>}
         */
        timeSystems: Map<string, TimeSystem>;
        /**
         * The currently applied time system.
         * @type {TimeSystem | undefined}
         */
        system: TimeSystem | undefined;
        /**
         * The clocks available to the TimeAPI.
         * @type {Map<string, import('../../utils/clock/DefaultClock.js').default>}
         */
        clocks: Map<string, import("src/utils/clock/DefaultClock").default>;
        /**
         * The current bounds of the time conductor.
         * @type {TimeConductorBounds}
         */
        boundsVal: TimeConductorBounds;
        /**
         * The currently active clock.
         * @type {Clock | undefined}
         */
        activeClock: Clock | undefined;
        offsets: any;
        mode: any;
        warnCounts: {};
        /**
         * Update bounds based on provided time and current offsets.
         * @param {number} timestamp A time from which bounds will be calculated
         * using current offsets.
         */
        tick(timestamp: number): void;
        /**
         * Get or set the time system of the TimeAPI.
         * @param {TimeSystem | string} timeSystemOrKey
         * @param {TimeConductorBounds} bounds
         * @returns {TimeSystem} The currently applied time system
         * @deprecated This method is deprecated. Use "getTimeSystem" and "setTimeSystem" instead.
         */
        timeSystem(timeSystemOrKey: TimeSystem | string, bounds: TimeConductorBounds, ...args: any[]): TimeSystem;
        /**
         * Validate the given bounds. This can be used for pre-validation of bounds,
         * for example by views validating user inputs.
         * @param {TimeConductorBounds} bounds The start and end time of the conductor.
         * @returns {ValidationResult} A validation error, or true if valid
         */
        validateBounds(bounds: TimeConductorBounds): ValidationResult;
        /**
         * Get or set the start and end time of the time conductor. Basic validation
         * of bounds is performed.
         *
         * @param {TimeConductorBounds} [newBounds] The new bounds to set. If not provided, current bounds will be returned.
         * @throws {Error} Validation error
         * @returns {TimeConductorBounds} The current bounds of the time conductor.
         * @deprecated This method is deprecated. Use "getBounds" and "setBounds" instead.
         */
        bounds(newBounds?: TimeConductorBounds | undefined, ...args: any[]): TimeConductorBounds;
        /**
         * Validate the given offsets. This can be used for pre-validation of
         * offsets, for example by views validating user inputs.
         * @param {ClockOffsets} offsets The start and end offsets from a 'now' value.
         * @returns {ValidationResult} A validation error, and true/false if valid or not
         */
        validateOffsets(offsets: ClockOffsets): ValidationResult;
        /**
         * Get or set the currently applied clock offsets. If no parameter is provided,
         * the current value will be returned. If provided, the new value will be
         * used as the new clock offsets.
         * @param {ClockOffsets} [offsets] The new clock offsets to set. If not provided, current offsets will be returned.
         * @returns {ClockOffsets} The current clock offsets.
         * @deprecated This method is deprecated. Use "getClockOffsets" and "setClockOffsets" instead.
         */
        clockOffsets(offsets?: ClockOffsets | undefined, ...args: any[]): ClockOffsets;
        /**
         * Stop following the currently active clock. This will
         * revert all views to showing a static time frame defined by the current
         * bounds.
         * @deprecated This method is deprecated.
         */
        stopClock(): void;
        /**
         * Set the active clock. Tick source will be immediately subscribed to
         * and ticking will begin. Offsets from 'now' must also be provided.
         *
         * @param {string|Clock} keyOrClock The clock to activate, or its key
         * @param {ClockOffsets} offsets on each tick these will be used to calculate
         * the start and end bounds. This maintains a sliding time window of a fixed
         * width that automatically updates.
         * (Legacy) Emits a "clock" event with the new clock.
         * Emits a "clockChanged" event with the new clock.
         * @return {Clock|undefined} the currently active clock; undefined if in fixed mode
         * @deprecated This method is deprecated. Use "getClock" and "setClock" instead.
         */
        clock(keyOrClock: string | Clock, offsets: ClockOffsets, ...args: any[]): Clock | undefined;
        /**
         * Get the timestamp of the current clock
         * @returns {number} current timestamp of current clock regardless of mode
         */
        now(): number;
        /**
         * Get the time system of the TimeAPI.
         * @returns {TimeSystem} The currently applied time system
         */
        getTimeSystem(): TimeSystem;
        /**
         * Set the time system of the TimeAPI.
         * Emits a "timeSystem" event with the new time system.
         * @param {TimeSystem | string} timeSystemOrKey
         * @param {TimeConductorBounds} bounds
         */
        setTimeSystem(timeSystemOrKey: TimeSystem | string, bounds: TimeConductorBounds): void;
        /**
         * Get the start and end time of the time conductor. Basic validation
         * of bounds is performed.
         * @returns {TimeConductorBounds} The current bounds of the time conductor.
         */
        getBounds(): TimeConductorBounds;
        /**
         * Set the start and end time of the time conductor. Basic validation
         * of bounds is performed.
         *
         * @param {TimeConductorBounds} newBounds The new bounds to set.
         * @throws {Error} Validation error if bounds are invalid
         */
        setBounds(newBounds: TimeConductorBounds): void;
        /**
         * Get the active clock.
         * @return {Clock|undefined} the currently active clock; undefined if in fixed mode.
         */
        getClock(): Clock | undefined;
        /**
         * Set the active clock. Tick source will be immediately subscribed to
         * and the currently ticking will begin.
         * Offsets from 'now', if provided, will be used to set realtime mode offsets
         *
         * @param {string|Clock} keyOrClock The clock to activate, or its key
         */
        setClock(keyOrClock: string | Clock): void;
        /**
         * Get the current mode.
         * @return {Mode} the current mode
         */
        getMode(): Mode;
        /**
         * Set the mode to either fixed or realtime.
         *
         * @param {Mode} mode The mode to activate
         * @param {TimeConductorBounds|ClockOffsets} offsetsOrBounds A time window of a fixed width
         * @fires module:openmct.TimeAPI~clock
         * @return {Mode | undefined} the currently active mode
         */
        setMode(mode: Mode, offsetsOrBounds: TimeConductorBounds | ClockOffsets): Mode | undefined;
        /**
         * Checks if this time context is in realtime mode or not.
         * @returns {boolean} true if this context is in real-time mode, false if not
         */
        isRealTime(): boolean;
        /**
         * Checks if this time context is in fixed mode or not.
         * @returns {boolean} true if this context is in fixed mode, false if not
         */
        isFixed(): boolean;
        /**
         * Get the currently applied clock offsets.
         * @returns {ClockOffsets} The current clock offsets.
         */
        getClockOffsets(): ClockOffsets;
        /**
         * Set the currently applied clock offsets.
         * @param {ClockOffsets} offsets The new clock offsets to set.
         */
        setClockOffsets(offsets: ClockOffsets): void;
        #private;
    }
    import { EventEmitter } from "eventemitter3";
}
declare module "src/api/telemetry/TelemetryCollection" {
    /**
     * @typedef {import('openmct').DomainObject} DomainObject
     */
    /**
     * @typedef {import('../time/TimeContext').TimeContext} TimeContext
     */
    /**
     * @typedef {import('./TelemetryAPI').TelemetryRequestOptions} TelemetryRequestOptions
     */
    /**
     * @typedef {import('../../../openmct').OpenMCT} OpenMCT
     */
    /** Class representing a Telemetry Collection. */
    export default class TelemetryCollection extends EventEmitter<string | symbol, any> {
        /**
         * Creates a Telemetry Collection
         *
         * @param  {OpenMCT} openmct - Open MCT
         * @param  {DomainObject} domainObject - Domain Object to use for telemetry collection
         * @param  {TelemetryRequestOptions} options - Any options passed in for request/subscribe
         */
        constructor(openmct: OpenMCT, domainObject: DomainObject, options?: TelemetryRequestOptions);
        loaded: boolean;
        openmct: import("src/MCT").MCT;
        domainObject: import("src/api/objects/ObjectAPI").DomainObject;
        boundedTelemetry: any[];
        futureBuffer: any[];
        parseTime: ((datum: any) => any) | undefined;
        metadata: import("src/api/telemetry/TelemetryMetadataManager").default;
        options: import("src/api/telemetry/TelemetryAPI").TelemetryRequestOptions;
        unsubscribe: Function | undefined;
        pageState: any;
        lastBounds: any;
        requestAbort: AbortController | undefined;
        isStrategyLatest: boolean;
        dataOutsideTimeBounds: boolean;
        modeChanged: boolean;
        /**
         * This will start the requests for historical and realtime data,
         * as well as setting up initial values and watchers
         */
        load(): void;
        /**
         * can/should be called by the requester of the telemetry collection
         * to remove any listeners
         */
        destroy(): void;
        /**
         * This will start the requests for historical and realtime data,
         * as well as setting up initial values and watchers
         */
        getAll(): any[];
        /**
         * If a historical provider exists, then historical requests will be made
         * @private
         */
        private _requestHistoricalTelemetry;
        /**
         * This uses the built in subscription function from Telemetry API
         * @private
         */
        private _initiateSubscriptionTelemetry;
        /**
         * Filter any new telemetry (add/page, historical, subscription) based on
         * time bounds and dupes
         *
         * @param  {(Object|Object[])} telemetryData - telemetry data object or
         * array of telemetry data objects
         * @private
         */
        private _processNewTelemetry;
        /**
         * Finds the correct insertion point for the given telemetry datum.
         * Leverages lodash's `sortedIndexBy` function which implements a binary search.
         * @private
         */
        private _sortedIndex;
        /**
         * when the start time, end time, or both have been updated.
         * data could be added OR removed here we update the current
         * bounded telemetry
         *
         * @param  {TimeConductorBounds} bounds The newly updated bounds
         * @param  {boolean} [tick] `true` if the bounds update was due to
         * a "tick" event (ie. was an automatic update), false otherwise.
         * @private
         */
        private _bounds;
        _handleDataInsideBounds(): void;
        _handleDataOutsideBounds(): void;
        /**
         * whenever the time system is updated need to update related values in
         * the Telemetry Collection and reset the telemetry collection
         *
         * @param  {TimeSystem} timeSystem - the value of the currently applied
         * Time System
         * @private
         */
        private _setTimeSystem;
        timeKey: any;
        _setTimeSystemAndFetchData(timeSystem: any): void;
        _timeModeChanged(): void;
        /**
         * Reset the telemetry data of the collection, and re-request
         * historical telemetry
         * @private
         *
         * @todo handle subscriptions more granually
         */
        private _reset;
        /**
         * adds the _bounds callback to the 'boundsChanged' timeAPI listener
         * @private
         */
        private _watchBounds;
        /**
         * removes the _bounds callback from the 'boundsChanged' timeAPI listener
         * @private
         */
        private _unwatchBounds;
        /**
         * adds the _timeModeChanged callback to the 'modeChanged' timeAPI listener
         * @private
         */
        private _watchTimeModeChange;
        /**
         * removes the _timeModeChanged callback from the 'modeChanged' timeAPI listener
         * @private
         */
        private _unwatchTimeModeChange;
        /**
         * adds the _setTimeSystemAndFetchData callback to the 'timeSystem' timeAPI listener
         * @private
         */
        private _watchTimeSystem;
        /**
         * removes the _setTimeSystemAndFetchData callback from the 'timeSystem' timeAPI listener
         * @private
         */
        private _unwatchTimeSystem;
        /**
         * will throw a new Error, for passed in message
         * @param  {string} message Message describing the error
         * @private
         */
        private _error;
        _warn(message: any): void;
    }
    export type DomainObject = import("openmct").DomainObject;
    export type TimeContext = import("src/api/time/TimeContext").TimeContext;
    export type TelemetryRequestOptions = import("src/api/telemetry/TelemetryAPI").TelemetryRequestOptions;
    export type OpenMCT = import("openmct").OpenMCT;
    import { EventEmitter } from "eventemitter3";
}
declare module "src/api/telemetry/TelemetryMetadataManager" {
    /**
     * Utility class for handling and inspecting telemetry metadata.  Applies
     * reasonable defaults to simplify the task of providing metadata, while
     * also providing methods for interrogating telemetry metadata.
     */
    export default function TelemetryMetadataManager(metadata: any): void;
    export default class TelemetryMetadataManager {
        /**
         * Utility class for handling and inspecting telemetry metadata.  Applies
         * reasonable defaults to simplify the task of providing metadata, while
         * also providing methods for interrogating telemetry metadata.
         */
        constructor(metadata: any);
        metadata: any;
        valueMetadatas: any;
        /**
         * Get value metadata for a single key.
         */
        value(key: any): any;
        /**
         * Returns all value metadatas, sorted by priority.
         */
        values(): any[];
        /**
         * Get an array of valueMetadatas that possess all hints requested.
         * Array is sorted based on hint priority.
         *
         */
        valuesForHints(hints: any): any[];
        /**
         * check out of a given metadata has array values
         */
        isArrayValue(metadata: any): boolean;
        getFilterableValues(): any;
        getUseToUpdateInPlaceValue(): any;
        isInPlaceUpdateValue(metadatum: any): boolean;
        getDefaultDisplayValue(): any;
    }
}
declare module "src/api/telemetry/TelemetryRequestInterceptor" {
    /*****************************************************************************
     * Open MCT, Copyright (c) 2014-2024, United States Government
     * as represented by the Administrator of the National Aeronautics and Space
     * Administration. All rights reserved.
     *
     * Open MCT is licensed under the Apache License, Version 2.0 (the
     * "License"); you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     * http://www.apache.org/licenses/LICENSE-2.0.
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
     * License for the specific language governing permissions and limitations
     * under the License.
     *
     * Open MCT includes source code licensed under additional open source
     * licenses. See the Open Source Licenses file (LICENSES.md) included with
     * this source code distribution or the Licensing information page available
     * at runtime from the About dialog for additional information.
     *****************************************************************************/
    export default class TelemetryRequestInterceptorRegistry {
        interceptors: any[];
        /**
         * @interface TelemetryRequestInterceptorDef
         * @property {function} appliesTo function that determines if this interceptor should be called for the given identifier/request
         * @property {function} invoke function that transforms the provided request and returns the transformed request
         * @property {function} priority the priority for this interceptor. A higher number returned has more weight than a lower number
         */
        /**
         * Register a new telemetry request interceptor.
         *
         * @param {module:openmct.RequestInterceptorDef} requestInterceptorDef the interceptor to add
         * @method addInterceptor
         */
        addInterceptor(interceptorDef: any): void;
        /**
         * Retrieve all interceptors applicable to a domain object/request.
         * @method getInterceptors
         * @returns [module:openmct.RequestInterceptorDef] the registered interceptors for this identifier/request
         */
        getInterceptors(identifier: any, request: any): any[];
    }
}
declare module "src/api/telemetry/TelemetryValueFormatter" {
    export default class TelemetryValueFormatter {
        constructor(valueMetadata: any, formatMap: any);
        valueMetadata: any;
        formatMap: any;
        valueMetadataFormat: any;
        formatter: any;
        enumerations: any;
        getNonArrayValue(value: any): any;
        parse(datum: any): any;
        format(datum: any): any;
    }
}
declare module "src/api/telemetry/TelemetryAPI" {
    /**
     * Utilities for telemetry
     * @interface TelemetryAPI
     */
    export default class TelemetryAPI {
        constructor(openmct: any);
        get SUBSCRIBE_STRATEGY(): {
            LATEST: string;
            BATCH: string;
        };
        openmct: any;
        formatMapCache: WeakMap<object, any>;
        formatters: Map<any, any>;
        limitProviders: any[];
        stalenessProviders: any[];
        metadataCache: WeakMap<object, any>;
        metadataProviders: DefaultMetadataProvider[];
        noRequestProviderForAllObjects: boolean;
        requestAbortControllers: Set<any>;
        requestProviders: any[];
        subscriptionProviders: any[];
        valueFormatterCache: WeakMap<object, any>;
        requestInterceptorRegistry: TelemetryRequestInterceptorRegistry;
        BatchingWebSocket: typeof BatchingWebSocket;
        abortAllRequests(): void;
        /**
         * Return Custom String Formatter
         *
         * @param {Object} valueMetadata valueMetadata for given telemetry object
         * @param {string} format custom formatter string (eg: %.4f, &lts etc.)
         * @returns {CustomStringFormatter}
         */
        customStringFormatter(valueMetadata: any, format: string): CustomStringFormatter;
        /**
         * Return true if the given domainObject is a telemetry object.  A telemetry
         * object is any object which has telemetry metadata-- regardless of whether
         * the telemetry object has an available telemetry provider.
         *
         * @param {import('openmct').DomainObject} domainObject
         * @returns {boolean} true if the object is a telemetry object.
         */
        isTelemetryObject(domainObject: import('openmct').DomainObject): boolean;
        /**
         * Check if this provider can supply telemetry data associated with
         * this domain object.
         *
         * @method canProvideTelemetry
         * @param {import('openmct').DomainObject} domainObject the object for
         *        which telemetry would be provided
         * @returns {boolean} true if telemetry can be provided
         */
        canProvideTelemetry(domainObject: import('openmct').DomainObject): boolean;
        /**
         * Register a telemetry provider with the telemetry service. This
         * allows you to connect alternative telemetry sources.
         * @method addProvider
         * @param {module:openmct.TelemetryAPI~TelemetryProvider} provider the new
         *        telemetry provider
         */
        addProvider(provider: any): void;
        /**
         * Returns a telemetry subscription provider that supports
         * a given domain object and options.
         */
        findSubscriptionProvider(...args: any[]): any;
        /**
         * Returns a telemetry request provider that supports
         * a given domain object and options.
         */
        findRequestProvider(...args: any[]): any;
        /**
         * @param {TelemetryRequestOptions} options options for the telemetry request
         * @returns {TelemetryRequestOptions} the options, with defaults filled in
         */
        standardizeRequestOptions(options?: TelemetryRequestOptions): TelemetryRequestOptions;
        /**
         * Register a request interceptor that transforms a request via module:openmct.TelemetryAPI.request
         * The request will be modified when it is received and will be returned in it's modified state
         * The request will be transformed only if the interceptor is applicable to that domain object as defined by the RequestInterceptorDef
         *
         * @param {module:openmct.RequestInterceptorDef} requestInterceptorDef the request interceptor definition to add
         * @method addRequestInterceptor
         */
        addRequestInterceptor(requestInterceptorDef: any): void;
        /**
         * Invoke interceptors if applicable for a given domain object.
         */
        applyRequestInterceptors(domainObject: any, request: any): Promise<any>;
        /**
         * Get or set greedy LAD. For strategy "latest" telemetry in
         * realtime mode the start bound will be ignored if true and
         * there is no new data to replace the existing data.
         * defaults to true
         *
         * To turn off greedy LAD:
         * openmct.telemetry.greedyLAD(false);
         *
         * @method greedyLAD
         * @returns {boolean} if greedyLAD is active or not
         */
        greedyLAD(isGreedy: any, ...args: any[]): boolean;
        /**
         * Request telemetry collection for a domain object.
         * The `options` argument allows you to specify filters
         * (start, end, etc.), sort order, and strategies for retrieving
         * telemetry (aggregation, latest available, etc.).
         *
         * @method requestCollection
         * @param {import('openmct').DomainObject} domainObject the object
         *        which has associated telemetry
         * @param {TelemetryRequestOptions} options
         *        options for this telemetry collection request
         * @returns {TelemetryCollection} a TelemetryCollection instance
         */
        requestCollection(domainObject: import('openmct').DomainObject, options?: TelemetryRequestOptions): TelemetryCollection;
        /**
         * Request historical telemetry for a domain object.
         * The `options` argument allows you to specify filters
         * (start, end, etc.), sort order, time context, and strategies for retrieving
         * telemetry (aggregation, latest available, etc.).
         *
         * @method request
         * @param {import('openmct').DomainObject} domainObject the object
         *        which has associated telemetry
         * @param {TelemetryRequestOptions} options
         *        options for this historical request
         * @returns {Promise.<object[]>} a promise for an array of
         *          telemetry data
         */
        request(domainObject: import('openmct').DomainObject, ...args: any[]): Promise<object[]>;
        /**
         * Subscribe to realtime telemetry for a specific domain object.
         * The callback will be called whenever data is received from a
         * realtime provider.
         *
         * @method subscribe
         * @param {import('openmct').DomainObject} domainObject the object
         *        which has associated telemetry
         * @param {TelemetrySubscriptionOptions} options configuration items for subscription
         * @param {Function} callback the callback to invoke with new data, as
         *        it becomes available
         * @returns {Function} a function which may be called to terminate
         *          the subscription
         */
        subscribe(domainObject: import('openmct').DomainObject, callback: Function, options?: TelemetrySubscriptionOptions): Function;
        /**
         * Subscribe to staleness updates for a specific domain object.
         * The callback will be called whenever staleness changes.
         *
         * @method subscribeToStaleness
         * @param {import('openmct').DomainObject} domainObject the object
         *          to watch for staleness updates
         * @param {Function} callback the callback to invoke with staleness data,
         *  as it is received: ex.
         *  {
         *      isStale: <Boolean>,
         *      timestamp: <timestamp>
         *  }
         * @returns {Function} a function which may be called to terminate
         *          the subscription to staleness updates
         */
        subscribeToStaleness(domainObject: import('openmct').DomainObject, callback: Function): Function;
        stalenessSubscriberCache: {} | undefined;
        /**
         * Subscribe to run-time changes in configured telemetry limits for a specific domain object.
         * The callback will be called whenever data is received from a
         * limit provider.
         *
         * @method subscribeToLimits
         * @param {import('openmct').DomainObject} domainObject the object
         *        which has associated limits
         * @param {Function} callback the callback to invoke with new data, as
         *        it becomes available
         * @returns {Function} a function which may be called to terminate
         *          the subscription
         */
        subscribeToLimits(domainObject: import('openmct').DomainObject, callback: Function): Function;
        limitsSubscribeCache: {} | undefined;
        /**
         * Request telemetry staleness for a domain object.
         *
         * @method isStale
         * @param {import('openmct').DomainObject} domainObject the object
         *        which has associated telemetry staleness
         * @returns {Promise.<StalenessResponseObject>} a promise for a StalenessResponseObject
         *        or undefined if no provider exists
         */
        isStale(domainObject: import('openmct').DomainObject): Promise<StalenessResponseObject>;
        /**
         * Get telemetry metadata for a given domain object.  Returns a telemetry
         * metadata manager which provides methods for interrogating telemetry
         * metadata.
         *
         * @returns {TelemetryMetadataManager}
         */
        getMetadata(domainObject: any): TelemetryMetadataManager;
        /**
         * Get a value formatter for a given valueMetadata.
         *
         * @returns {TelemetryValueFormatter}
         */
        getValueFormatter(valueMetadata: any): TelemetryValueFormatter;
        /**
         * Get a value formatter for a given key.
         * @param {string} key
         *
         * @returns {Format}
         */
        getFormatter(key: string): Format;
        /**
         * Get a format map of all value formatters for a given piece of telemetry
         * metadata.
         *
         * @returns {Record<string, TelemetryValueFormatter>}
         */
        getFormatMap(metadata: any): Record<string, TelemetryValueFormatter>;
        /**
         * Register a new telemetry data formatter.
         * @param {Format} format the
         */
        addFormat(format: Format): void;
        /**
         * Get a limit evaluator for this domain object.
         * Limit Evaluators help you evaluate limit and alarm status of individual
         * telemetry datums for display purposes without having to interact directly
         * with the Limit API.
         *
         * This method is optional.
         * If a provider does not implement this method, it is presumed
         * that no limits are defined for this domain object's telemetry.
         *
         * @param {import('openmct').DomainObject} domainObject the domain
         *        object for which to evaluate limits
         * @returns {module:openmct.TelemetryAPI~LimitEvaluator}
         * @method limitEvaluator
         */
        limitEvaluator(domainObject: import('openmct').DomainObject): any;
        /**
         * Get a limits for this domain object.
         * Limits help you display limits and alarms of
         * telemetry for display purposes without having to interact directly
         * with the Limit API.
         *
         * This method is optional.
         * If a provider does not implement this method, it is presumed
         * that no limits are defined for this domain object's telemetry.
         *
         * @param {import('openmct').DomainObject} domainObject the domain
         *        object for which to get limits
         * @returns {LimitsResponseObject}
         * @method limits
         */
        limitDefinition(domainObject: import('openmct').DomainObject): LimitsResponseObject;
        /**
         * Get a limit evaluator for this domain object.
         * Limit Evaluators help you evaluate limit and alarm status of individual
         * telemetry datums for display purposes without having to interact directly
         * with the Limit API.
         *
         * This method is optional.
         * If a provider does not implement this method, it is presumed
         * that no limits are defined for this domain object's telemetry.
         *
         * @param {import('openmct').DomainObject} domainObject the domain
         *        object for which to evaluate limits
         * @returns {module:openmct.TelemetryAPI~LimitEvaluator}
         * @method limitEvaluator
         */
        getLimitEvaluator(domainObject: import('openmct').DomainObject): any;
        /**
         * Get a limit definitions for this domain object.
         * Limit Definitions help you indicate limits and alarms of
         * telemetry for display purposes without having to interact directly
         * with the Limit API.
         *
         * This method is optional.
         * If a provider does not implement this method, it is presumed
         * that no limits are defined for this domain object's telemetry.
         *
         * @param {import('openmct').DomainObject} domainObject the domain
         *        object for which to display limits
         * @returns {LimitsResponseObject}
         * @method limits returns a limits object of type {LimitsResponseObject}
         *  supported colors are purple, red, orange, yellow and cyan
         */
        getLimits(domainObject: import('openmct').DomainObject): LimitsResponseObject;
        #private;
    }
    export type TimeContext = import("src/api/time/TimeContext").TimeContext;
    /**
     * Describes and bounds requests for telemetry data.
     */
    export type TelemetryRequestOptions = {
        /**
         * the key of the property to sort by. This may
         * be prefixed with a "+" or a "-" sign to sort in ascending
         * or descending order respectively. If no prefix is present,
         * ascending order will be used.
         */
        sort?: string | undefined;
        /**
         * the lower bound for values of the sorting property
         */
        start?: number | undefined;
        /**
         * the upper bound for values of the sorting property
         */
        end?: number | undefined;
        /**
         * symbolic identifier for strategies
         * (such as `latest` or `minmax`) which may be recognized by providers;
         * these will be tried in order until an appropriate provider
         * is found
         */
        strategy?: string | undefined;
        /**
         * an AbortController which can be used
         * to cancel a telemetry request
         */
        signal?: AbortController | undefined;
        /**
         * the domain key of the request
         */
        domain?: string | undefined;
        /**
         * the time context to use for this request
         */
        timeContext?: any;
    };
    /**
     * Describes and bounds requests for telemetry data.
     */
    export type TelemetrySubscriptionOptions = {
        /**
         * symbolic identifier directing providers on how
         * to handle telemetry subscriptions. The default behavior is 'latest' which will
         * always return a single telemetry value with each callback, and in the event
         * of throttling will always prioritize the latest data, meaning intermediate
         * data will be skipped. Alternatively, the `batch` strategy can be used, which
         * will return all telemetry values since the last callback. This strategy is
         * useful for cases where intermediate data is important, such as when
         * rendering a telemetry plot or table. If `batch` is specified, the subscription
         * callback will be invoked with an Array.
         */
        strategy?: string | undefined;
    };
    /**
     * A violation of limits defined for a telemetry property.
     */
    export type LimitViolation = {
        /**
         * the class (or space-separated classes) to
         * apply to display elements for values which violate this limit
         */
        cssClass: string;
        /**
         * the human-readable name for the limit violation
         */
        name: string;
        /**
         * a lower limit for violation
         */
        low: number;
        /**
         * a higher limit violation
         */
        high: number;
    };
    export type LimitsResponseObject = {
        /**
         * the level name and it's limit definition
         */
        limitLevel: LimitDefinition;
    };
    /**
     * Limit defined for a telemetry property.
     */
    export type LimitDefinition = {
        /**
         * a lower limit
         */
        low: LimitDefinitionValue;
        /**
         * a higher limit
         */
        high: LimitDefinitionValue;
    };
    /**
     * Limit definition for a Limit of a telemetry property.
     */
    export type LimitDefinitionValue = {
        /**
         * color to represent this limit
         */
        color: string;
        /**
         * the limit value
         */
        value: number;
    };
    /**
     * Describes a property which would be found in a datum of telemetry
     * associated with a particular domain object.
     */
    export type TelemetryProperty = {
        /**
         * the name of the property in the datum which
         * contains this telemetry value
         */
        key: string;
        /**
         * the human-readable name for this property
         */
        name: string;
        /**
         * the units associated with this property
         */
        units?: string | undefined;
        /**
         * true if this property is a timestamp, or
         * may be otherwise used to order telemetry in a time-like
         * fashion; default is false
         */
        temporal?: boolean | undefined;
        /**
         * true if the values for this property
         * can be interpreted plainly as numbers; default is true
         */
        numeric?: boolean | undefined;
        /**
         * true if this property may have only
         * certain specific values; default is false
         */
        enumerated?: boolean | undefined;
        /**
         * for enumerated states, an ordered list
         * of possible values
         */
        values?: string | undefined;
    };
    /**
     * Describes and bounds requests for telemetry data.
     */
    export type TelemetryRequest = {
        /**
         * the key of the property to sort by. This may
         * be prefixed with a "+" or a "-" sign to sort in ascending
         * or descending order respectively. If no prefix is present,
         * ascending order will be used.
         */
        sort: string;
        /**
         * the lower bound for values of the sorting property
         */
        start: any;
        /**
         * the upper bound for values of the sorting property
         */
        end: any;
        /**
         * symbolic identifiers for strategies
         * (such as `minmax`) which may be recognized by providers;
         * these will be tried in order until an appropriate provider
         * is found
         */
        strategies: string[];
    };
    export type StalenessResponseObject = {
        /**
         * boolean representing the staleness state
         */
        isStale: boolean;
        /**
         * Unix timestamp in milliseconds
         */
        timestamp: number;
    };
    import DefaultMetadataProvider from "src/api/telemetry/DefaultMetadataProvider";
    import TelemetryRequestInterceptorRegistry from "src/api/telemetry/TelemetryRequestInterceptor";
    import BatchingWebSocket from "src/api/telemetry/BatchingWebSocket";
    import CustomStringFormatter from "src/plugins/displayLayout/CustomStringFormatter";
    import TelemetryCollection from "src/api/telemetry/TelemetryCollection";
    import TelemetryMetadataManager from "src/api/telemetry/TelemetryMetadataManager";
    import TelemetryValueFormatter from "src/api/telemetry/TelemetryValueFormatter";
}
declare module "src/api/tooltips/ToolTip" {
    export default Tooltip;
    class Tooltip extends EventEmitter<string | symbol, any> {
        constructor({ toolTipText, toolTipLocation, parentElement }?: {
            tooltipText: string;
            toolTipLocation: string;
            parentElement: null;
            toolTipText: any;
        });
        component: any;
        _destroy: any;
        isActive: boolean | null;
        destroy(): void;
        /**
         * @private
         **/
        private show;
    }
    import { EventEmitter } from "eventemitter3";
}
declare module "src/api/tooltips/ToolTipAPI" {
    export default TooltipAPI;
    /**
     * The TooltipAPI is responsible for adding custom tooltips to
     * the desired elements on the screen
     *
     * @constructor
     */
    class TooltipAPI {
        activeToolTips: any[];
        TOOLTIP_LOCATIONS: Readonly<{
            ABOVE: "above";
            BELOW: "below";
            RIGHT: "right";
            LEFT: "left";
            CENTER: "center";
        }>;
        /**
         * @private for platform-internal use
         */
        private showTooltip;
        /**
         * API method to allow for removing all tooltips
         */
        removeAllTooltips(): void;
        /**
         * A description of option properties that can be passed into the tooltip
         * @typedef {Object} TooltipOptions
         * @property {string} tooltipText text to show in the tooltip
         * @property {TOOLTIP_LOCATIONS} tooltipLocation location to show the tooltip relative to the parentElement
         * @property {HTMLElement} parentElement reference to the DOM node we're adding the tooltip to
         */
        /**
         * Tooltips take an options object that consists of the string, tooltipLocation, and parentElement
         * @param {TooltipOptions} options
         */
        tooltip(options: {
            /**
             * text to show in the tooltip
             */
            tooltipText: string;
            /**
             * location to show the tooltip relative to the parentElement
             */
            tooltipLocation: TOOLTIP_LOCATIONS;
            /**
             * reference to the DOM node we're adding the tooltip to
             */
            parentElement: HTMLElement;
        }): Tooltip;
    }
    /**
     * TooltipLocation
     */
    type TOOLTIP_LOCATIONS = string;
    /**
     * @readonly
     * @enum {string} TooltipLocation
     * @property {string} ABOVE The string for locating tooltips above an element
     * @property {string} BELOW The string for locating tooltips below an element
     * @property {string} RIGHT The pixel-spatial annotation type
     * @property {string} LEFT The temporal annotation type
     * @property {string} CENTER The plot-spatial annotation type
     */
    const TOOLTIP_LOCATIONS: Readonly<{
        ABOVE: "above";
        BELOW: "below";
        RIGHT: "right";
        LEFT: "left";
        CENTER: "center";
    }>;
    import Tooltip from "src/api/tooltips/ToolTip";
}
declare module "src/api/types/Type" {
    /*****************************************************************************
     * Open MCT, Copyright (c) 2014-2024, United States Government
     * as represented by the Administrator of the National Aeronautics and Space
     * Administration. All rights reserved.
     *
     * Open MCT is licensed under the Apache License, Version 2.0 (the
     * "License"); you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     * http://www.apache.org/licenses/LICENSE-2.0.
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
     * License for the specific language governing permissions and limitations
     * under the License.
     *
     * Open MCT includes source code licensed under additional open source
     * licenses. See the Open Source Licenses file (LICENSES.md) included with
     * this source code distribution or the Licensing information page available
     * at runtime from the About dialog for additional information.
     *****************************************************************************/
    /**
     * A Type describes a kind of domain object that may appear or be
     * created within Open MCT.
     */
    export default class Type {
        /**
         * Convert a legacy type definition to the new format.
         * @param {LegacyTypeDefinition} legacyDefinition
         * @returns {TypeDefinition}
         */
        static definitionFromLegacyDefinition(legacyDefinition: LegacyTypeDefinition): TypeDefinition;
        /**
         * @param {TypeDefinition} definition
         */
        constructor(definition: TypeDefinition);
        definition: TypeDefinition;
        key: string | undefined;
        /**
         * Check if a domain object is an instance of this type.
         * @param {DomainObject} domainObject
         * @returns {boolean} true if the domain object is of this type
         */
        check(domainObject: DomainObject): boolean;
        /**
         * Get a definition for this type that can be registered using the
         * legacy bundle format.
         * @private
         */
        private toLegacyDefinition;
    }
    export type TypeDefinition = {
        key?: string | undefined;
        name: string;
        cssClass: string;
        description: string;
        form: Form;
        telemetry: Telemetry;
        initialize: (arg0: any) => void;
        creatable: boolean;
    };
    export type DomainObject = import("openmct").DomainObject;
}
declare module "src/api/types/TypeRegistry" {
    /**
     * @typedef TypeDefinition
     * @property {string} label the name for this type of object
     * @property {string} description a longer-form description of this type
     * @property {function(domainObject:DomainObject): void} [initialize] a function which initializes
     *           the model for new domain objects of this type
     * @property {boolean} [creatable=false] true if users should be allowed to
     *           create this type (default: false)
     * @property {string} [cssClass] the CSS class to apply for icons
     */
    /**
     * A TypeRegistry maintains the definitions for different types
     * that domain objects may have.
     * @interface TypeRegistry
     */
    export default class TypeRegistry {
        /**
         * @type {Record<string, Type>}
         */
        types: Record<string, Type>;
        /**
         * Register a new object type.
         *
         * @param {string} typeKey a string identifier for this type
         * @param {TypeDefinition} typeDef the type to add
         */
        addType(typeKey: string, typeDef: TypeDefinition): void;
        /**
         * Takes a typeDef, standardizes it, and logs warnings about unsupported
         * usage.
         * @private
         */
        private standardizeType;
        /**
         * List keys for all registered types.
         * @returns {string[]} all registered type keys
         */
        listKeys(): string[];
        /**
         * Retrieve a registered type by its key.
         * @param {string} typeKey the key for this type
         * @returns {Type} the registered type
         */
        get(typeKey: string): Type;
        importLegacyTypes(types: any): void;
    }
    export type TypeDefinition = {
        /**
         * the name for this type of object
         */
        label: string;
        /**
         * a longer-form description of this type
         */
        description: string;
        /**
         * ): void} [initialize] a function which initializes
         * the model for new domain objects of this type
         */
        "": (arg0: domainObject) => DomainObject;
        /**
         * true if users should be allowed to
         * create this type (default: false)
         */
        creatable?: boolean | undefined;
        /**
         * the CSS class to apply for icons
         */
        cssClass?: string | undefined;
    };
    import Type from "src/api/types/Type";
}
declare module "src/api/user/constants" {
    /*****************************************************************************
     * Open MCT, Copyright (c) 2014-2024, United States Government
     * as represented by the Administrator of the National Aeronautics and Space
     * Administration. All rights reserved.
     *
     * Open MCT is licensed under the Apache License, Version 2.0 (the
     * "License"); you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     * http://www.apache.org/licenses/LICENSE-2.0.
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
     * License for the specific language governing permissions and limitations
     * under the License.
     *
     * Open MCT includes source code licensed under additional open source
     * licenses. See the Open Source Licenses file (LICENSES.md) included with
     * this source code distribution or the Licensing information page available
     * at runtime from the About dialog for additional information.
     *****************************************************************************/
    export const MULTIPLE_PROVIDER_ERROR: "Only one user provider may be set at a time.";
    export const NO_PROVIDER_ERROR: "No user provider has been set.";
    export const ACTIVE_ROLE_LOCAL_STORAGE_KEY: "ACTIVE_USER_ROLE";
    export const ACTIVE_ROLE_BROADCAST_CHANNEL_NAME: "ActiveRoleChannel";
}
declare module "src/api/user/UserProvider" {
    /*****************************************************************************
     * Open MCT, Copyright (c) 2014-2024, United States Government
     * as represented by the Administrator of the National Aeronautics and Space
     * Administration. All rights reserved.
     *
     * Open MCT is licensed under the Apache License, Version 2.0 (the
     * "License"); you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     * http://www.apache.org/licenses/LICENSE-2.0.
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
     * License for the specific language governing permissions and limitations
     * under the License.
     *
     * Open MCT includes source code licensed under additional open source
     * licenses. See the Open Source Licenses file (LICENSES.md) included with
     * this source code distribution or the Licensing information page available
     * at runtime from the About dialog for additional information.
     *****************************************************************************/
    /**
     * A user provider is responsible for providing information about the currently
     * logged in user. This includes information about the user's roles, and whether
     * the user is currently logged in.
     */
    export default class UserProvider {
        /**
         * @returns {Promise<User>} A promise that resolves with the currently logged in user
         */
        getCurrentUser(): Promise<User>;
        /**
         * @returns {boolean} true if a user is currently logged in, otherwise false
         */
        isLoggedIn(): boolean;
        /**
         * @param {string} role
         * @returns {Promise<boolean>} true if the current user has the given role
         */
        hasRole(role: string): Promise<boolean>;
    }
}
declare module "src/api/user/StatusUserProvider" {
    export default class StatusUserProvider extends UserProvider {
        /**
         * @param {('statusChange'|'pollQuestionChange'|'missionActionStatusChange')} event the name of the event to listen to
         * @param {Function} callback a function to invoke when this event occurs
         */
        on(event: ('statusChange' | 'pollQuestionChange' | 'missionActionStatusChange'), callback: Function): void;
        /**
         * @param {('statusChange'|'pollQuestionChange'|'missionActionStatusChange')} event the name of the event to stop listen to
         * @param {Function} callback the callback function used to register the listener
         */
        off(event: ('statusChange' | 'pollQuestionChange' | 'missionActionStatusChange'), callback: Function): void;
        /**
         * @returns {import("./StatusAPI").PollQuestion} the current status poll question
         */
        getPollQuestion(): import("./StatusAPI").PollQuestion;
        /**
         * @param {import("./StatusAPI").PollQuestion} pollQuestion a new poll question to set
         * @returns {Promise<Boolean>} true if operation was successful, otherwise false
         */
        setPollQuestion(pollQuestion: import("./StatusAPI").PollQuestion): Promise<boolean>;
        /**
         * @returns {Promise<Boolean>} true if the current user can set the poll question, otherwise false
         */
        canSetPollQuestion(): Promise<boolean>;
        /**
         * @returns {Promise<Array<import("./StatusAPI").Status>>} a list of the possible statuses that an operator can be in
         */
        getPossibleStatuses(): Promise<Array<import("./StatusAPI").Status>>;
        /**
         * @param {import("./UserAPI").Role} role
         * @returns {Promise<import("./StatusAPI").Status}
         */
        getStatusForRole(role: import("./UserAPI").Role): Promise<import("./StatusAPI").Status>;
        /**
         * @param {import("./UserAPI").Role} role
         * @returns {Promise<import("./StatusAPI").Status}
         */
        getDefaultStatusForRole(role: import("./UserAPI").Role): Promise<import("./StatusAPI").Status>;
        /**
         * @param {import("./UserAPI").Role} role
         * @param {*} status
         * @returns {Promise<Boolean>} true if operation was successful, otherwise false.
         */
        setStatusForRole(role: import("./UserAPI").Role, status: any): Promise<boolean>;
        /**
         * @param {import("./UserAPI").Role} role
         * @returns {Promise<Boolean} true if the user provider can provide status for the given role
         */
        canProvideStatusForRole(role: import("./UserAPI").Role): Promise<boolean>;
        /**
         * @returns {Promise<Array<import("./UserAPI").Role>>} a list of all available status roles, if user permissions allow it.
         */
        getAllStatusRoles(): Promise<Array<import("./UserAPI").Role>>;
    }
    import UserProvider from "src/api/user/UserProvider";
}
declare module "src/api/user/StatusAPI" {
    /**
     * The StatusAPI is used to get and set various statuses linked to the current logged in user.
     * This includes the ability to set the status of the current user as a response to a poll question,
     * set the poll question itself, and the ability to set the status of mission actions.
     *
     * @augments EventEmitter
     */
    export default class StatusAPI extends EventEmitter<string | symbol, any> {
        /**
         * @param {UserAPI} userAPI
         * @param {OpenMCT} openmct
         */
        constructor(userAPI: UserAPI, openmct: OpenMCT);
        /**
         * Emit a status change event
         * @private
         */
        private onProviderStatusChange;
        /**
         * Emit a poll question change event
         * @private
         */
        private onProviderPollQuestionChange;
        /**
         * Emit a mission action status change event
         * @private
         */
        private onMissionActionStatusChange;
        /**
         * Listen to status events from the UserProvider
         * @private
         */
        private listenToStatusEvents;
        /**
         * Fetch the currently defined operator status poll question. When presented with a status poll question, all operators will reply with their current status.
         * @returns {Promise<PollQuestion>}
         */
        getPollQuestion(): Promise<PollQuestion>;
        /**
         * Set a poll question for operators to respond to. When presented with a status poll question, all operators will reply with their current status.
         * @param {string} questionText - The text of the question
         * @returns {Promise<Boolean>} true if operation was successful, otherwise false.
         */
        setPollQuestion(questionText: string): Promise<boolean>;
        /**
         * Can the currently logged in user set the operator status poll question.
         * @returns {Promise<Boolean>}
         */
        canSetPollQuestion(): Promise<boolean>;
        /**
         * Can the currently logged in user set the mission status.
         * @returns {Promise<Boolean>} true if the currently logged in user can set the mission status, false otherwise.
         */
        canSetMissionStatus(): Promise<boolean>;
        /**
         * Fetch the current status for the given mission action
         * @param {MissionAction} action
         * @returns {string}
         */
        getStatusForMissionAction(action: MissionAction): string;
        /**
         * Fetch the list of possible mission status options (GO, NO-GO, etc.)
         * @returns {Promise<MissionStatusOption[]>} the complete list of possible mission statuses
         */
        getPossibleMissionActionStatuses(): Promise<MissionStatusOption[]>;
        /**
         * Fetch the list of possible mission actions
         * @returns {Promise<string[]>} the list of possible mission actions
         */
        getPossibleMissionActions(): Promise<string[]>;
        /**
         * @returns {Promise<Array<Status>>} the complete list of possible states that an operator can reply to a poll question with.
         */
        getPossibleStatuses(): Promise<Array<Status>>;
        /**
         * @param {import("./UserAPI").Role} role The role to fetch the current status for.
         * @returns {Promise<Status>} the current status of the provided role
         */
        getStatusForRole(role: import("./UserAPI").Role): Promise<Status>;
        /**
         * @param {import("./UserAPI").Role} role
         * @returns {Promise<Boolean>} true if the configured UserProvider can provide status for the given role
         * @see StatusUserProvider
         */
        canProvideStatusForRole(role: import("./UserAPI").Role): Promise<boolean>;
        /**
         * @param {import("./UserAPI").Role} role The role to set the status for.
         * @param {Status} status The status to set for the provided role
         * @returns {Promise<Boolean>} true if operation was successful, otherwise false.
         */
        setStatusForRole(status: Status): Promise<boolean>;
        /**
         * @param {MissionAction} action
         * @param {MissionStatusOption} status
         * @returns {Promise<Boolean>} true if operation was successful, otherwise false.
         */
        setStatusForMissionAction(action: MissionAction, status: MissionStatusOption): Promise<boolean>;
        /**
         * Resets the status of the provided role back to its default status.
         * @param {import("./UserAPI").Role} role The role to set the status for.
         * @returns {Promise<Boolean>} true if operation was successful, otherwise false.
         */
        resetStatusForRole(role: import("./UserAPI").Role): Promise<boolean>;
        /**
         * Resets the status of all operators to their default status
         * @returns {Promise<Boolean>} true if operation was successful, otherwise false.
         */
        resetAllStatuses(): Promise<boolean>;
        /**
         * The default status. This is the status that will be used before the user has selected any status.
         * @param {import("./UserAPI").Role} role
         * @returns {Promise<Status>} the default operator status if no other has been set.
         */
        getDefaultStatusForRole(role: import("./UserAPI").Role): Promise<Status>;
        /**
         * All possible status roles. A status role is a user role that can provide status. In some systems
         * this may be all user roles, but there may be cases where some users are not are not polled
         * for status if they do not have a real-time operational role.
         *
         * @returns {Promise<Array<import("./UserAPI").Role>>} the default operator status if no other has been set.
         */
        getAllStatusRoles(): Promise<Array<import("./UserAPI").Role>>;
        /**
         * @returns {Promise<Boolean>} true if the configured UserProvider can provide status for the currently logged in user, false otherwise.
         * @see StatusUserProvider
         */
        canProvideStatusForCurrentUser(): Promise<boolean>;
        #private;
    }
    export type UserAPI = import("src/api/user/UserAPI").default;
    export type OpenMCT = import("openmct").OpenMCT;
    export type UserProvider = typeof import("src/api/user/UserProvider");
    export type StatusUserProvider = typeof import("src/api/user/StatusUserProvider");
    /**
     * The PollQuestion type
     */
    export type PollQuestion = {
        /**
         * - The question to be presented to users
         */
        question: string;
        /**
         * - The time that the poll question was set.
         */
        timestamp: number;
    };
    export type MissionAction = {
        /**
         * A unique identifier for this action
         */
        key: string;
        /**
         * A human readable label for this action
         */
        label: string;
    };
    /**
     * The MissionStatusOption type, extends Status.
     */
    export type MissionStatusOption = {
        /**
         * - A unique identifier for this status.
         */
        key: string;
        /**
         * - A human-readable label for this status.
         */
        label: string;
        /**
         * - The time that the status was set.
         */
        timestamp: number;
        /**
         * - A color to be used when displaying the mission status.
         */
        color: string;
    };
    /**
     * The Status type
     */
    export type Status = {
        /**
         * - A unique identifier for this status
         */
        key: string;
        /**
         * - A human readable label for this status
         */
        label: string;
        /**
         * - The time that the status was set.
         */
        timestamp: number;
    };
    import { EventEmitter } from "eventemitter3";
}
declare module "src/api/user/StoragePersistence" {
    const _default: StoragePersistence;
    export default _default;
    class StoragePersistence {
        getActiveRole(): string | null;
        setActiveRole(role: any): void;
        clearActiveRole(): void;
    }
}
declare module "src/api/user/User" {
    /*****************************************************************************
     * Open MCT, Copyright (c) 2014-2024, United States Government
     * as represented by the Administrator of the National Aeronautics and Space
     * Administration. All rights reserved.
     *
     * Open MCT is licensed under the Apache License, Version 2.0 (the
     * "License"); you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     * http://www.apache.org/licenses/LICENSE-2.0.
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
     * License for the specific language governing permissions and limitations
     * under the License.
     *
     * Open MCT includes source code licensed under additional open source
     * licenses. See the Open Source Licenses file (LICENSES.md) included with
     * this source code distribution or the Licensing information page available
     * at runtime from the About dialog for additional information.
     *****************************************************************************/
    /**
     * The example User class.
     */
    export default class User {
        constructor(id: any, name: any);
        id: any;
        name: any;
        getId(): any;
        getName(): any;
    }
}
declare module "src/api/user/UserAPI" {
    export default UserAPI;
    export type Role = string;
    export type OpenMCT = import("src/MCT").MCT;
    export type UserAPIConfiguration = {
        statusStyles: Record<string, StatusStyleDefinition>;
    };
    export type UserProvider = any;
    export type StatusStyleDefinition = {
        /**
         * The icon class to apply to the status indicator when this status is active "icon-circle-slash",
         */
        iconClass: string;
        /**
         * The icon class to apply to the poll question indicator when this style is active eg. "icon-status-poll-question-mark"
         */
        iconClassPoll: string;
        /**
         * The class to apply to the indicator when this status is active eg. "s-status-error"
         */
        statusClass: string;
        /**
         * The background color to apply in the status summary section of the poll question popup for this status eg."#9900cc"
         */
        statusBgColor: string;
        /**
         * The foreground color to apply in the status summary section of the poll question popup for this status eg. "#fff"
         */
        statusFgColor: string;
    };
    class UserAPI extends EventEmitter<string | symbol, any> {
        /**
         * @param {OpenMCT} openmct
         */
        constructor(openmct: OpenMCT);
        _provider: any;
        User: typeof User;
        status: StatusAPI;
        /**
         * Set the user provider for the user API. This allows you
         *  to specify ONE user provider to be used with Open MCT.
         * @method setProvider
         * @param {module:openmct.UserAPI~UserProvider} provider the new
         *        user provider
         */
        setProvider(provider: any): void;
        getProvider(): any;
        /**
         * Return true if the user provider has been set.
         *
         * @returns {boolean} true if the user provider exists
         */
        hasProvider(): boolean;
        /**
         * If a user provider is set, it will return a copy of a user object from
         * the provider. If the user is not logged in, it will return undefined;
         *
         * @returns {Function|Promise} user provider 'getCurrentUser' method
         * @throws Will throw an error if no user provider is set
         */
        getCurrentUser(): Function | Promise<any>;
        /**
         *  If a user provider is set, it will return an array of possible roles
         *  that can be selected by the current user
         *  @returns {Array}
         *  @throws Will throw an error if no user provider is set
         */
        getPossibleRoles(): any[];
        /**
         * If a user provider is set, it will return the active role or null
         * @returns {string|null}
         */
        getActiveRole(): string | null;
        /**
         * Set the active role in session storage
         * @returns {undefined}
         */
        setActiveRole(role: any): undefined;
        /**
         * Will return if a role can provide a operator status response
         * @returns {boolean}
         */
        canProvideStatusForRole(): boolean;
        /**
         * If a user provider is set, it will return the user provider's
         * 'isLoggedIn' method
         *
         * @returns {Function|Boolean} user provider 'isLoggedIn' method
         * @throws Will throw an error if no user provider is set
         */
        isLoggedIn(): Function | boolean;
        /**
         * If a user provider is set, it will return a call to it's
         * 'hasRole' method
         *
         * @returns {Function|boolean} user provider 'isLoggedIn' method
         * @param {string} roleId id of role to check for
         * @throws Will throw an error if no user provider is set
         */
        hasRole(roleId: string): Function | boolean;
        /**
         * Checks if a provider is set and if not, will throw error
         *
         * @private
         * @throws Will throw an error if no user provider is set
         */
        private noProviderCheck;
        /**
         * Utility function for throwing errors
         *
         * @private
         * @param {string} error description of error
         * @throws Will throw error passed in
         */
        private error;
        #private;
    }
    import { EventEmitter } from "eventemitter3";
    import User from "src/api/user/User";
    import StatusAPI from "src/api/user/StatusAPI";
}
declare module "src/plugins/duplicate/DuplicateTask" {
    /**
     * This class encapsulates the process of  duplicating/copying a domain object
     * and all of its children.
     *
     * @param {DomainObject} domainObject The object to duplicate
     * @param {DomainObject} parent The new location of the cloned object tree
     * @param {src/plugins/duplicate.DuplicateService~filter} filter
     *        a function used to filter out objects from
     *        the cloning process
     * @constructor
     */
    export default class DuplicateTask {
        constructor(openmct: any);
        domainObject: any;
        parent: any;
        firstClone: any;
        filter: any;
        persisted: number;
        clones: any[];
        idMap: {};
        name: any;
        openmct: any;
        changeName(name: any): void;
        /**
         * Execute the duplicate/copy task with the objects provided.
         * @returns {promise} Which will resolve with a clone of the object
         * once complete.
         */
        duplicate(domainObject: any, parent: any, filter: any): Promise<any>;
        namespace: any;
        /**
         * Will build a graph of an object and all of its child objects in
         * memory
         * @private
         * @param domainObject The original object to be copied
         * @param parent The parent of the original object to be copied
         * @returns {Promise} resolved with an array of clones of the models
         * of the object tree being copied. Duplicating is done in a bottom-up
         * fashion, so that the last member in the array is a clone of the model
         * object being copied. The clones are all full composed with
         * references to their own children.
         */
        private buildDuplicationPlan;
        /**
         * Will persist a list of {@link objectClones}. It will persist all
         * simultaneously, irrespective of order in the list. This may
         * result in automatic request batching by the browser.
         */
        persistObjects(): Promise<void>;
        /**
         * Will add a list of clones to the specified parent's composition
         */
        addClonesToParent(): Promise<void>;
        /**
         * A recursive function that will perform a bottom-up duplicate of
         * the object tree with originalObject at the root. Recurses to
         * the farthest leaf, then works its way back up again,
         * cloning objects, and composing them with their child clones
         * as it goes
         * @private
         * @returns {DomainObject} If the type of the original object allows for
         * duplication, then a duplicate of the object, otherwise the object
         * itself (to allow linking to non duplicatable objects).
         */
        private duplicateObject;
        /**
         * Given an array of objects composed by a parent, clone them, then
         * add them to the parent.
         * @private
         * @returns {*}
         */
        private duplicateComposees;
        /**
         * Update identifiers in a cloned object model (or part of
         * a cloned object model) to reflect new identifiers after
         * duplicating.
         * @private
         */
        private rewriteIdentifiers;
        composeChild(child: any, parent: any, setLocation: any): void;
        getTypeDefinition(domainObject: any, definition: any): any;
        cloneObjectModel(domainObject: any): any;
        getKeyString(domainObject: any): any;
        isCreatable(domainObject: any): any;
    }
}
declare module "src/plugins/duplicate/DuplicateAction" {
    export default DuplicateAction;
    export const DUPLICATE_ACTION_KEY: "duplicate";
    class DuplicateAction {
        constructor(openmct: any);
        name: string;
        key: string;
        description: string;
        cssClass: string;
        group: string;
        priority: number;
        openmct: any;
        transaction: any;
        invoke(objectPath: any): void;
        object: any;
        parent: any;
        inNavigationPath(): any;
        onSave(changes: any): Promise<void>;
        showForm(domainObject: any, parentDomainObject: any): void;
        validate(currentParent: any): (data: any) => any;
        appliesTo(objectPath: any): any;
        startTransaction(): void;
        saveTransaction(): Promise<void>;
    }
}
declare module "src/plugins/duplicate/plugin" {
    export default function _default(): (openmct: any) => void;
}
declare module "src/plugins/exportAsJSONAction/ExportAsJSONAction" {
    export default ExportAsJSONAction;
    export const EXPORT_AS_JSON_ACTION_KEY: "export.JSON";
    class ExportAsJSONAction {
        /**
         * @param {import('../../../openmct').OpenMCT} openmct The Open MCT API
         */
        constructor(openmct: import('../../../openmct').OpenMCT);
        /**
         *
         * @param {import('../../api/objects/ObjectAPI').DomainObject[]} objectPath
         */
        invoke(objectPath: import('../../api/objects/ObjectAPI').DomainObject[]): void;
        /**
         *
         * @param {Object} objectPath
         * @returns {boolean}
         */
        appliesTo(objectPath: any): boolean;
        /**
         * @private
         * @param {Object} completedTree
         */
        private saveAs;
        name: string;
        key: string;
        description: string;
        cssClass: string;
        group: string;
        priority: number;
        tree: any;
        calls: number | null;
        idMap: {} | null;
        dialog: import("src/api/overlays/ProgressDialog").default | null;
        progressPerc: number;
        exportedCount: number;
        totalToExport: number;
        JSONExportService: any;
        root: any;
        #private;
    }
}
declare module "src/plugins/exportAsJSONAction/plugin" {
    export default function _default(): (openmct: any) => void;
}
declare module "src/plugins/imagery/actions/OpenImageInNewTabAction" {
    export default OpenImageInNewTabAction;
    /*****************************************************************************
     * Open MCT, Copyright (c) 2014-2024, United States Government
     * as represented by the Administrator of the National Aeronautics and Space
     * Administration. All rights reserved.
     *
     * Open MCT is licensed under the Apache License, Version 2.0 (the
     * "License"); you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     * http://www.apache.org/licenses/LICENSE-2.0.
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
     * License for the specific language governing permissions and limitations
     * under the License.
     *
     * Open MCT includes source code licensed under additional open source
     * licenses. See the Open Source Licenses file (LICENSES.md) included with
     * this source code distribution or the Licensing information page available
     * at runtime from the About dialog for additional information.
     *****************************************************************************/
    export const OPEN_IMAGE_IN_NEW_TAB_ACTION_KEY: "openImageInNewTab";
    class OpenImageInNewTabAction {
        constructor(openmct: any);
        openmct: any;
        cssClass: string;
        description: string;
        group: string;
        key: string;
        name: string;
        priority: number;
        invoke(objectPath: any, view: any): void;
        appliesTo(objectPath: any, view?: {}): false | undefined;
    }
}
declare module "src/plugins/imagery/actions/SaveImageAsAction" {
    export default SaveImageAction;
    /*****************************************************************************
     * Open MCT, Copyright (c) 2014-2024, United States Government
     * as represented by the Administrator of the National Aeronautics and Space
     * Administration. All rights reserved.
     *
     * Open MCT is licensed under the Apache License, Version 2.0 (the
     * "License"); you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     * http://www.apache.org/licenses/LICENSE-2.0.
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
     * License for the specific language governing permissions and limitations
     * under the License.
     *
     * Open MCT includes source code licensed under additional open source
     * licenses. See the Open Source Licenses file (LICENSES.md) included with
     * this source code distribution or the Licensing information page available
     * at runtime from the About dialog for additional information.
     *****************************************************************************/
    export const SAVE_IMAGE_ACTION_KEY: "saveImageAs";
    class SaveImageAction {
        constructor(openmct: any);
        openmct: any;
        cssClass: string;
        description: string;
        group: string;
        key: string;
        name: string;
        priority: number;
        invoke(objectPath: any, view: any): Promise<void>;
        appliesTo(objectPath: any, view?: {}): false | undefined;
    }
}
declare module "src/plugins/imagery/ImageryTimestripViewProvider" {
    export default function ImageryTimestripViewProvider(openmct: any): {
        key: string;
        name: string;
        cssClass: string;
        canView: (domainObject: any, objectPath: any) => any;
        view: (domainObject: any, objectPath: any) => {
            show: (element: any) => void;
            destroy: () => void;
            getComponent(): any;
        };
    };
}
declare module "src/plugins/imagery/ImageryView" {
    export default class ImageryView {
        constructor(openmct: any, domainObject: any, objectPath: any, options: any);
        openmct: any;
        domainObject: any;
        objectPath: any;
        options: any;
        component: any;
        _destroy: any;
        show(element: any, isEditing: any, viewOptions: any): void;
        getViewContext(): any;
        pause(): void;
        previouslyPaused: any;
        unpause(): void;
        onPreviewModeChange({ isPreviewing }?: {
            isPreviewing: any;
        }): void;
        destroy(): void;
        _getInstance(): any;
    }
}
declare module "src/plugins/imagery/ImageryViewProvider" {
    export default function ImageryViewProvider(openmct: any, options: any): {
        key: string;
        name: string;
        cssClass: string;
        canView: (domainObject: any, objectPath: any) => any;
        view: (domainObject: any, objectPath: any) => ImageryView;
    };
    import ImageryView from "src/plugins/imagery/ImageryView";
}
declare module "src/plugins/imagery/plugin" {
    export default function _default(options: any): (openmct: any) => void;
}
declare module "src/plugins/importFromJSONAction/ImportFromJSONAction" {
    export default ImportFromJSONAction;
    export const IMPORT_FROM_JSON_ACTION_KEY: "import.JSON";
    class ImportFromJSONAction {
        constructor(openmct: any);
        name: string;
        key: string;
        description: string;
        cssClass: string;
        group: string;
        priority: number;
        openmct: any;
        /**
         *
         * @param {Object} objectPath
         * @returns {boolean}
         */
        appliesTo(objectPath: any): boolean;
        /**
         *
         * @param {Object} objectPath
         */
        invoke(objectPath: any): void;
        /**
         *
         * @param {Object} object
         * @param {Object} changes
         */
        onSave(object: any, changes: any): void;
        /**
         * @private
         * @param {Object} parent
         * @param {Object} tree
         * @param {Object} seen
         * @param {Array} objectsToCreate tracks objects from import json that will need to be created
         */
        private _deepInstantiate;
        /**
         * @private
         * @param {Object} parent
         * @returns [identifiers]
         */
        private _getObjectReferenceIds;
        /**
         * Generates a map of old IDs to new IDs for efficient lookup during tree walking.
         * This function considers cases where original namespaces are blank and updates those IDs as well.
         *
         * @param {Object} tree - The object tree containing the old IDs.
         * @param {string} newNamespace - The namespace for the new IDs.
         * @returns {Object} A map of old IDs to new IDs.
         */
        _generateIdMap(tree: any, newNamespace: string): any;
        /**
         * Walks through the object tree and updates IDs according to the provided ID map.
         * @param {Object} obj - The current object being visited in the tree.
         * @param {Object} idMap - A map of old IDs to new IDs for rewriting.
         * @param {Object} importDialog - Optional progress dialog for import.
         * @returns {Promise<Object>} The object with updated IDs.
         */
        _walkAndRewriteIds(obj: any, idMap: any, importDialog: any): Promise<any>;
        /**
         * @private
         * @param {Object} tree
         * @returns {Promise<Object>}
         */
        private _generateNewIdentifiers;
        /**
         * @private
         * @param {Object} domainObject
         * @param {Object} objTree
         */
        private _importObjectTree;
        /**
         * @private
         * @param {Object} model
         * @returns {Object}
         */
        private _instantiate;
        /**
         * @private
         * @param {Object} domainObject
         */
        private _showForm;
        /**
         * @private
         * @param {Object} data
         * @returns {boolean}
         */
        private _validateJSON;
    }
}
declare module "src/plugins/importFromJSONAction/plugin" {
    export default function _default(): (openmct: any) => void;
}
declare module "src/plugins/licenses/plugin" {
    export default function _default(): (openmct: any) => void;
}
declare module "src/plugins/linkAction/LinkAction" {
    export default LinkAction;
    /*****************************************************************************
     * Open MCT, Copyright (c) 2014-2024, United States Government
     * as represented by the Administrator of the National Aeronautics and Space
     * Administration. All rights reserved.
     *
     * Open MCT is licensed under the Apache License, Version 2.0 (the
     * "License"); you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     * http://www.apache.org/licenses/LICENSE-2.0.
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
     * License for the specific language governing permissions and limitations
     * under the License.
     *
     * Open MCT includes source code licensed under additional open source
     * licenses. See the Open Source Licenses file (LICENSES.md) included with
     * this source code distribution or the Licensing information page available
     * at runtime from the About dialog for additional information.
     *****************************************************************************/
    export const LINK_ACTION_KEY: "link";
    class LinkAction {
        constructor(openmct: any);
        name: string;
        key: string;
        description: string;
        cssClass: string;
        group: string;
        priority: number;
        openmct: any;
        transaction: any;
        appliesTo(objectPath: any): boolean;
        invoke(objectPath: any): void;
        object: any;
        parent: any;
        inNavigationPath(): any;
        onSave(changes: any): Promise<void>;
        linkInNewParent(child: any, newParent: any): void;
        showForm(domainObject: any, parentDomainObject: any): void;
        validate(currentParent: any): (data: any) => any;
        startTransaction(): void;
        saveTransaction(): Promise<void>;
    }
}
declare module "src/plugins/linkAction/plugin" {
    export default function _default(): (openmct: any) => void;
}
declare module "src/plugins/move/MoveAction" {
    export default MoveAction;
    /*****************************************************************************
     * Open MCT, Copyright (c) 2014-2024, United States Government
     * as represented by the Administrator of the National Aeronautics and Space
     * Administration. All rights reserved.
     *
     * Open MCT is licensed under the Apache License, Version 2.0 (the
     * "License"); you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     * http://www.apache.org/licenses/LICENSE-2.0.
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
     * License for the specific language governing permissions and limitations
     * under the License.
     *
     * Open MCT includes source code licensed under additional open source
     * licenses. See the Open Source Licenses file (LICENSES.md) included with
     * this source code distribution or the Licensing information page available
     * at runtime from the About dialog for additional information.
     *****************************************************************************/
    export const MOVE_ACTION_KEY: "move";
    class MoveAction {
        constructor(openmct: any);
        name: string;
        key: string;
        description: string;
        cssClass: string;
        group: string;
        priority: number;
        openmct: any;
        transaction: any;
        invoke(objectPath: any): void;
        object: any;
        oldParent: any;
        inNavigationPath(): any;
        navigateTo(objectPath: any): void;
        addToNewParent(child: any, newParent: any): void;
        onSave(changes: any): Promise<void>;
        removeFromOldParent(child: any): void;
        showForm(domainObject: any, parentDomainObject: any): void;
        validate(currentParent: any): (data: any) => any;
        appliesTo(objectPath: any): any;
        startTransaction(): void;
        saveTransaction(): Promise<void>;
    }
}
declare module "src/plugins/move/plugin" {
    export default function _default(): (openmct: any) => void;
}
declare module "example/dataVisualization/ExampleDataVisualizationSourceViewProvider" {
    export default function ExampleDataVisualizationSourceViewProvider(openmct: any): {
        key: string;
        name: string;
        cssClass: string;
        canView: (domainObject: any) => boolean;
        canEdit: (domainObject: any) => true | undefined;
        view: (domainObject: any) => {
            show: (element: any, isEditing: any) => void;
            destroy: () => void;
        };
        priority: () => number;
    };
}
declare module "example/dataVisualization/plugin" {
    export default function _default(): (openmct: any) => void;
}
declare module "example/eventGenerator/EventMetadataProvider" {
    export default EventMetadataProvider;
    /*****************************************************************************
     * Open MCT, Copyright (c) 2014-2024, United States Government
     * as represented by the Administrator of the National Aeronautics and Space
     * Administration. All rights reserved.
     *
     * Open MCT is licensed under the Apache License, Version 2.0 (the
     * "License"); you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     * http://www.apache.org/licenses/LICENSE-2.0.
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
     * License for the specific language governing permissions and limitations
     * under the License.
     *
     * Open MCT includes source code licensed under additional open source
     * licenses. See the Open Source Licenses file (LICENSES.md) included with
     * this source code distribution or the Licensing information page available
     * at runtime from the About dialog for additional information.
     *****************************************************************************/
    class EventMetadataProvider {
        METADATA_BY_TYPE: {
            eventGenerator: {
                values: ({
                    key: string;
                    name: string;
                    format: string;
                    hints?: undefined;
                } | {
                    key: string;
                    name: string;
                    format: string;
                    hints: {
                        domain: number;
                    };
                })[];
            };
        };
        supportsMetadata(domainObject: any): boolean;
        getMetadata(domainObject: any): any;
    }
}
declare module "example/eventGenerator/EventTelemetryProvider" {
    export default EventTelemetryProvider;
    class EventTelemetryProvider {
        defaultSize: number;
        generateData(firstObservedTime: any, count: any, startTime: any, duration: any, name: any): {
            name: any;
            utc: any;
            message: string;
        };
        supportsRequest(domainObject: any): boolean;
        supportsSubscribe(domainObject: any): boolean;
        subscribe(domainObject: any, callback: any): () => void;
        request(domainObject: any, options: any): Promise<{
            name: any;
            utc: any;
            message: string;
        }[]>;
    }
}
declare module "example/eventGenerator/plugin" {
    export default function EventGeneratorPlugin(options: any): (openmct: any) => void;
}
declare module "example/exampleTags/plugin" {
    /**
    @typedef {{
        namespaceToSaveAnnotations: string
    }} TagsPluginOptions
    */
    /**
     * @typedef {TagsPluginOptions} options
     * @returns {function} The plugin install function
     */
    export default function exampleTagsPlugin(options: any): Function;
    export type TagsPluginOptions = {
        namespaceToSaveAnnotations: string;
    };
    export type options = TagsPluginOptions;
}
declare module "example/exampleUser/exampleUserCreator" {
    /*****************************************************************************
     * Open MCT, Copyright (c) 2014-2024, United States Government
     * as represented by the Administrator of the National Aeronautics and Space
     * Administration. All rights reserved.
     *
     * Open MCT is licensed under the Apache License, Version 2.0 (the
     * "License"); you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     * http://www.apache.org/licenses/LICENSE-2.0.
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
     * License for the specific language governing permissions and limitations
     * under the License.
     *
     * Open MCT includes source code licensed under additional open source
     * licenses. See the Open Source Licenses file (LICENSES.md) included with
     * this source code distribution or the Licensing information page available
     * at runtime from the About dialog for additional information.
     *****************************************************************************/
    export default function createExampleUser(UserClass: any): {
        new (id: any, name: any, roles: any): {
            [x: string]: any;
            roles: any;
            getRoles(): any;
        };
        [x: string]: any;
    };
}
declare module "example/exampleUser/ExampleUserProvider" {
    /**
     * @implements {StatusUserProvider}
     */
    export default class ExampleUserProvider extends EventEmitter<string | symbol, any> implements StatusUserProvider {
        constructor(openmct: any, { statusRoles }?: {
            statusRoles: never[];
        });
        openmct: any;
        user: {
            [x: string]: any;
            roles: any;
            getRoles(): any;
        } | undefined;
        loggedIn: boolean;
        autoLoginUser: any;
        statusRoleValues: {
            role: never;
            status: {
                key: string;
                label: string;
                iconClass: string;
                iconClassPoll: string;
                statusClass?: undefined;
                statusBgColor?: undefined;
                statusFgColor?: undefined;
            } | {
                key: string;
                label: string;
                iconClass: string;
                iconClassPoll: string;
                statusClass: string;
                statusBgColor: string;
                statusFgColor: string;
            };
        }[];
        pollQuestion: {
            question: any;
            timestamp: number;
        } | undefined;
        statusRoles: never[];
        ExampleUser: {
            new (id: any, name: any, roles: any): {
                [x: string]: any;
                roles: any;
                getRoles(): any;
            };
            [x: string]: any;
        };
        loginPromise: any;
        isLoggedIn(): boolean;
        autoLogin(username: any): void;
        getCurrentUser(): any;
        canProvideStatusForRole(role: any): boolean;
        canSetPollQuestion(): Promise<boolean>;
        canSetMissionStatus(): Promise<boolean>;
        hasRole(roleId: any): Promise<any>;
        getPossibleRoles(): any;
        getPossibleMissionActions(): Promise<string[]>;
        getPossibleMissionActionStatuses(): Promise<{
            key: number;
            label: string;
        }[]>;
        getStatusForMissionAction(action: any): Promise<any>;
        setStatusForMissionAction(action: any, status: any): boolean;
        getAllStatusRoles(): Promise<never[]>;
        getStatusForRole(role: any): Promise<{
            key: string;
            label: string;
            iconClass: string;
            iconClassPoll: string;
            statusClass?: undefined;
            statusBgColor?: undefined;
            statusFgColor?: undefined;
        } | {
            key: string;
            label: string;
            iconClass: string;
            iconClassPoll: string;
            statusClass: string;
            statusBgColor: string;
            statusFgColor: string;
        } | undefined>;
        getDefaultStatusForRole(role: any): Promise<{
            key: string;
            label: string;
            iconClass: string;
            iconClassPoll: string;
            statusClass?: undefined;
            statusBgColor?: undefined;
            statusFgColor?: undefined;
        } | {
            key: string;
            label: string;
            iconClass: string;
            iconClassPoll: string;
            statusClass: string;
            statusBgColor: string;
            statusFgColor: string;
        }>;
        setStatusForRole(role: any, status: any): boolean;
        getPollQuestion(): Promise<{
            question: any;
            timestamp: number;
        } | undefined>;
        setPollQuestion(pollQuestion: any): boolean;
        getPossibleStatuses(): Promise<({
            key: string;
            label: string;
            iconClass: string;
            iconClassPoll: string;
            statusClass?: undefined;
            statusBgColor?: undefined;
            statusFgColor?: undefined;
        } | {
            key: string;
            label: string;
            iconClass: string;
            iconClassPoll: string;
            statusClass: string;
            statusBgColor: string;
            statusFgColor: string;
        })[]>;
        _login(): any;
        #private;
    }
    export type StatusUserProvider = any;
    import { EventEmitter } from "eventemitter3";
}
declare module "example/exampleUser/plugin" {
    export default function ExampleUserPlugin({ autoLoginUser, statusRoles }?: {
        autoLoginUser: string;
        statusRoles: string[];
    }): (openmct: any) => void;
}
declare module "example/faultManagement/utils" {
    export function shelveFault(fault: any, opts?: {
        shelved: boolean;
        comment: string;
        shelveDuration: number;
    }): void;
    export function acknowledgeFault(fault: any): void;
    export function randomFaults(staticFaults: any, count?: number): {
        type: any;
        fault: {
            acknowledged: boolean;
            currentValueInfo: {
                value: number;
                rangeCondition: string;
                monitoringResult: string;
            };
            id: string;
            name: string;
            namespace: string;
            seqNum: number;
            severity: string;
            shelved: boolean;
            shortDescription: string;
            triggerTime: number;
            triggerValueInfo: {
                value: number;
                rangeCondition: string;
                monitoringResult: string;
            };
        };
    }[];
}
declare module "example/faultManagement/exampleFaultSource" {
    export default function _default(staticFaults?: boolean): (openmct: any) => void;
}
declare module "example/generator/GeneratorMetadataProvider" {
    export default function GeneratorMetadataProvider(): void;
    export default class GeneratorMetadataProvider {
        supportsMetadata(domainObject: any): boolean;
        getMetadata(domainObject: any): any;
    }
}
declare module "example/generator/WorkerInterface" {
    export default function WorkerInterface(openmct: any, StalenessProvider: any): void;
    export default class WorkerInterface {
        constructor(openmct: any, StalenessProvider: any);
        StalenessProvider: any;
        worker: Worker;
        callbacks: {};
        staleTelemetryIds: {};
        watchStaleness(): void;
        onMessage(message: any): void;
        dispatch(request: any, data: any, callback: any): any;
        request(request: any): Promise<any>;
        subscribe(request: any, cb: any): () => void;
    }
}
declare module "example/generator/GeneratorProvider" {
    export default function GeneratorProvider(openmct: any, StalenessProvider: any): void;
    export default class GeneratorProvider {
        constructor(openmct: any, StalenessProvider: any);
        openmct: any;
        workerInterface: WorkerInterface;
        canProvideTelemetry(domainObject: any): boolean;
        supportsRequest: any;
        supportsSubscribe: any;
        makeWorkerRequest(domainObject: any, request: any): {
            id: any;
            name: any;
        };
        request(domainObject: any, request: any): Promise<any>;
        subscribe(domainObject: any, callback: any): () => void;
    }
    import WorkerInterface from "example/generator/WorkerInterface";
}
declare module "example/generator/SinewaveLimitProvider" {
    export default function SinewaveLimitProvider(): void;
    export default class SinewaveLimitProvider {
        supportsLimits(domainObject: any): boolean;
        getLimitEvaluator(domainObject: any): {
            evaluate: (datum: any, valueMetadata: any) => {
                cssClass: string;
                low: {
                    sin: number;
                    cos: number;
                };
                high: number;
                name: string;
            } | {
                cssClass: string;
                high: number;
                low: number;
                name: string;
            } | {
                cssClass: string;
                low: {
                    sin: number;
                    cos: number;
                };
                high: {
                    sin: number;
                    cos: number;
                };
                name: string;
            } | undefined;
        };
        getLimits(domainObject: any): {
            limits: () => Promise<{
                WATCH: {
                    low: {
                        color: string;
                        sin: number;
                        cos: number;
                    };
                    high: {
                        sin: number;
                        cos: number;
                        color: string;
                    };
                };
                WARNING: {
                    low: {
                        color: string;
                        sin: number;
                        cos: number;
                    };
                    high: {
                        sin: number;
                        cos: number;
                        color: string;
                    };
                };
                DISTRESS: {
                    low: {
                        color: string;
                        sin: number;
                        cos: number;
                    };
                    high: {
                        sin: number;
                        cos: number;
                        color: string;
                    };
                };
                CRITICAL: {
                    low: {
                        color: string;
                        sin: number;
                        cos: number;
                    };
                    high: {
                        sin: number;
                        cos: number;
                        color: string;
                    };
                };
                SEVERE: {
                    low: {
                        color: string;
                        sin: number;
                        cos: number;
                    };
                    high: {
                        sin: number;
                        cos: number;
                        color: string;
                    };
                };
            }>;
        };
    }
}
declare module "example/generator/SinewaveStalenessProvider" {
    export default class SinewaveLimitProvider extends EventEmitter<string | symbol, any> {
        constructor(openmct: any);
        supportsStaleness(domainObject: any): boolean;
        isStale(domainObject: any, options: any): Promise<{
            isStale: any;
            utc: number;
        }> | undefined;
        subscribeToStaleness(domainObject: any, callback: any): () => void;
        #private;
    }
    import { EventEmitter } from "eventemitter3";
}
declare module "example/generator/StateGeneratorProvider" {
    /*****************************************************************************
     * Open MCT, Copyright (c) 2014-2024, United States Government
     * as represented by the Administrator of the National Aeronautics and Space
     * Administration. All rights reserved.
     *
     * Open MCT is licensed under the Apache License, Version 2.0 (the
     * "License"); you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     * http://www.apache.org/licenses/LICENSE-2.0.
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
     * License for the specific language governing permissions and limitations
     * under the License.
     *
     * Open MCT includes source code licensed under additional open source
     * licenses. See the Open Source Licenses file (LICENSES.md) included with
     * this source code distribution or the Licensing information page available
     * at runtime from the About dialog for additional information.
     *****************************************************************************/
    export default function StateGeneratorProvider(): void;
    export default class StateGeneratorProvider {
        supportsSubscribe(domainObject: any): boolean;
        subscribe(domainObject: any, callback: any): () => void;
        supportsRequest(domainObject: any, options: any): boolean;
        request(domainObject: any, options: any): Promise<{
            name: any;
            utc: number;
            value: number;
        }[]>;
    }
}
declare module "example/generator/plugin" {
    export default function _default(openmct: any): void;
}
declare module "example/imagery/plugin" {
    export default function _default(): (openmct: any) => void;
}
declare module "src/plugins/autoflow/AutoflowTabularConstants" {
    namespace _default {
        let ROW_HEIGHT: number;
        let SLIDER_HEIGHT: number;
        let INITIAL_COLUMN_WIDTH: number;
        let MAX_COLUMN_WIDTH: number;
        let COLUMN_WIDTH_STEP: number;
    }
    export default _default;
}
declare module "src/plugins/autoflow/AutoflowTabularRowController" {
    /*****************************************************************************
     * Open MCT, Copyright (c) 2014-2024, United States Government
     * as represented by the Administrator of the National Aeronautics and Space
     * Administration. All rights reserved.
     *
     * Open MCT is licensed under the Apache License, Version 2.0 (the
     * "License"); you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     * http://www.apache.org/licenses/LICENSE-2.0.
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
     * License for the specific language governing permissions and limitations
     * under the License.
     *
     * Open MCT includes source code licensed under additional open source
     * licenses. See the Open Source Licenses file (LICENSES.md) included with
     * this source code distribution or the Licensing information page available
     * at runtime from the About dialog for additional information.
     *****************************************************************************/
    /**
     * Controller for individual rows of an Autoflow Tabular View.
     * Subscribes to telemetry and updates row data.
     *
     * @param {DomainObject} domainObject the object being viewed
     * @param {*} data the view data
     * @param openmct a reference to the openmct application
     * @param {Function} callback a callback to invoke with "last updated" timestamps
     */
    export default function AutoflowTabularRowController(domainObject: DomainObject, data: any, openmct: any, callback: Function): void;
    export default class AutoflowTabularRowController {
        /*****************************************************************************
         * Open MCT, Copyright (c) 2014-2024, United States Government
         * as represented by the Administrator of the National Aeronautics and Space
         * Administration. All rights reserved.
         *
         * Open MCT is licensed under the Apache License, Version 2.0 (the
         * "License"); you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         * http://www.apache.org/licenses/LICENSE-2.0.
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
         * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
         * License for the specific language governing permissions and limitations
         * under the License.
         *
         * Open MCT includes source code licensed under additional open source
         * licenses. See the Open Source Licenses file (LICENSES.md) included with
         * this source code distribution or the Licensing information page available
         * at runtime from the About dialog for additional information.
         *****************************************************************************/
        /**
         * Controller for individual rows of an Autoflow Tabular View.
         * Subscribes to telemetry and updates row data.
         *
         * @param {DomainObject} domainObject the object being viewed
         * @param {*} data the view data
         * @param openmct a reference to the openmct application
         * @param {Function} callback a callback to invoke with "last updated" timestamps
         */
        constructor(domainObject: DomainObject, data: any, openmct: any, callback: Function);
        domainObject: DomainObject;
        data: any;
        openmct: any;
        callback: Function;
        metadata: any;
        ranges: any;
        domains: any;
        rangeFormatter: any;
        domainFormatter: any;
        evaluator: any;
        initialized: boolean;
        private updateRowData;
        /**
         * Activate this controller; begin listening for changes.
         */
        activate(): void;
        unsubscribe: any;
        /**
         * Destroy this controller; detach any associated resources.
         */
        destroy(): void;
    }
}
declare module "src/plugins/autoflow/AutoflowTabularController" {
    /**
     * Controller for an Autoflow Tabular View. Subscribes to telemetry
     * associated with children of the domain object and passes that
     * information on to the view.
     *
     * @param {DomainObject} domainObject the object being viewed
     * @param {*} data the view data
     * @param openmct a reference to the openmct application
     */
    export default function AutoflowTabularController(domainObject: DomainObject, data: any, openmct: any): void;
    export default class AutoflowTabularController {
        /**
         * Controller for an Autoflow Tabular View. Subscribes to telemetry
         * associated with children of the domain object and passes that
         * information on to the view.
         *
         * @param {DomainObject} domainObject the object being viewed
         * @param {*} data the view data
         * @param openmct a reference to the openmct application
         */
        constructor(domainObject: DomainObject, data: any, openmct: any);
        composition: any;
        data: any;
        openmct: any;
        rows: {};
        controllers: {};
        addRow: any;
        removeRow: any;
        private trackLastUpdated;
        /**
         * Activate this controller; begin listening for changes.
         */
        activate(): void;
        /**
         * Destroy this controller; detach any associated resources.
         */
        destroy(): void;
    }
}
declare module "src/plugins/autoflow/VueView" {
    export default function _default(): {
        new (options: any): {
            show: (container: any) => void;
            destroy: any;
        };
    };
}
declare module "src/plugins/autoflow/AutoflowTabularView" {
    /**
     * Implements the Autoflow Tabular view of a domain object.
     */
    function AutoflowTabularView(domainObject: any, openmct: any): void;
    export default AutoflowTabularView;
}
declare module "src/plugins/autoflow/AutoflowTabularPlugin" {
    export default function _default(options: any): (openmct: any) => void;
}
declare module "src/plugins/charts/bar/BarGraphConstants" {
    export const BAR_GRAPH_VIEW: "bar-graph.view";
    export const BAR_GRAPH_KEY: "telemetry.plot.bar-graph";
    export const BAR_GRAPH_INSPECTOR_KEY: "telemetry.plot.bar-graph.inspector";
}
declare module "src/plugins/charts/bar/BarGraphCompositionPolicy" {
    export default function BarGraphCompositionPolicy(openmct: any): {
        allow: (parent: any, child: any) => boolean;
    };
}
declare module "src/plugins/charts/bar/BarGraphViewProvider" {
    export default function BarGraphViewProvider(openmct: any): {
        key: string;
        name: string;
        cssClass: string;
        canView(domainObject: any, objectPath: any): any;
        canEdit(domainObject: any, objectPath: any): any;
        view(domainObject: any, objectPath: any): {
            show(element: any): void;
            destroy(): void;
            onClearData(): void;
        };
    };
}
declare module "src/plugins/charts/bar/inspector/BarGraphInspectorViewProvider" {
    export default function BarGraphInspectorViewProvider(openmct: any): {
        key: string;
        name: string;
        canView: (selection: any) => any;
        view: (selection: any) => {
            show: (element: any) => void;
            priority: () => any;
            destroy: () => void;
        };
    };
}
declare module "src/plugins/charts/bar/plugin" {
    export default function _default(): (openmct: any) => void;
}
declare module "src/plugins/charts/scatter/scatterPlotConstants" {
    export const SCATTER_PLOT_VIEW: "scatter-plot.view";
    export const SCATTER_PLOT_KEY: "telemetry.plot.scatter-plot";
    export const SCATTER_PLOT_INSPECTOR_KEY: "telemetry.plot.scatter-plot.inspector";
    export const TIME_STRIP_KEY: "time-strip";
}
declare module "src/plugins/charts/scatter/inspector/ScatterPlotInspectorViewProvider" {
    export default function ScatterPlotInspectorViewProvider(openmct: any): {
        key: string;
        name: string;
        canView: (selection: any) => any;
        view: (selection: any) => {
            show: (element: any) => void;
            priority: () => any;
            destroy: () => void;
        };
    };
}
declare module "src/plugins/charts/scatter/ScatterPlotCompositionPolicy" {
    export default function ScatterPlotCompositionPolicy(openmct: any): {
        allow: (parent: any, child: any) => boolean;
    };
}
declare module "src/plugins/charts/scatter/ScatterPlotViewProvider" {
    export default function ScatterPlotViewProvider(openmct: any): {
        key: string;
        name: string;
        cssClass: string;
        canView(domainObject: any, objectPath: any): any;
        canEdit(domainObject: any, objectPath: any): any;
        view: (domainObject: any, objectPath: any) => {
            show: (element: any) => void;
            destroy: () => void;
        };
    };
}
declare module "src/plugins/charts/scatter/plugin" {
    export default function _default(): (openmct: any) => void;
}
declare module "src/plugins/clearData/ClearDataAction" {
    export default ClearDataAction;
    export const CLEAR_DATA_ACTION_KEY: "clear-data-action";
    class ClearDataAction {
        constructor(openmct: any, appliesToObjects: any);
        name: string;
        key: string;
        description: string;
        cssClass: string;
        _openmct: any;
        _appliesToObjects: any;
        invoke(objectPath: any): void;
        appliesTo(objectPath: any): boolean;
    }
}
declare module "src/plugins/clearData/plugin" {
    export default function plugin(appliesToObjects: any, options?: {
        indicator: boolean;
    }): (openmct: any) => void;
}
declare module "src/plugins/clock/ClockViewProvider" {
    export default function ClockViewProvider(openmct: any): {
        key: string;
        name: string;
        cssClass: string;
        canView(domainObject: any): boolean;
        view: (domainObject: any) => {
            show: (element: any) => void;
            destroy: () => void;
        };
    };
}
declare module "src/plugins/clock/plugin" {
    export default function ClockPlugin(options: any): (openmct: any) => void;
}
declare module "src/plugins/condition/ConditionSetCompositionPolicy" {
    /*****************************************************************************
     * Open MCT, Copyright (c) 2014-2024, United States Government
     * as represented by the Administrator of the National Aeronautics and Space
     * Administration. All rights reserved.
     *
     * Open MCT is licensed under the Apache License, Version 2.0 (the
     * "License"); you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     * http://www.apache.org/licenses/LICENSE-2.0.
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
     * License for the specific language governing permissions and limitations
     * under the License.
     *
     * Open MCT includes source code licensed under additional open source
     * licenses. See the Open Source Licenses file (LICENSES.md) included with
     * this source code distribution or the Licensing information page available
     * at runtime from the About dialog for additional information.
     *****************************************************************************/
    export default function ConditionSetCompositionPolicy(openmct: any): {
        allow: (parent: any, child: any) => boolean;
    };
}
declare module "src/plugins/condition/ConditionSetMetadataProvider" {
    /*****************************************************************************
     * Open MCT, Copyright (c) 2014-2024, United States Government
     * as represented by the Administrator of the National Aeronautics and Space
     * Administration. All rights reserved.
     *
     * Open MCT is licensed under the Apache License, Version 2.0 (the
     * "License"); you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     * http://www.apache.org/licenses/LICENSE-2.0.
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
     * License for the specific language governing permissions and limitations
     * under the License.
     *
     * Open MCT includes source code licensed under additional open source
     * licenses. See the Open Source Licenses file (LICENSES.md) included with
     * this source code distribution or the Licensing information page available
     * at runtime from the About dialog for additional information.
     *****************************************************************************/
    export default class ConditionSetMetadataProvider {
        constructor(openmct: any);
        openmct: any;
        supportsMetadata(domainObject: any): boolean;
        getDomains(domainObject: any): any;
        getMetadata(domainObject: any): {
            values: any;
        };
    }
}
declare module "src/plugins/condition/utils/constants" {
    export namespace TRIGGER {
        let ANY: string;
        let ALL: string;
        let NOT: string;
        let XOR: string;
    }
    export namespace TRIGGER_LABEL {
        let any: string;
        let all: string;
        let not: string;
        let xor: string;
    }
    export namespace TRIGGER_CONJUNCTION {
        let any_1: string;
        export { any_1 as any };
        let all_1: string;
        export { all_1 as all };
        let not_1: string;
        export { not_1 as not };
        let xor_1: string;
        export { xor_1 as xor };
    }
    export namespace STYLE_CONSTANTS {
        let isStyleInvisible: string;
        let borderColorTitle: string;
        let textColorTitle: string;
        let backgroundColorTitle: string;
        let imagePropertiesTitle: string;
        let visibilityHidden: string;
        let visibilityVisible: string;
    }
    export namespace ERROR {
        namespace TELEMETRY_NOT_FOUND {
            let errorText: string;
        }
        namespace CONDITION_NOT_FOUND {
            let errorText_1: string;
            export { errorText_1 as errorText };
        }
    }
    export const IS_OLD_KEY: "isStale";
    export const IS_STALE_KEY: "isStale.new";
}
declare module "src/plugins/condition/utils/evaluator" {
    export function evaluateResults(results: any, trigger: any): boolean;
}
declare module "src/plugins/condition/utils/time" {
    export function getLatestTimestamp(currentTimestamp: any, compareTimestamp: any, timeSystems: any, currentTimeSystem: any): any;
    export function checkIfOld(callback: any, timeout: any): {
        update: (data: any) => void;
        clear: () => void;
    };
}
declare module "src/plugins/condition/utils/operations" {
    export function getOperatorText(operationName: any, values: any): string;
    export const OPERATIONS: {
        name: string;
        operation: (input: any) => any;
        text: string;
        appliesTo: string[];
        inputCount: number;
        getDescription: (values: any) => string;
    }[];
    export namespace INPUT_TYPES {
        let string: string;
        let number: string;
    }
}
declare module "src/plugins/condition/criterion/TelemetryCriterion" {
    export default class TelemetryCriterion extends EventEmitter<string | symbol, any> {
        /**
         * Subscribes/Unsubscribes to telemetry and emits the result
         * of operations performed on the telemetry data returned and a given input value.
         * @constructor
         * @param telemetryDomainObjectDefinition {id: uuid, operation: enum, input: Array, metadata: string, key: {domainObject.identifier} }
         * @param openmct
         */
        constructor(telemetryDomainObjectDefinition: id, openmct: any);
        openmct: any;
        telemetryDomainObjectDefinition: id;
        id: any;
        telemetry: any;
        operation: any;
        input: any;
        metadata: any;
        result: any;
        ageCheck: {
            update: (data: any) => void;
            clear: () => void;
        } | undefined;
        unsubscribeFromStaleness: any;
        initialize(): void;
        telemetryObjectIdAsString: any;
        usesTelemetry(id: any): any;
        checkForOldData(): void;
        handleOldTelemetry(data: any): void;
        subscribeToStaleness(): void;
        stalenessUtils: any;
        handleStaleTelemetry(stalenessResponse: any): void;
        isValid(): any;
        isOldCheck(): any;
        isStalenessCheck(): any;
        isValidInput(): number | false;
        updateTelemetryObjects(telemetryObjects: any): void;
        telemetryObject: any;
        createNormalizedDatum(telemetryDatum: any, endpoint: any): any;
        formatData(data: any): {
            result: boolean;
        };
        updateResult(data: any): void;
        requestLAD(telemetryObjects: any, requestOptions: any): any;
        findOperation(operation: any): ((input: any) => any) | null;
        computeResult(data: any): boolean;
        emitEvent(eventName: any, data: any): void;
        getMetaDataObject(telemetryObject: any, metadata: any): any;
        getInputValueFromMetaData(metadataObject: any, input: any): any[] | undefined;
        getMetadataValueFromMetaData(metadataObject: any): any;
        getDescription(criterion: any, index: any): string;
        destroy(): void;
    }
    import { EventEmitter } from "eventemitter3";
}
declare module "src/plugins/condition/criterion/AllTelemetryCriterion" {
    export default class AllTelemetryCriterion extends TelemetryCriterion {
        telemetryObjects: any;
        telemetryDataCache: {} | undefined;
        checkForOldData(telemetryObjects: any): void;
        handleOldTelemetry(id: any, data: any): void;
        subscribeToStaleness(telemetryObjects: any): void;
        stalenessSubscription: {} | undefined;
        handleStaleTelemetry(id: any, stalenessResponse: any): void;
        removeTelemetryDataCache(): void;
        formatData(data: any, telemetryObjects: any): {
            result: boolean;
        };
        updateResult(data: any, telemetryObjects: any): void;
        requestLAD(telemetryObjects: any, requestOptions: any): {
            result: boolean;
        } | Promise<{
            id: any;
            data: any;
        }>;
        getDescription(): string;
    }
    import TelemetryCriterion from "src/plugins/condition/criterion/TelemetryCriterion";
}
declare module "src/plugins/condition/Condition" {
    export default class Condition extends EventEmitter<string | symbol, any> {
        /**
         * Manages criteria and emits the result of - true or false - based on criteria evaluated.
         * @constructor
         * @param conditionConfiguration: {id: uuid,trigger: enum, criteria: Array of {id: uuid, operation: enum, input: Array, metaDataKey: string, key: {domainObject.identifier} }
         * @param openmct
         * @param conditionManager
         */
        constructor(conditionConfiguration: any, openmct: any, conditionManager: any);
        openmct: any;
        conditionManager: any;
        id: any;
        criteria: any[];
        result: boolean | undefined;
        timeSystems: any;
        trigger: any;
        summary: string;
        handleCriterionUpdated(criterion: any): void;
        handleOldTelemetryCriterion(updatedCriterion: any): void;
        handleTelemetryStaleness(): void;
        updateResult(datum: any): void;
        isAnyOrAllTelemetry(criterion: any): any;
        hasNoTelemetry(): boolean;
        isTelemetryUsed(id: any): boolean;
        update(conditionConfiguration: any): void;
        updateTrigger(trigger: any): void;
        generateCriterion(criterionConfiguration: any): {
            id: any;
            telemetry: any;
            telemetryObjects: any;
            operation: any;
            input: any;
            metadata: any;
        };
        createCriteria(criterionConfigurations: any): void;
        updateCriteria(criterionConfigurations: any): void;
        updateTelemetryObjects(): void;
        /**
         *  adds criterion to the condition.
         */
        addCriterion(criterionConfiguration: any): any;
        findCriterion(id: any): {
            item: any;
            index: number;
        } | undefined;
        updateCriterion(id: any, criterionConfiguration: any): void;
        destroyCriterion(id: any): boolean;
        updateDescription(): void;
        getTriggerDescription(): {
            conjunction: any;
            prefix: string;
        };
        requestLADConditionResult(options: any): Promise<{
            id: any;
            data: any;
        }>;
        getCriteria(): any[];
        destroyCriteria(): boolean;
        destroy(): void;
    }
    import { EventEmitter } from "eventemitter3";
}
declare module "src/plugins/condition/ConditionManager" {
    export default class ConditionManager extends EventEmitter<string | symbol, any> {
        constructor(conditionSetDomainObject: any, openmct: any);
        openmct: any;
        conditionSetDomainObject: any;
        timeSystems: any;
        composition: any;
        shouldEvaluateNewTelemetry(currentTimestamp: any): boolean;
        compositionLoad: any;
        subscriptions: {};
        telemetryObjects: {};
        testData: {
            conditionTestInputs: any;
            applied: boolean;
        };
        requestLatestValue(endpoint: any): Promise<void>;
        subscribeToTelemetry(endpoint: any): void;
        unsubscribeFromTelemetry(endpointIdentifier: any): void;
        initialize(): void;
        conditions: any[] | undefined;
        updateConditionTelemetryObjects(): void;
        removeConditionTelemetryObjects(): void;
        updateConditionDescription(condition: any): any;
        updateCondition(conditionConfiguration: any): void;
        initCondition(conditionConfiguration: any, index: any): void;
        createCondition(conditionConfiguration: any): any;
        addCondition(): void;
        cloneCondition(conditionConfiguration: any, index: any): void;
        createAndSaveCondition(index: any, conditionConfiguration: any): void;
        removeCondition(id: any): void;
        findConditionById(id: any): any;
        reorderConditions(reorderPlan: any): void;
        getCurrentCondition(): any;
        getCurrentConditionLAD(conditionResults: any): any;
        requestLADConditionSetOutput(options: any): Promise<any[]>;
        isTelemetryUsed(endpoint: any): boolean;
        telemetryReceived(endpoint: any, datum: any): void;
        updateConditionResults(normalizedDatum: any): void;
        updateCurrentCondition(timestamp: any): void;
        getTestData(metadatum: any): any;
        createNormalizedDatum(telemetryDatum: any, endpoint: any): any;
        updateTestData(testData: any): void;
        persistConditions(): void;
        destroy(): void;
    }
    import { EventEmitter } from "eventemitter3";
}
declare module "src/plugins/condition/ConditionSetTelemetryProvider" {
    export default class ConditionSetTelemetryProvider {
        constructor(openmct: any);
        openmct: any;
        conditionManagerPool: {};
        isTelemetryObject(domainObject: any): boolean;
        supportsRequest(domainObject: any): boolean;
        supportsSubscribe(domainObject: any): boolean;
        request(domainObject: any, options: any): Promise<any>;
        subscribe(domainObject: any, callback: any): () => void;
        /**
         * returns conditionManager instance for corresponding domain object
         * creates the instance if it is not yet created
         * @private
         */
        private getConditionManager;
        /**
         * cleans up and destroys conditionManager instance for corresponding domain object id
         * can be called manually for views that only request but do not subscribe to data
         */
        destroyConditionManager(id: any): void;
    }
}
declare module "src/plugins/condition/ConditionSetViewProvider" {
    export default class ConditionSetViewProvider {
        constructor(openmct: any);
        openmct: any;
        name: string;
        key: string;
        cssClass: string;
        canView(domainObject: any, objectPath: any): any;
        canEdit(domainObject: any, objectPath: any): any;
        view(domainObject: any, objectPath: any): {
            show: (container: any, isEditing: any) => void;
            onEditModeChange: (isEditing: any) => void;
            destroy: () => void;
        };
        priority(domainObject: any): number;
    }
}
declare module "src/plugins/condition/plugin" {
    export default function ConditionPlugin(): (openmct: any) => void;
}
declare module "src/plugins/conditionWidget/ConditionWidgetViewProvider" {
    export default function ConditionWidget(openmct: any): {
        key: string;
        name: string;
        cssClass: string;
        canView: (domainObject: any) => boolean;
        canEdit: (domainObject: any) => boolean;
        view: (domainObject: any) => {
            show: (element: any) => void;
            destroy: () => void;
        };
        priority: () => number;
    };
}
declare module "src/plugins/conditionWidget/plugin" {
    export default function plugin(): (openmct: any) => void;
}
declare module "src/plugins/CouchDBSearchFolder/plugin" {
    export default function _default(folderName: any, couchPlugin: any, searchFilter: any): (openmct: any) => void;
}
declare module "src/plugins/defaultRootName/plugin" {
    export default function _default(name: any): (openmct: any) => void;
}
declare module "src/utils/agent/Agent" {
    /*****************************************************************************
     * Open MCT, Copyright (c) 2014-2024, United States Government
     * as represented by the Administrator of the National Aeronautics and Space
     * Administration. All rights reserved.
     *
     * Open MCT is licensed under the Apache License, Version 2.0 (the
     * "License"); you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     * http://www.apache.org/licenses/LICENSE-2.0.
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
     * License for the specific language governing permissions and limitations
     * under the License.
     *
     * Open MCT includes source code licensed under additional open source
     * licenses. See the Open Source Licenses file (LICENSES.md) included with
     * this source code distribution or the Licensing information page available
     * at runtime from the About dialog for additional information.
     *****************************************************************************/
    /**
     * The query service handles calls for browser and userAgent
     * info using a comparison between the userAgent and key
     * device names
     * @constructor
     * @param window the browser object model
     */
    export default class Agent {
        constructor(window: any);
        userAgent: any;
        mobileName: any;
        window: any;
        touchEnabled: boolean;
        /**
         * Check if the user is on a mobile device.
         * @returns {boolean} true on mobile
         */
        isMobile(): boolean;
        /**
         * Check if the user is on a phone-sized mobile device.
         * @returns {boolean} true on a phone
         */
        isPhone(): boolean;
        /**
         * Check if the user is on a tablet sized android device
         * @returns {boolean | undefined} true on an android tablet
         */
        isAndroidTablet(): boolean | undefined;
        /**
         * Check if the user is on a tablet-sized mobile device.
         * @returns {boolean | undefined} true on a tablet
         */
        isTablet(): boolean | undefined;
        /**
         * Check if the user's device is in a portrait-style
         * orientation (display width is narrower than display height.)
         * @returns {boolean} true in portrait mode
         */
        isPortrait(): boolean;
        /**
         * Check if the user's device is in a landscape-style
         * orientation (display width is greater than display height.)
         * @returns {boolean} true in landscape mode
         */
        isLandscape(): boolean;
        /**
         * Check if the user's device supports a touch interface.
         * @returns {boolean} true if touch is supported
         */
        isTouch(): boolean;
        /**
         * Check if the user agent matches a certain named device,
         * as indicated by checking for a case-insensitive substring
         * match.
         * @param {string} name the name to check for
         * @returns {boolean} true if the user agent includes that name
         */
        isBrowser(name: string): boolean;
    }
}
declare module "src/plugins/DeviceClassifier/src/DeviceMatchers" {
    namespace _default {
        function mobile(agent: any): any;
        function phone(agent: any): any;
        function tablet(agent: any): any;
        function desktop(agent: any): boolean;
        function portrait(agent: any): any;
        function landscape(agent: any): any;
        function touch(agent: any): any;
    }
    export default _default;
}
declare module "src/plugins/DeviceClassifier/src/DeviceClassifier" {
    function _default(agent: any, document: any): void;
    export default _default;
}
declare module "src/plugins/DeviceClassifier/plugin" {
    function _default(): (openmct: any) => void;
    export default _default;
}
declare module "src/plugins/displayLayout/actions/CopyToClipboardAction" {
    export default CopyToClipboardAction;
    export const COPY_TO_CLIPBOARD_ACTION_KEY: "copyToClipboard";
    class CopyToClipboardAction {
        constructor(openmct: any);
        openmct: any;
        cssClass: string;
        description: string;
        group: string;
        key: string;
        name: string;
        priority: number;
        invoke(objectPath: any, view?: {}): void;
        appliesTo(objectPath: any, view?: {}): any;
    }
}
declare module "src/plugins/displayLayout/AlphanumericFormatViewProvider" {
    export default function AlphanumericFormatViewProvider(openmct: any, options: any): {
        key: string;
        name: string;
        canView: (selection: any) => any;
        view: (domainObject: any, objectPath: any) => AlphanumericFormatView;
    };
    class AlphanumericFormatView {
        constructor(openmct: any, domainObject: any, objectPath: any);
        openmct: any;
        domainObject: any;
        objectPath: any;
        _destroy: any;
        component: any;
        show(element: any): void;
        getViewContext(): any;
        priority(): number;
        destroy(): void;
    }
    export {};
}
declare module "src/plugins/displayLayout/DisplayLayoutToolbar" {
    export default class DisplayLayoutToolbar {
        constructor(openmct: any);
        name: string;
        key: string;
        description: string;
        forSelection(selection: any): any;
        icon: any;
        toolbar(selectedObjects: any): ({
            control: string;
            domainObject: any;
            method: (option: any) => void;
            key: string;
            icon: string;
            label: string;
            options: {
                name: string;
                class: string;
            }[];
        } | {
            control: string;
            domainObject: any;
            icon: string;
            method: () => void;
            secondary: boolean;
        } | undefined)[];
        #private;
    }
}
declare module "src/plugins/displayLayout/DisplayLayoutType" {
    /*****************************************************************************
     * Open MCT, Copyright (c) 2014-2024, United States Government
     * as represented by the Administrator of the National Aeronautics and Space
     * Administration. All rights reserved.
     *
     * Open MCT is licensed under the Apache License, Version 2.0 (the
     * "License"); you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     * http://www.apache.org/licenses/LICENSE-2.0.
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
     * License for the specific language governing permissions and limitations
     * under the License.
     *
     * Open MCT includes source code licensed under additional open source
     * licenses. See the Open Source Licenses file (LICENSES.md) included with
     * this source code distribution or the Licensing information page available
     * at runtime from the About dialog for additional information.
     *****************************************************************************/
    export default function DisplayLayoutType(): {
        name: string;
        creatable: boolean;
        description: string;
        cssClass: string;
        initialize(domainObject: any): void;
        form: {
            name: string;
            control: string;
            cssClass: string;
            property: (string | number)[];
            required: boolean;
        }[];
    };
}
declare module "src/plugins/displayLayout/DrawingObjectTypes" {
    export default displayLayoutDrawingObjectTypes;
    const displayLayoutDrawingObjectTypes: {
        'box-view': {
            name: string;
            creatable: boolean;
            description: string;
            cssClass: string;
        };
        'ellipse-view': {
            name: string;
            creatable: boolean;
            description: string;
            cssClass: string;
        };
        'line-view': {
            name: string;
            creatable: boolean;
            description: string;
            cssClass: string;
        };
        'text-view': {
            name: string;
            creatable: boolean;
            description: string;
            cssClass: string;
        };
        'image-view': {
            name: string;
            creatable: boolean;
            description: string;
            cssClass: string;
        };
    };
}
declare module "src/plugins/displayLayout/plugin" {
    export default function DisplayLayoutPlugin(options: any): (openmct: any) => void;
}
declare module "src/plugins/faultManagement/constants" {
    export const FAULT_MANAGEMENT_TYPE: "faultManagement";
    export const FAULT_MANAGEMENT_INSPECTOR: "faultManagementInspector";
    export const FAULT_MANAGEMENT_ALARMS: "alarms";
    export const FAULT_MANAGEMENT_GLOBAL_ALARMS: "global-alarm-status";
    export const FAULT_MANAGEMENT_SHELVE_DURATIONS_IN_MS: {
        name: string;
        value: number;
    }[];
    export const FAULT_MANAGEMENT_VIEW: "faultManagement.view";
    export const FAULT_MANAGEMENT_NAMESPACE: "faults.taxonomy";
    export const FILTER_ITEMS: string[];
    export const SORT_ITEMS: {
        'newest-first': {
            name: string;
            value: string;
            sortFunction: (a: any, b: any) => 0 | 1 | -1;
        };
        'oldest-first': {
            name: string;
            value: string;
            sortFunction: (a: any, b: any) => 0 | 1 | -1;
        };
        severity: {
            name: string;
            value: string;
            sortFunction: (a: any, b: any) => number;
        };
    };
}
declare module "src/plugins/faultManagement/FaultManagementInspectorViewProvider" {
    export default function FaultManagementInspectorViewProvider(openmct: any): {
        openmct: any;
        key: string;
        name: string;
        canView: (selection: any) => any;
        view: (selection: any) => {
            show: (element: any) => void;
            priority: () => any;
            destroy: () => void;
        };
    };
}
declare module "src/plugins/faultManagement/FaultManagementObjectProvider" {
    export default class FaultManagementObjectProvider {
        constructor(openmct: any);
        openmct: any;
        namespace: string;
        key: string;
        objects: {};
        createFaultManagementRootObject(): void;
        rootObject: {
            identifier: {
                key: string;
                namespace: string;
            };
            name: string;
            type: string;
            location: string;
        } | undefined;
        get(identifier: any): Promise<{
            identifier: {
                key: string;
                namespace: string;
            };
            name: string;
            type: string;
            location: string;
        } | undefined>;
    }
}
declare module "src/plugins/faultManagement/FaultManagementViewProvider" {
    export default class FaultManagementViewProvider {
        constructor(openmct: any);
        openmct: any;
        key: string;
        canView(domainObject: any): boolean;
        canEdit(domainObject: any): boolean;
        view(domainObject: any): {
            show: (element: any) => void;
            destroy: () => void;
        };
    }
}
declare module "src/plugins/faultManagement/FaultManagementPlugin" {
    export default function FaultManagementPlugin(): (openmct: any) => void;
}
declare module "src/plugins/filters/FiltersInspectorViewProvider" {
    export default class FiltersInspectorViewProvider {
        constructor(openmct: any, supportedObjectTypesArray: any);
        openmct: any;
        supportedObjectTypesArray: any;
        key: string;
        name: string;
        canView(selection: any): any;
        view(selection: any): {
            show: (element: any) => void;
            showTab: (isEditing: any) => any;
            priority: () => any;
            destroy: () => void;
        };
    }
}
declare module "src/plugins/filters/plugin" {
    export default function plugin(supportedObjectTypesArray: any): (openmct: any) => void;
}
declare module "src/plugins/flexibleLayout/flexibleLayoutViewProvider" {
    export default class FlexibleLayoutViewProvider {
        constructor(openmct: any);
        openmct: any;
        key: string;
        name: string;
        cssClass: string;
        destroy: any;
        canView(domainObject: any): boolean;
        canEdit(domainObject: any): boolean;
        view(domainObject: any, objectPath: any): {
            show(element: any, isEditing: any): void;
            getSelectionContext(): {
                item: any;
                type: string;
            };
            contextAction(action: any, ...args: any[]): void;
            onEditModeChange(isEditing: any): void;
            destroy(): void;
        };
        priority(): number;
    }
}
declare module "src/plugins/flexibleLayout/toolbarProvider" {
    export default ToolbarProvider;
    /*****************************************************************************
     * Open MCT, Copyright (c) 2014-2024, United States Government
     * as represented by the Administrator of the National Aeronautics and Space
     * Administration. All rights reserved.
     *
     * Open MCT is licensed under the Apache License, Version 2.0 (the
     * "License"); you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     * http://www.apache.org/licenses/LICENSE-2.0.
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
     * License for the specific language governing permissions and limitations
     * under the License.
     *
     * Open MCT includes source code licensed under additional open source
     * licenses. See the Open Source Licenses file (LICENSES.md) included with
     * this source code distribution or the Licensing information page available
     * at runtime from the About dialog for additional information.
     *****************************************************************************/
    function ToolbarProvider(openmct: any): {
        name: string;
        key: string;
        description: string;
        forSelection: (selection: any) => any;
        toolbar: (selection: any) => ({
            control: string;
        } | undefined)[];
    };
}
declare module "src/plugins/flexibleLayout/utils/container" {
    export default Container;
    class Container {
        constructor(size: any);
        id: any;
        frames: any[];
        size: any;
    }
}
declare module "src/plugins/flexibleLayout/plugin" {
    export default function plugin(): (openmct: any) => void;
}
declare module "src/plugins/folderView/constants" {
    /*****************************************************************************
     * Open MCT, Copyright (c) 2014-2024, United States Government
     * as represented by the Administrator of the National Aeronautics and Space
     * Administration. All rights reserved.
     *
     * Open MCT is licensed under the Apache License, Version 2.0 (the
     * "License"); you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     * http://www.apache.org/licenses/LICENSE-2.0.
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
     * License for the specific language governing permissions and limitations
     * under the License.
     *
     * Open MCT includes source code licensed under additional open source
     * licenses. See the Open Source Licenses file (LICENSES.md) included with
     * this source code distribution or the Licensing information page available
     * at runtime from the About dialog for additional information.
     *****************************************************************************/
    export const ALLOWED_FOLDER_TYPES: string[];
}
declare module "src/plugins/folderView/FolderGridView" {
    export default class FolderGridView {
        constructor(openmct: any);
        openmct: any;
        key: string;
        name: string;
        cssClass: string;
        canView(domainObject: any): boolean;
        view(domainObject: any): {
            show: (element: any) => void;
            destroy: () => void;
        };
        _destroy: any;
        priority(): number;
    }
}
declare module "src/plugins/folderView/FolderListView" {
    export default class FolderListView {
        constructor(openmct: any);
        openmct: any;
        key: string;
        name: string;
        cssClass: string;
        canView(domainObject: any): boolean;
        view(domainObject: any): {
            show: (element: any) => void;
            destroy: () => void;
        };
        _destroy: any;
        priority(): number;
    }
}
declare module "src/plugins/folderView/plugin" {
    export default function _default(): (openmct: any) => void;
}
declare module "src/plugins/formActions/CreateWizard" {
    /*****************************************************************************
     * Open MCT, Copyright (c) 2014-2024, United States Government
     * as represented by the Administrator of the National Aeronautics and Space
     * Administration. All rights reserved.
     *
     * Open MCT is licensed under the Apache License, Version 2.0 (the
     * 'License'); you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     * http://www.apache.org/licenses/LICENSE-2.0.
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an 'AS IS' BASIS, WITHOUT
     * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
     * License for the specific language governing permissions and limitations
     * under the License.
     *
     * Open MCT includes source code licensed under additional open source
     * licenses. See the Open Source Licenses file (LICENSES.md) included with
     * this source code distribution or the Licensing information page available
     * at runtime from the About dialog for additional information.
     *****************************************************************************/
    export default class CreateWizard {
        constructor(openmct: any, domainObject: any, parent: any);
        openmct: any;
        domainObject: any;
        type: any;
        model: any;
        parent: any;
        properties: any;
        addNotes(sections: any): void;
        addTitle(sections: any): void;
        /**
         * Get the form model for this wizard; this is a description
         * that will be rendered to an HTML form. See the
         * platform/forms bundle
         * @param {boolean} includeLocation if true, a 'location' section
         * will be included that will allow the user to select the location
         * of the newly created object, otherwise the .location property of
         * the model will be used.
         */
        getFormStructure(includeLocation: boolean): {
            sections: ({
                name: string;
                rows: any;
                cssClass?: undefined;
            } | {
                name: string;
                cssClass: string;
                rows: {
                    name: string;
                    cssClass: string;
                    control: string;
                    domainObject: any;
                    required: boolean;
                    parent: any;
                    validate: (data: any) => any;
                    key: string;
                }[];
            })[];
        };
        getValue(row: any): any;
    }
}
declare module "src/plugins/formActions/PropertiesAction" {
    /*****************************************************************************
     * Open MCT, Copyright (c) 2014-2024, United States Government
     * as represented by the Administrator of the National Aeronautics and Space
     * Administration. All rights reserved.
     *
     * Open MCT is licensed under the Apache License, Version 2.0 (the
     * 'License'); you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     * http://www.apache.org/licenses/LICENSE-2.0.
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an 'AS IS' BASIS, WITHOUT
     * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
     * License for the specific language governing permissions and limitations
     * under the License.
     *
     * Open MCT includes source code licensed under additional open source
     * licenses. See the Open Source Licenses file (LICENSES.md) included with
     * this source code distribution or the Licensing information page available
     * at runtime from the About dialog for additional information.
     *****************************************************************************/
    export default class PropertiesAction {
        constructor(openmct: any);
        openmct: any;
        /**
         * @private
         */
        private _getTypeDefinition;
    }
}
declare module "src/plugins/formActions/CreateAction" {
    export default CreateAction;
    export const CREATE_ACTION_KEY: "create";
    class CreateAction extends PropertiesAction {
        key: string;
        isHidden: boolean;
        get invoke(): (type: any, parentDomainObject: any) => void;
        /**
         * @private
         */
        private _onSave;
        /**
         * @private
         */
        private _onCancel;
        /**
         * @private
         */
        private _navigateAndEdit;
        /**
         * @private
         */
        private _showCreateForm;
        domainObject: any;
        startTransaction(): void;
        saveTransaction(): Promise<void>;
        #private;
    }
    import PropertiesAction from "src/plugins/formActions/PropertiesAction";
}
declare module "src/plugins/formActions/EditPropertiesAction" {
    export default EditPropertiesAction;
    export const EDIT_PROPERTIES_ACTION_KEY: "properties";
    class EditPropertiesAction extends PropertiesAction {
        name: string;
        key: string;
        description: string;
        cssClass: string;
        hideInDefaultMenu: boolean;
        group: string;
        priority: number;
        formProperties: {};
        appliesTo(objectPath: any): any;
        invoke(objectPath: any): any;
        /**
         * @private
         */
        private _onSave;
        /**
         * @private
         */
        private _onCancel;
        /**
         * @private
         */
        private _showEditForm;
        domainObject: any;
    }
    import PropertiesAction from "src/plugins/formActions/PropertiesAction";
}
declare module "src/plugins/formActions/plugin" {
    export default function _default(): (openmct: any) => void;
}
declare module "src/plugins/gauge/GaugeCompositionPolicy" {
    /*****************************************************************************
     * Open MCT, Copyright (c) 2014-2024, United States Government
     * as represented by the Administrator of the National Aeronautics and Space
     * Administration. All rights reserved.
     *
     * Open MCT is licensed under the Apache License, Version 2.0 (the
     * "License"); you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     * http://www.apache.org/licenses/LICENSE-2.0.
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
     * License for the specific language governing permissions and limitations
     * under the License.
     *
     * Open MCT includes source code licensed under additional open source
     * licenses. See the Open Source Licenses file (LICENSES.md) included with
     * this source code distribution or the Licensing information page available
     * at runtime from the About dialog for additional information.
     *****************************************************************************/
    export default function GaugeCompositionPolicy(openmct: any): {
        allow: (parent: any, child: any) => boolean;
    };
}
declare module "src/plugins/gauge/GaugeViewProvider" {
    export default function GaugeViewProvider(openmct: any): {
        key: string;
        name: string;
        cssClass: string;
        canView: (domainObject: any) => boolean;
        canEdit: (domainObject: any) => true | undefined;
        view: (domainObject: any) => {
            show: (element: any, isEditing: any, { renderWhenVisible }: {
                renderWhenVisible: any;
            }) => void;
            destroy: () => void;
        };
        priority: () => number;
    };
}
declare module "src/plugins/gauge/GaugePlugin" {
    export default function _default(): (openmct: any) => void;
    export const GAUGE_TYPES: string[][];
}
declare module "src/plugins/goToOriginalAction/goToOriginalAction" {
    export default GoToOriginalAction;
    /*****************************************************************************
     * Open MCT, Copyright (c) 2014-2024, United States Government
     * as represented by the Administrator of the National Aeronautics and Space
     * Administration. All rights reserved.
     *
     * Open MCT is licensed under the Apache License, Version 2.0 (the
     * "License"); you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     * http://www.apache.org/licenses/LICENSE-2.0.
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
     * License for the specific language governing permissions and limitations
     * under the License.
     *
     * Open MCT includes source code licensed under additional open source
     * licenses. See the Open Source Licenses file (LICENSES.md) included with
     * this source code distribution or the Licensing information page available
     * at runtime from the About dialog for additional information.
     *****************************************************************************/
    export const GO_TO_ORIGINAL_ACTION_KEY: "goToOriginal";
    class GoToOriginalAction {
        constructor(openmct: any);
        name: string;
        key: string;
        description: string;
        group: string;
        priority: number;
        _openmct: any;
        invoke(objectPath: any): void;
        appliesTo(objectPath: any): boolean;
    }
}
declare module "src/plugins/goToOriginalAction/plugin" {
    export default function _default(): (openmct: any) => void;
}
declare module "src/plugins/hyperlink/HyperlinkProvider" {
    export default function HyperlinkProvider(openmct: any): {
        key: string;
        name: string;
        cssClass: string;
        canView(domainObject: any): boolean;
        view: (domainObject: any) => {
            show: (element: any) => void;
            destroy: () => void;
        };
    };
}
declare module "src/plugins/hyperlink/plugin" {
    export default function _default(): (openmct: any) => void;
}
declare module "src/plugins/inspectorDataVisualization/InspectorDataVisualizationViewProvider" {
    export default function InspectorDataVisualizationViewProvider(openmct: any, configuration: any): {
        key: string;
        name: any;
        canView(selection: any): boolean;
        view(selection: any): {
            show(element: any): void;
            destroy(): void;
            priority(): any;
        };
    };
}
declare module "src/plugins/inspectorDataVisualization/plugin" {
    export default function _default(options: any): (openmct: any) => void;
}
declare module "src/plugins/inspectorViews/annotations/AnnotationsViewProvider" {
    export default function AnnotationsViewProvider(openmct: any): {
        key: string;
        name: string;
        canView: (selection: any) => any;
        view: (selection: any) => {
            show: (element: any) => void;
            priority: () => any;
            destroy: () => void;
        };
    };
}
declare module "src/plugins/inspectorViews/elements/ElementsViewProvider" {
    export default function ElementsViewProvider(openmct: any): {
        key: string;
        name: string;
        canView: (selection: any) => any;
        view: (selection: any) => {
            show: (element: any) => void;
            showTab: (isEditing: any) => any;
            priority: () => any;
            destroy: () => void;
        };
    };
}
declare module "src/plugins/inspectorViews/elements/PlotElementsViewProvider" {
    export default function PlotElementsViewProvider(openmct: any): {
        key: string;
        name: string;
        canView: (selection: any) => boolean;
        view: (selection: any) => {
            show: (element: any) => void;
            showTab: (isEditing: any) => any;
            priority: () => any;
            destroy: () => void;
        };
    };
}
declare module "src/plugins/inspectorViews/properties/PropertiesViewProvider" {
    export default function PropertiesViewProvider(openmct: any): {
        key: string;
        name: string;
        glyph: string;
        canView: (selection: any) => boolean;
        view: (selection: any) => {
            show: (element: any) => void;
            priority: () => any;
            destroy: () => void;
        };
    };
}
declare module "src/plugins/inspectorViews/styles/StylesManager" {
    export default stylesManager;
    export type Style = {
        property: any;
    };
    const stylesManager: StylesManager;
    /**
     * @typedef {Object} Style
     * @property {*} property
     */
    class StylesManager extends EventEmitter<string | symbol, any> {
        constructor();
        load(): string | null;
        save(style: any): void;
        delete(index: any): void;
        select(style: any): void;
        /**
         * @private
         */
        private normalizeStyle;
        /**
         * @private
         */
        private getBaseStyleObject;
        /**
         * @private
         */
        private isSaveLimitReached;
        /**
         * @private
         */
        private isExistingStyle;
        /**
         * @private
         */
        private persist;
        /**
         * @private
         */
        private isEqual;
    }
    import { EventEmitter } from "eventemitter3";
}
declare module "src/plugins/inspectorViews/styles/StylesInspectorViewProvider" {
    export default function StylesInspectorViewProvider(openmct: any): {
        key: string;
        name: string;
        glyph: string;
        canView: (selection: any) => any;
        view: (selection: any) => {
            show: (element: any) => void;
            priority: () => any;
            destroy: () => void;
        };
    };
}
declare module "src/plugins/inspectorViews/plugin" {
    export default function InspectorViewsPlugin(): (openmct: any) => void;
}
declare module "src/plugins/interceptors/missingObjectInterceptor" {
    /*****************************************************************************
     * Open MCT, Copyright (c) 2014-2024, United States Government
     * as represented by the Administrator of the National Aeronautics and Space
     * Administration. All rights reserved.
     *
     * Open MCT is licensed under the Apache License, Version 2.0 (the
     * "License"); you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     * http://www.apache.org/licenses/LICENSE-2.0.
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
     * License for the specific language governing permissions and limitations
     * under the License.
     *
     * Open MCT includes source code licensed under additional open source
     * licenses. See the Open Source Licenses file (LICENSES.md) included with
     * this source code distribution or the Licensing information page available
     * at runtime from the About dialog for additional information.
     *****************************************************************************/
    export default function MissingObjectInterceptor(openmct: any): void;
}
declare module "src/plugins/interceptors/plugin" {
    export default function plugin(): (openmct: any) => void;
}
declare module "src/plugins/ISOTimeFormat/ISOTimeFormat" {
    /*****************************************************************************
     * Open MCT, Copyright (c) 2014-2024, United States Government
     * as represented by the Administrator of the National Aeronautics and Space
     * Administration. All rights reserved.
     *
     * Open MCT is licensed under the Apache License, Version 2.0 (the
     * "License"); you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     * http://www.apache.org/licenses/LICENSE-2.0.
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
     * License for the specific language governing permissions and limitations
     * under the License.
     *
     * Open MCT includes source code licensed under additional open source
     * licenses. See the Open Source Licenses file (LICENSES.md) included with
     * this source code distribution or the Licensing information page available
     * at runtime from the About dialog for additional information.
     *****************************************************************************/
    export default class ISOTimeFormat {
        key: string;
        format(value: any): any;
        parse(text: any): any;
        validate(text: any): boolean;
    }
}
declare module "src/plugins/ISOTimeFormat/plugin" {
    export default function _default(): (openmct: any) => void;
}
declare module "src/plugins/LADTable/LADTableCompositionPolicy" {
    /*****************************************************************************
     * Open MCT, Copyright (c) 2014-2024, United States Government
     * as represented by the Administrator of the National Aeronautics and Space
     * Administration. All rights reserved.
     *
     * Open MCT is licensed under the Apache License, Version 2.0 (the
     * "License"); you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     * http://www.apache.org/licenses/LICENSE-2.0.
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
     * License for the specific language governing permissions and limitations
     * under the License.
     *
     * Open MCT includes source code licensed under additional open source
     * licenses. See the Open Source Licenses file (LICENSES.md) included with
     * this source code distribution or the Licensing information page available
     * at runtime from the About dialog for additional information.
     *****************************************************************************/
    export default function ladTableCompositionPolicy(openmct: any): (parent: any, child: any) => any;
}
declare module "src/plugins/LADTable/LADTableConfigurationViewProvider" {
    export default function LADTableConfigurationViewProvider(openmct: any): {
        key: string;
        name: string;
        canView(selection: any): boolean;
        view(selection: any): {
            show(element: any): void;
            priority(): number;
            destroy(): void;
        };
    };
}
declare module "src/plugins/LADTable/LADTableConfiguration" {
    export default class LADTableConfiguration extends EventEmitter<string | symbol, any> {
        constructor(domainObject: any, openmct: any);
        domainObject: any;
        openmct: any;
        objectMutated(configuration: any): void;
        unlistenFromMutation: any;
        getConfiguration(): any;
        updateConfiguration(configuration: any): void;
        destroy(): void;
    }
    import { EventEmitter } from "eventemitter3";
}
declare module "src/plugins/LADTable/LadTableSetView" {
    export default class LadTableSetView {
        constructor(openmct: any, domainObject: any, objectPath: any);
        openmct: any;
        domainObject: any;
        objectPath: any;
        _destroy: any;
        component: any;
        show(element: any, isEditing: any, { renderWhenVisible }: {
            renderWhenVisible: any;
        }): void;
        getViewContext(): any;
        destroy(): void;
    }
}
declare module "src/plugins/LADTable/LADTableSetViewProvider" {
    export default function LADTableSetViewProvider(openmct: any): {
        key: string;
        name: string;
        cssClass: string;
        canView: (domainObject: any) => boolean;
        canEdit: (domainObject: any) => boolean;
        view: (domainObject: any, objectPath: any) => LadTableSetView;
        priority: () => number;
    };
    import LadTableSetView from "src/plugins/LADTable/LadTableSetView";
}
declare module "src/plugins/LADTable/LADTableView" {
    export default class LADTableView {
        constructor(openmct: any, domainObject: any, objectPath: any);
        openmct: any;
        domainObject: any;
        objectPath: any;
        component: any;
        _destroy: any;
        show(element: any, isEditing: any, { renderWhenVisible }: {
            renderWhenVisible: any;
        }): void;
        getViewContext(): any;
        destroy(): void;
    }
}
declare module "src/plugins/LADTable/LADTableViewProvider" {
    export default class LADTableViewProvider {
        constructor(openmct: any);
        openmct: any;
        name: string;
        key: string;
        cssClass: string;
        canView(domainObject: any): any;
        canEdit(domainObject: any): boolean;
        view(domainObject: any, objectPath: any): LADTableView;
        priority(domainObject: any): any;
    }
    import LADTableView from "src/plugins/LADTable/LADTableView";
}
declare module "src/plugins/LADTable/ViewActions" {
    export default viewActions;
    const viewActions: {
        name: string;
        key: string;
        description: string;
        cssClass: string;
        invoke: (objectPath: any, view: any) => void;
        showInStatusBar: boolean;
        group: string;
    }[];
}
declare module "src/plugins/LADTable/plugin" {
    export default function plugin(): (openmct: any) => void;
}
declare module "src/utils/sanitization" {
    /*****************************************************************************
     * Open MCT, Copyright (c) 2014-2024, United States Government
     * as represented by the Administrator of the National Aeronautics and Space
     * Administration. All rights reserved.
     *
     * Open MCT is licensed under the Apache License, Version 2.0 (the
     * "License"); you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     * http://www.apache.org/licenses/LICENSE-2.0.
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
     * License for the specific language governing permissions and limitations
     * under the License.
     *
     * Open MCT includes source code licensed under additional open source
     * licenses. See the Open Source Licenses file (LICENSES.md) included with
     * this source code distribution or the Licensing information page available
     * at runtime from the About dialog for additional information.
     *****************************************************************************/
    export function filter__proto__(key: any, value: any): any;
}
declare module "src/plugins/localStorage/LocalStorageObjectProvider" {
    export default class LocalStorageObjectProvider {
        constructor(spaceKey?: string);
        localStorage: Storage;
        spaceKey: string;
        get(identifier: any): Promise<any>;
        getAllObjects(): any;
        create(object: any): Promise<boolean>;
        update(object: any): Promise<boolean>;
        /**
         * @private
         */
        private persistObject;
        /**
         * @private
         */
        private persistSpace;
        isReadOnly(): boolean;
        /**
         * @private
         */
        private getSpace;
        /**
         * @private
         */
        private getSpaceAsObject;
        /**
         * @private
         */
        private initializeSpace;
        /**
         * @private
         */
        private isEmpty;
    }
}
declare module "src/plugins/localStorage/plugin" {
    export default function _default(namespace?: string, storageSpace?: string): (openmct: any) => void;
}
declare module "src/plugins/localTimeSystem/LocalTimeFormat" {
    /**
     * @typedef Scale
     * @property {number} min the minimum scale value, in ms
     * @property {number} max the maximum scale value, in ms
     */
    /**
     * Formatter for UTC timestamps. Interprets numeric values as
     * milliseconds since the start of 1970.
     *
     * @implements {Format}
     * @constructor
     */
    export default function LocalTimeFormat(): void;
    export default class LocalTimeFormat {
        key: string;
        /**
         *
         * @param value
         * @returns {string} the formatted date
         */
        format(value: any, scale: any): string;
        parse(text: any): number;
        validate(text: any): boolean;
    }
    export type Scale = {
        /**
         * the minimum scale value, in ms
         */
        min: number;
        /**
         * the maximum scale value, in ms
         */
        max: number;
    };
}
declare module "src/plugins/localTimeSystem/LocalTimeSystem" {
    /*****************************************************************************
     * Open MCT Web, Copyright (c) 2014-2024, United States Government
     * as represented by the Administrator of the National Aeronautics and Space
     * Administration. All rights reserved.
     *
     * Open MCT Web is licensed under the Apache License, Version 2.0 (the
     * "License"); you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     * http://www.apache.org/licenses/LICENSE-2.0.
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
     * License for the specific language governing permissions and limitations
     * under the License.
     *
     * Open MCT Web includes source code licensed under additional open source
     * licenses. See the Open Source Licenses file (LICENSES.md) included with
     * this source code distribution or the Licensing information page available
     * at runtime from the About dialog for additional information.
     *****************************************************************************/
    /**
     * This time system supports UTC dates and provides a ticking clock source.
     * @implements TimeSystem
     * @constructor
     */
    export default class LocalTimeSystem implements TimeSystem {
        /**
         * Some metadata, which will be used to identify the time system in
         * the UI
         * @type {{key: string, name: string, glyph: string}}
         */
        key: {
            key: string;
            name: string;
            glyph: string;
        };
        name: string;
        cssClass: string;
        timeFormat: string;
        durationFormat: string;
        isUTCBased: boolean;
    }
}
declare module "src/plugins/localTimeSystem/plugin" {
    export default function _default(): (openmct: any) => void;
}
declare module "src/plugins/myItems/createMyItemsIdentifier" {
    export function createMyItemsIdentifier(namespace?: string): {
        key: string;
        namespace: string;
    };
    export const MY_ITEMS_KEY: "mine";
}
declare module "src/plugins/myItems/myItemsInterceptor" {
    export default myItemsInterceptor;
    /*****************************************************************************
     * Open MCT, Copyright (c) 2014-2024, United States Government
     * as represented by the Administrator of the National Aeronautics and Space
     * Administration. All rights reserved.
     *
     * Open MCT is licensed under the Apache License, Version 2.0 (the
     * "License"); you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     * http://www.apache.org/licenses/LICENSE-2.0.
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
     * License for the specific language governing permissions and limitations
     * under the License.
     *
     * Open MCT includes source code licensed under additional open source
     * licenses. See the Open Source Licenses file (LICENSES.md) included with
     * this source code distribution or the Licensing information page available
     * at runtime from the About dialog for additional information.
     *****************************************************************************/
    function myItemsInterceptor({ openmct, identifierObject, name }: {
        openmct: any;
        identifierObject: any;
        name: any;
    }): {
        appliesTo: (identifier: any) => boolean;
        invoke: (identifier: any, object: any) => any;
        priority: any;
    };
}
declare module "src/plugins/myItems/plugin" {
    export default function MyItemsPlugin(name?: string, namespace?: string, priority?: undefined): (openmct: any) => void;
}
declare module "src/plugins/newFolderAction/newFolderAction" {
    export default NewFolderAction;
    /*****************************************************************************
     * Open MCT, Copyright (c) 2014-2024, United States Government
     * as represented by the Administrator of the National Aeronautics and Space
     * Administration. All rights reserved.
     *
     * Open MCT is licensed under the Apache License, Version 2.0 (the
     * "License"); you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     * http://www.apache.org/licenses/LICENSE-2.0.
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
     * License for the specific language governing permissions and limitations
     * under the License.
     *
     * Open MCT includes source code licensed under additional open source
     * licenses. See the Open Source Licenses file (LICENSES.md) included with
     * this source code distribution or the Licensing information page available
     * at runtime from the About dialog for additional information.
     *****************************************************************************/
    export const NEW_FOLDER_ACTION_KEY: "newFolder";
    class NewFolderAction {
        constructor(openmct: any);
        type: string;
        name: string;
        key: string;
        description: string;
        cssClass: string;
        group: string;
        priority: number;
        _openmct: any;
        invoke(objectPath: any): void;
        appliesTo(objectPath: any): any;
    }
}
declare module "src/plugins/newFolderAction/plugin" {
    export default function _default(): (openmct: any) => void;
}
declare module "src/tools/url" {
    /*****************************************************************************
     * Open MCT, Copyright (c) 2014-2024, United States Government
     * as represented by the Administrator of the National Aeronautics and Space
     * Administration. All rights reserved.
     *
     * Open MCT is licensed under the Apache License, Version 2.0 (the
     * "License"); you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     * http://www.apache.org/licenses/LICENSE-2.0.
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
     * License for the specific language governing permissions and limitations
     * under the License.
     *
     * Open MCT includes source code licensed under additional open source
     * licenses. See the Open Source Licenses file (LICENSES.md) included with
     * this source code distribution or the Licensing information page available
     * at runtime from the About dialog for additional information.
     *****************************************************************************/
    /**
     * Module defining url handling.
     */
    /**
     * Convert the current URL parameters to an array of strings.
     * @param {import('../../openmct').OpenMCT} openmct
     * @returns {Array<string>} newTabParams
     */
    export function paramsToArray(openmct: import("openmct").OpenMCT, customUrlParams?: {}): Array<string>;
    export function identifierToString(openmct: any, objectPath: any): string;
    /**
     * @param {import('../../openmct').OpenMCT} openmct
     * @param {Array<import('../api/objects/ObjectAPI').DomainObject>} objectPath
     * @param {any} customUrlParams
     * @returns {string} url
     */
    export function objectPathToUrl(openmct: import("openmct").OpenMCT, objectPath: Array<import("src/api/objects/ObjectAPI").DomainObject>, customUrlParams?: any): string;
}
declare module "src/ui/mixins/object-link" {
    namespace _default {
        let inject: string[];
        namespace props {
            namespace objectPath {
                export let type: ArrayConstructor;
                function _default(): never[];
                export { _default as default };
            }
        }
        namespace computed {
            function objectLink(): string | undefined;
        }
    }
    export default _default;
}
declare module "src/plugins/notebook/utils/notebook-image" {
    export function createNotebookImageDomainObject(fullSizeImageURL: any): {
        name: string;
        type: string;
        identifier: {
            key: any;
            namespace: string;
        };
        configuration: {
            fullSizeImageURL: any;
        };
    };
    export function getThumbnailURLFromCanvas(canvas: any, size?: {
        width: number;
        height: number;
    }): string;
    export function getThumbnailURLFromImageUrl(imageUrl: any, size?: {
        width: number;
        height: number;
    }): Promise<any>;
    export function saveNotebookImageDomainObject(openmct: any, object: any): Promise<void>;
    export function updateNotebookImageDomainObject(openmct: any, identifier: any, fullSizeImage: any): Promise<void>;
    export function updateNamespaceOfDomainObject(object: any, namespace: any): any;
    export namespace DEFAULT_SIZE {
        let width: number;
        let height: number;
    }
}
declare module "src/plugins/notebook/utils/notebook-entries" {
    export function addEntryIntoPage(notebookStorage: any, entries: any, entry: any): any;
    export function selectEntry({ element, entryId, domainObject, openmct, onAnnotationChange, notebookAnnotations }: {
        element: any;
        entryId: any;
        domainObject: any;
        openmct: any;
        onAnnotationChange: any;
        notebookAnnotations: any;
    }): void;
    export function getHistoricLinkInFixedMode(openmct: any, bounds: any, historicLink: any): any;
    export function createNewImageEmbed(image: any, openmct: any, imageName?: string): Promise<any>;
    export function createNewEmbed(snapshotMeta: any, snapshot?: string): Promise<{
        bounds: any;
        createdOn: any;
        createdBy: any;
        cssClass: string;
        domainObject: any;
        historicLink: any;
        id: string;
        name: any;
        snapshot: string;
        type: any;
    }>;
    export function addNotebookEntry(openmct: any, domainObject: any, notebookStorage: any, passedEmbeds?: any[], entryText?: string): Promise<string | undefined>;
    export function getNotebookEntries(domainObject: any, selectedSection: any, selectedPage: any): any;
    export function getEntryPosById(entryId: any, domainObject: any, selectedSection: any, selectedPage: any): number | undefined;
    export function deleteNotebookEntries(openmct: any, domainObject: any, selectedSection: any, selectedPage: any): void;
    export function mutateObject(openmct: any, object: any, key: any, value: any): void;
    export const DEFAULT_CLASS: "notebook-default";
}
declare module "src/plugins/notebook/utils/notebook-migration" {
    export function notebookImageMigration(openmct: any, domainObject: any): void;
    export const IMAGE_MIGRATION_VER: "v1";
}
declare module "src/plugins/notebook/utils/notebook-storage" {
    export function clearDefaultNotebook(): void;
    export function getDefaultNotebook(): any;
    export function getNotebookSectionAndPage(domainObject: any, sectionId: any, pageId: any): {
        section: any;
        page: any;
    };
    export function getDefaultNotebookLink(openmct: any, domainObject?: null): Promise<string | null>;
    export function setDefaultNotebook(openmct: any, notebookStorage: any, domainObject: any): void;
    export function setDefaultNotebookSectionId(sectionId: any): void;
    export function setDefaultNotebookPageId(pageId: any): void;
    export function validateNotebookStorageObject(): any;
}
declare module "src/plugins/notebook/actions/CopyToNotebookAction" {
    export default CopyToNotebookAction;
    export const COPY_TO_NOTEBOOK_ACTION_KEY: "copyToNotebook";
    class CopyToNotebookAction {
        constructor(openmct: any);
        openmct: any;
        cssClass: string;
        description: string;
        group: string;
        key: string;
        name: string;
        priority: number;
        copyToNotebook(entryText: any): void;
        invoke(objectPath: any, view: any): void;
        appliesTo(objectPath: any, view?: {}): any;
    }
}
declare module "src/plugins/notebook/notebook-constants" {
    export function isNotebookOrAnnotationType(domainObject: any): boolean;
    export function isNotebookType(domainObject: any): boolean;
    export function isAnnotationType(domainObject: any): boolean;
    export function isNotebookViewType(view: any): boolean;
    export const NOTEBOOK_TYPE: "notebook";
    export const RESTRICTED_NOTEBOOK_TYPE: "restricted-notebook";
    export const ANNOTATION_TYPE: "annotation";
    export const EVENT_SNAPSHOTS_UPDATED: "SNAPSHOTS_UPDATED";
    export const NOTEBOOK_DEFAULT: "DEFAULT";
    export const NOTEBOOK_SNAPSHOT: "SNAPSHOT";
    export const NOTEBOOK_VIEW_TYPE: "notebook-vue";
    export const RESTRICTED_NOTEBOOK_VIEW_TYPE: "restricted-notebook-vue";
    export const NOTEBOOK_BASE_INSTALLED: "_NOTEBOOK_BASE_FUNCTIONALITY_INSTALLED";
}
declare module "src/plugins/notebook/actions/ExportNotebookAsTextAction" {
    export default ExportNotebookAsTextAction;
    export const EXPORT_NOTEBOOK_AS_TEXT_ACTION_KEY: "exportNotebookAsText";
    class ExportNotebookAsTextAction {
        constructor(openmct: any);
        openmct: any;
        cssClass: string;
        description: string;
        group: string;
        key: string;
        name: string;
        invoke(objectPath: any): void;
        getTagName(tagId: any, availableTags: any): any;
        getTagsForEntry(entry: any, domainObjectKeyString: any, annotations: any): any[];
        formatTimeStamp(timestamp: any): string;
        appliesTo(objectPath: any): boolean;
        onSave(changes: any, objectPath: any): Promise<void>;
        getUserName(userId: any): any;
        showForm(objectPath: any): Promise<void>;
    }
}
declare module "src/plugins/notebook/monkeyPatchObjectAPIForNotebooks" {
    export default function _default(openmct: any): void;
}
declare module "src/plugins/notebook/NotebookType" {
    export default class NotebookType {
        constructor(name: any, description: any, icon: any);
        name: any;
        description: any;
        cssClass: any;
        creatable: boolean;
        form: ({
            key: string;
            name: string;
            control: string;
            options: {
                name: string;
                value: string;
            }[];
            cssClass: string;
            property: string[];
            required?: undefined;
        } | {
            key: string;
            name: string;
            control: string;
            cssClass: string;
            required: boolean;
            property: string[];
            options?: undefined;
        })[];
        initialize(domainObject: any): void;
    }
}
declare module "src/plugins/notebook/NotebookViewProvider" {
    export default class NotebookViewProvider {
        constructor(openmct: any, name: any, key: any, type: any, cssClass: any, snapshotContainer: any, entryUrlWhitelist: any);
        openmct: any;
        key: any;
        name: string;
        type: any;
        cssClass: any;
        snapshotContainer: any;
        entryUrlWhitelist: any;
        canView(domainObject: any): boolean;
        view(domainObject: any): {
            show(container: any): void;
            destroy(): void;
        };
    }
}
declare module "src/plugins/notebook/snapshot-container" {
    export const NOTEBOOK_SNAPSHOT_MAX_COUNT: 5;
    export default class SnapshotContainer extends EventEmitter<string | symbol, any> {
        constructor(openmct: any);
        openmct: any;
        addSnapshot(notebookImageDomainObject: any, embedObject: any): boolean;
        getSnapshot(id: any): any;
        getSnapshots(): any;
        removeSnapshot(id: any): boolean | undefined;
        removeAllSnapshots(): boolean;
        saveSnapshots(snapshots: any): boolean;
        updateSnapshot(snapshot: any): boolean;
    }
    import { EventEmitter } from "eventemitter3";
}
declare module "src/plugins/notebook/plugin" {
    export function getSnapshotContainer(openmct: any): any;
    export function NotebookPlugin(name?: string, entryUrlWhitelist?: any[]): (openmct: any) => void;
    export function RestrictedNotebookPlugin(name?: string, entryUrlWhitelist?: any[]): (openmct: any) => void;
}
declare module "src/plugins/notificationIndicator/plugin" {
    export default function plugin(): (openmct: any) => void;
}
declare module "src/plugins/objectMigration/Migrations" {
    export default function Migrations(openmct: any): {
        check(domainObject: any): any;
        migrate(domainObject: any): any;
    }[];
}
declare module "src/plugins/objectMigration/plugin" {
    export default function _default(): (openmct: any) => void;
}
declare module "src/plugins/openInNewTabAction/openInNewTabAction" {
    export default OpenInNewTab;
    export const NEW_TAB_ACTION_KEY: "newTab";
    class OpenInNewTab {
        constructor(openmct: any);
        name: string;
        key: string;
        description: string;
        group: string;
        priority: number;
        cssClass: string;
        _openmct: any;
        /**
         * Invokes the "Open in New Tab" action. This will open the object in a new
         * browser tab. The URL for the new tab is determined by the current object
         * path and any custom time bounds.
         *
         * @param {import('@/api/objects/ObjectAPI').DomainObject[]} objectPath The current object path
         * @param {ViewContext} _view The view context for the object being opened (unused)
         * @param {Object<string, string | number>} customUrlParams Provides the ability to override
         * the global time conductor bounds. It is an object with the following key/value pairs:
         * ```
         * {
         *  'tc.start': <number>,
         *  'tc.end': <number>,
         *  'tc.mode': 'fixed' | 'local' | <string>
         * }
         * ```
         */
        invoke(objectPath: any[], _view: ViewContext, customUrlParams: {
            [x: string]: string | number;
        }): void;
    }
}
declare module "src/plugins/openInNewTabAction/plugin" {
    export default function _default(): (openmct: any) => void;
}
declare module "src/plugins/operatorStatus/AbstractStatusIndicator" {
    export default class AbstractStatusIndicator {
        /**
         * @param {*} openmct the Open MCT API (proper typescript doc to come)
         * @param {import('@/api/user/UserAPI').UserAPIConfiguration} configuration Per-deployment status styling. See the type definition in UserAPI
         */
        constructor(openmct: any, configuration: any);
        openmct: any;
        showPopup(): void;
        clearPopup(clickAwayEvent: any): void;
        positionBox(): void;
        install(): void;
        createPopupComponent(): void;
        getPopupElement(): void;
        createIndicator(): void;
        getIndicator(): void;
        getConfiguration(): any;
        #private;
    }
}
declare module "src/plugins/operatorStatus/operatorStatus/OperatorStatusIndicator" {
    export default class OperatorStatusIndicator extends AbstractStatusIndicator {
        createPopupComponent(): any;
        createIndicator(): any;
    }
    import AbstractStatusIndicator from "src/plugins/operatorStatus/AbstractStatusIndicator";
}
declare module "src/plugins/operatorStatus/pollQuestion/PollQuestionIndicator" {
    export default class PollQuestionIndicator extends AbstractStatusIndicator {
        createPopupComponent(): any;
        createIndicator(): any;
    }
    import AbstractStatusIndicator from "src/plugins/operatorStatus/AbstractStatusIndicator";
}
declare module "src/plugins/operatorStatus/plugin" {
    /**
     * @param {import('@/api/user/UserAPI').UserAPIConfiguration} configuration
     * @returns {function} The plugin install function
     */
    export default function operatorStatusPlugin(configuration: any): Function;
}
declare module "src/plugins/performanceIndicator/plugin" {
    /*****************************************************************************
     * Open MCT, Copyright (c) 2014-2024, United States Government
     * as represented by the Administrator of the National Aeronautics and Space
     * Administration. All rights reserved.
     *
     * Open MCT is licensed under the Apache License, Version 2.0 (the
     * "License"); you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     * http://www.apache.org/licenses/LICENSE-2.0.
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
     * License for the specific language governing permissions and limitations
     * under the License.
     *
     * Open MCT includes source code licensed under additional open source
     * licenses. See the Open Source Licenses file (LICENSES.md) included with
     * this source code distribution or the Licensing information page available
     * at runtime from the About dialog for additional information.
     *****************************************************************************/
    export default function PerformanceIndicator(): (openmct: any) => void;
}
declare module "src/plugins/persistence/couch/CouchDocument" {
    /*****************************************************************************
     * Open MCT, Copyright (c) 2014-2024, United States Government
     * as represented by the Administrator of the National Aeronautics and Space
     * Administration. All rights reserved.
     *
     * Open MCT is licensed under the Apache License, Version 2.0 (the
     * "License"); you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     * http://www.apache.org/licenses/LICENSE-2.0.
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
     * License for the specific language governing permissions and limitations
     * under the License.
     *
     * Open MCT includes source code licensed under additional open source
     * licenses. See the Open Source Licenses file (LICENSES.md) included with
     * this source code distribution or the Licensing information page available
     * at runtime from the About dialog for additional information.
     *****************************************************************************/
    /**
     * A CouchDocument describes domain object model in a format
     * which is easily read-written to CouchDB. This includes
     * Couch's _id and _rev fields, as well as a separate
     * metadata field which contains a subset of information found
     * in the model itself (to support search optimization with
     * CouchDB views.)
     * @constructor
     * @param {string} id the id under which to store this mode
     * @param {Object} model the model to store
     * @param {string} rev the revision to include (or undefined,
     *        if no revision should be noted for couch)
     * @param {boolean} whether or not to mark this document as
     *        deleted (see CouchDB docs for _deleted)
     */
    export default function CouchDocument(id: string, model: any, rev: string, markDeleted: any): {
        _id: string;
        _rev: string;
        _deleted: any;
        metadata: {
            category: string;
            type: any;
            owner: string;
            name: any;
        };
        model: any;
    };
    export default class CouchDocument {
        /*****************************************************************************
         * Open MCT, Copyright (c) 2014-2024, United States Government
         * as represented by the Administrator of the National Aeronautics and Space
         * Administration. All rights reserved.
         *
         * Open MCT is licensed under the Apache License, Version 2.0 (the
         * "License"); you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         * http://www.apache.org/licenses/LICENSE-2.0.
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
         * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
         * License for the specific language governing permissions and limitations
         * under the License.
         *
         * Open MCT includes source code licensed under additional open source
         * licenses. See the Open Source Licenses file (LICENSES.md) included with
         * this source code distribution or the Licensing information page available
         * at runtime from the About dialog for additional information.
         *****************************************************************************/
        /**
         * A CouchDocument describes domain object model in a format
         * which is easily read-written to CouchDB. This includes
         * Couch's _id and _rev fields, as well as a separate
         * metadata field which contains a subset of information found
         * in the model itself (to support search optimization with
         * CouchDB views.)
         * @constructor
         * @param {string} id the id under which to store this mode
         * @param {Object} model the model to store
         * @param {string} rev the revision to include (or undefined,
         *        if no revision should be noted for couch)
         * @param {boolean} whether or not to mark this document as
         *        deleted (see CouchDB docs for _deleted)
         */
        constructor(id: string, model: any, rev: string, markDeleted: any);
    }
}
declare module "src/plugins/persistence/couch/CouchObjectQueue" {
    /*****************************************************************************
     * Open MCT, Copyright (c) 2014-2024, United States Government
     * as represented by the Administrator of the National Aeronautics and Space
     * Administration. All rights reserved.
     *
     * Open MCT is licensed under the Apache License, Version 2.0 (the
     * "License"); you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     * http://www.apache.org/licenses/LICENSE-2.0.
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
     * License for the specific language governing permissions and limitations
     * under the License.
     *
     * Open MCT includes source code licensed under additional open source
     * licenses. See the Open Source Licenses file (LICENSES.md) included with
     * this source code distribution or the Licensing information page available
     * at runtime from the About dialog for additional information.
     *****************************************************************************/
    export default class CouchObjectQueue {
        constructor(object: any, rev: any);
        rev: any;
        objects: any[];
        pending: boolean;
        updateRevision(rev: any): void;
        hasNext(): number;
        enqueue(item: any): void;
        dequeue(): any;
        clear(): void;
    }
}
declare module "src/plugins/persistence/couch/CouchStatusIndicator" {
    /*****************************************************************************
     * Open MCT, Copyright (c) 2014-2024, United States Government
     * as represented by the Administrator of the National Aeronautics and Space
     * Administration. All rights reserved.
     *
     * Open MCT is licensed under the Apache License, Version 2.0 (the
     * "License"); you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     * http://www.apache.org/licenses/LICENSE-2.0.
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
     * License for the specific language governing permissions and limitations
     * under the License.
     *
     * Open MCT includes source code licensed under additional open source
     * licenses. See the Open Source Licenses file (LICENSES.md) included with
     * this source code distribution or the Licensing information page available
     * at runtime from the About dialog for additional information.
     *****************************************************************************/
    /**
     * @typedef {Object} IndicatorState
     * An object defining the visible state of the indicator.
     * @property {string} statusClass - The class to apply to the indicator.
     * @property {string} text - The text to display in the indicator.
     * @property {string} description - The description to display in the indicator.
     */
    /**
     * Set of CouchDB connection states; changes among these states will be
     * reflected in the indicator's appearance.
     * CONNECTED: Everything nominal, expect to be able to read/write.
     * DISCONNECTED: HTTP request failed (network error). Unable to reach server at all.
     * PENDING: Still trying to connect, and haven't failed yet.
     * MAINTENANCE: CouchDB is connected but not accepting requests.
     */
    /** @type {IndicatorState} */
    export const CONNECTED: IndicatorState;
    /** @type {IndicatorState} */
    export const PENDING: IndicatorState;
    /** @type {IndicatorState} */
    export const DISCONNECTED: IndicatorState;
    /** @type {IndicatorState} */
    export const UNKNOWN: IndicatorState;
    export default class CouchStatusIndicator {
        constructor(simpleIndicator: any);
        indicator: any;
        /**
         * Set the indicator to the given state.
         * @param {IndicatorState} state
         */
        setIndicatorToState(state: IndicatorState): void;
        #private;
    }
    /**
     * An object defining the visible state of the indicator.
     */
    export type IndicatorState = {
        /**
         * - The class to apply to the indicator.
         */
        statusClass: string;
        /**
         * - The text to display in the indicator.
         */
        text: string;
        /**
         * - The description to display in the indicator.
         */
        description: string;
    };
}
declare module "src/plugins/persistence/couch/CouchObjectProvider" {
    export default CouchObjectProvider;
    class CouchObjectProvider {
        constructor({ openmct, databaseConfiguration, couchStatusIndicator }: {
            openmct: any;
            databaseConfiguration: any;
            couchStatusIndicator: any;
        });
        openmct: any;
        indicator: any;
        url: any;
        readOnly: any;
        useDesignDocuments: any;
        namespace: any;
        objectQueue: {};
        observers: {};
        batchIds: any[];
        onEventMessage(event: any): void;
        onEventError(error: any): void;
        flushPersistenceQueue(): Promise<void>;
        persistenceQueue: any[];
        rootObject: any;
        onSharedWorkerMessageError(event: any): void;
        isSynchronizedObject(object: any): any;
        onSharedWorkerMessage(event: any): void;
        changesFeedSharedWorkerConnectionId: any;
        isReadOnly(): any;
        request(subPath: any, method: any, body: any, signal: any): Promise<any>;
        get(identifier: any, abortSignal: any): Promise<any>;
        bulkPromise: Promise<any> | undefined;
        /**
         * @private
         */
        private removeDuplicates;
        search(): Promise<never[]>;
        getObjectsByView({ designDoc, viewName, keysToSearch }: {
            designDoc: any;
            viewName: any;
            keysToSearch: any;
        }, abortSignal: any): Promise<any[]>;
        getObjectsByFilter(filter: any, abortSignal: any): Promise<any[]>;
        observe(identifier: any, callback: any): () => void;
        isObservingObjectChanges(): boolean;
        changesFeedSharedWorker: SharedWorker | undefined;
        stopObservingObjectChanges: any;
        onEventOpen(event: any): void;
        fetchChanges(url: any): void;
        /**
         * @private
         */
        private enqueueObject;
        create(model: any): Promise<any>;
        update(model: any): Promise<any>;
        toPersistableModel(model: any): any;
        fromPersistedModel(model: any, key: any): any;
        #private;
    }
    namespace CouchObjectProvider {
        let HTTP_OK: number;
        let HTTP_CREATED: number;
        let HTTP_ACCEPTED: number;
        let HTTP_NOT_MODIFIED: number;
        let HTTP_BAD_REQUEST: number;
        let HTTP_UNAUTHORIZED: number;
        let HTTP_FORBIDDEN: number;
        let HTTP_NOT_FOUND: number;
        let HTTP_METHOD_NOT_ALLOWED: number;
        let HTTP_NOT_ACCEPTABLE: number;
        let HTTP_CONFLICT: number;
        let HTTP_PRECONDITION_FAILED: number;
        let HTTP_REQUEST_ENTITY_TOO_LARGE: number;
        let HTTP_UNSUPPORTED_MEDIA_TYPE: number;
        let HTTP_REQUESTED_RANGE_NOT_SATISFIABLE: number;
        let HTTP_EXPECTATION_FAILED: number;
        let HTTP_SERVER_ERROR: number;
        let HTTP_SERVICE_UNAVAILABLE: number;
    }
}
declare module "src/plugins/persistence/couch/CouchSearchProvider" {
    export default CouchSearchProvider;
    class CouchSearchProvider {
        constructor(couchObjectProvider: any);
        couchObjectProvider: any;
        searchTypes: any;
        useDesignDocuments: any;
        supportedSearchTypes: any[];
        supportsSearchType(searchType: any): boolean;
        isReadOnly(): boolean;
        search(query: any, abortSignal: any, searchType: any): any;
        searchForObjects(query: any, abortSignal: any): any;
        searchForAnnotations(keyString: any, abortSignal: any): Promise<any>;
        searchForTags(tagsArray: any, abortSignal: any): any;
        #private;
    }
}
declare module "src/plugins/persistence/couch/plugin" {
    export default function CouchPlugin(options: any): (openmct: any) => void;
}
declare module "src/plugins/activityStates/createActivityStatesIdentifier" {
    export function createActivityStatesIdentifier(namespace?: string): {
        key: string;
        namespace: string;
    };
    /*****************************************************************************
     * Open MCT, Copyright (c) 2014-2024, United States Government
     * as represented by the Administrator of the National Aeronautics and Space
     * Administration. All rights reserved.
     *
     * Open MCT is licensed under the Apache License, Version 2.0 (the
     * "License"); you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     * http://www.apache.org/licenses/LICENSE-2.0.
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
     * License for the specific language governing permissions and limitations
     * under the License.
     *
     * Open MCT includes source code licensed under additional open source
     * licenses. See the Open Source Licenses file (LICENSES.md) included with
     * this source code distribution or the Licensing information page available
     * at runtime from the About dialog for additional information.
     *****************************************************************************/
    export const ACTIVITY_STATES_KEY: "activity-states";
}
declare module "src/plugins/activityStates/activityStatesInterceptor" {
    export default activityStatesInterceptor;
    export type ActivityStatesInterceptorOptions = {
        /**
         * the {namespace, key} to use for the activity states object.
         */
        identifier: import('openmct').Identifier;
        /**
         * The name of the activity states model.
         */
        name: string;
        /**
         * the priority of the interceptor. By default, it is low.
         */
        priority: number;
    };
    function activityStatesInterceptor(openmct: any, options: any): {
        appliesTo: (identifierObject: any) => boolean;
        invoke: (identifierObject: any, object: any) => any;
        priority: any;
    };
}
declare module "src/plugins/plan/GanttChartCompositionPolicy" {
    export default function ganttChartCompositionPolicy(openmct: any): (parent: any, child: any) => boolean;
}
declare module "src/plugins/plan/inspector/ActivityInspectorViewProvider" {
    export default function ActivityInspectorViewProvider(openmct: any): {
        key: string;
        name: string;
        canView: (selection: any) => any;
        view: (selection: any) => {
            show: (element: any) => void;
            priority: () => any;
            destroy: () => void;
        };
    };
}
declare module "src/plugins/plan/inspector/GanttChartInspectorViewProvider" {
    export default function GanttChartInspectorViewProvider(openmct: any): {
        key: string;
        name: string;
        canView: (selection: any) => boolean;
        view: (selection: any) => {
            show: (element: any) => void;
            priority: () => any;
            destroy: () => void;
        };
    };
}
declare module "src/plugins/plan/PlanViewConfiguration" {
    export namespace DEFAULT_CONFIGURATION {
        let clipActivityNames: boolean;
        let swimlaneVisibility: {};
    }
    export default class PlanViewConfiguration extends EventEmitter<string | symbol, any> {
        constructor(domainObject: any, openmct: any);
        domainObject: any;
        openmct: any;
        configurationChanged(configuration: any): void;
        unlistenFromMutation: any;
        /**
         * @returns {Object.<string, any>}
         */
        getConfiguration(): {
            [x: string]: any;
        };
        /**
         * @param {string} swimlaneName
         * @param {boolean} isVisible
         */
        setSwimlaneVisibility(swimlaneName: string, isVisible: boolean): void;
        resetSwimlaneVisibility(): void;
        initializeSwimlaneVisibility(swimlaneNames: any): void;
        /**
         * @param {boolean} isEnabled
         */
        setClipActivityNames(isEnabled: boolean): void;
        destroy(): void;
        #private;
    }
    import { EventEmitter } from "eventemitter3";
}
declare module "src/plugins/plan/PlanViewProvider" {
    export default function PlanViewProvider(openmct: any): {
        key: string;
        name: string;
        cssClass: string;
        canView(domainObject: any): boolean;
        canEdit(domainObject: any): boolean;
        view: (domainObject: any, objectPath: any) => {
            show: (element: any) => void;
            destroy: () => void;
        };
    };
}
declare module "src/plugins/plan/plugin" {
    /**
     * @typedef {Object} PlanOptions
     * @property {boolean} creatable true/false to allow creation of a plan via the Create menu.
     * @property {string} name The name of the activity states model.
     * @property {string} namespace the namespace to use for the activity states object.
     * @property {number} priority the priority of the interceptor. By default, it is low.
     */
    /**
     *
     * @param {PlanOptions} options
     * @returns {*} (any)
     */
    export default function _default(options?: PlanOptions): any;
    export type PlanOptions = {
        /**
         * true/false to allow creation of a plan via the Create menu.
         */
        creatable: boolean;
        /**
         * The name of the activity states model.
         */
        name: string;
        /**
         * the namespace to use for the activity states object.
         */
        namespace: string;
        /**
         * the priority of the interceptor. By default, it is low.
         */
        priority: number;
    };
}
declare module "src/plugins/plot/actions/ViewActions" {
    export default viewActions;
    const viewActions: {
        name: string;
        key: string;
        description: string;
        cssClass: string;
        group: string;
        invoke(objectPath: any, view: any): void;
    }[];
}
declare module "src/plugins/plot/inspector/PlotsInspectorViewProvider" {
    export default function PlotsInspectorViewProvider(openmct: any): {
        key: string;
        name: string;
        canView: (selection: any) => any;
        view: (selection: any) => {
            show: (element: any) => void;
            priority: () => any;
            destroy: () => void;
        };
    };
}
declare module "src/plugins/plot/inspector/StackedPlotsInspectorViewProvider" {
    export default function StackedPlotsInspectorViewProvider(openmct: any): {
        key: string;
        name: string;
        canView: (selection: any) => any;
        view: (selection: any) => {
            show: (element: any) => void;
            priority: () => any;
            destroy: () => void;
        };
    };
}
declare module "src/plugins/plot/overlayPlot/OverlayPlotCompositionPolicy" {
    export default function OverlayPlotCompositionPolicy(openmct: any): {
        allow: (parent: any, child: any) => boolean;
    };
}
declare module "src/plugins/plot/overlayPlot/OverlayPlotViewProvider" {
    export default function OverlayPlotViewProvider(openmct: any): {
        key: string;
        name: string;
        cssClass: string;
        canView(domainObject: any, objectPath: any): boolean;
        canEdit(domainObject: any, objectPath: any): boolean;
        view: (domainObject: any, objectPath: any) => {
            show: (element: any, isEditing: any, { renderWhenVisible }: {
                renderWhenVisible: any;
            }) => void;
            getViewContext(): any;
            destroy: () => void;
        };
    };
}
declare module "src/plugins/plot/PlotViewProvider" {
    export default function PlotViewProvider(openmct: any): {
        key: string;
        name: string;
        cssClass: string;
        canView(domainObject: any, objectPath: any): boolean;
        view: (domainObject: any, objectPath: any) => {
            show: (element: any, isEditing: any, { renderWhenVisible }: {
                renderWhenVisible: any;
            }) => void;
            getViewContext(): any;
            destroy: () => void;
            getComponent(): any;
        };
    };
}
declare module "src/plugins/plot/stackedPlot/StackedPlotCompositionPolicy" {
    export default function StackedPlotCompositionPolicy(openmct: any): {
        allow: (parent: any, child: any) => boolean;
    };
}
declare module "src/plugins/plot/stackedPlot/stackedPlotConfigurationInterceptor" {
    /*****************************************************************************
     * Open MCT, Copyright (c) 2014-2024, United States Government
     * as represented by the Administrator of the National Aeronautics and Space
     * Administration. All rights reserved.
     *
     * Open MCT is licensed under the Apache License, Version 2.0 (the
     * "License"); you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     * http://www.apache.org/licenses/LICENSE-2.0.
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
     * License for the specific language governing permissions and limitations
     * under the License.
     *
     * Open MCT includes source code licensed under additional open source
     * licenses. See the Open Source Licenses file (LICENSES.md) included with
     * this source code distribution or the Licensing information page available
     * at runtime from the About dialog for additional information.
     *****************************************************************************/
    export default function stackedPlotConfigurationInterceptor(openmct: any): void;
}
declare module "src/plugins/plot/stackedPlot/StackedPlotViewProvider" {
    export default function StackedPlotViewProvider(openmct: any): {
        key: string;
        name: string;
        cssClass: string;
        canView(domainObject: any, objectPath: any): boolean;
        canEdit(domainObject: any, objectPath: any): boolean;
        view: (domainObject: any, objectPath: any) => {
            show: (element: any, isEditing: any, { renderWhenVisible }: {
                renderWhenVisible: any;
            }) => void;
            getViewContext(): any;
            destroy: () => void;
        };
    };
}
declare module "src/plugins/plot/plugin" {
    export default function _default(): (openmct: any) => void;
}
declare module "src/plugins/reloadAction/ReloadAction" {
    export default ReloadAction;
    /*****************************************************************************
     * Open MCT, Copyright (c) 2014-2023, United States Government
     * as represented by the Administrator of the National Aeronautics and Space
     * Administration. All rights reserved.
     *
     * Open MCT is licensed under the Apache License, Version 2.0 (the
     * "License"); you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     * http://www.apache.org/licenses/LICENSE-2.0.
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
     * License for the specific language governing permissions and limitations
     * under the License.
     *
     * Open MCT includes source code licensed under additional open source
     * licenses. See the Open Source Licenses file (LICENSES.md) included with
     * this source code distribution or the Licensing information page available
     * at runtime from the About dialog for additional information.
     *****************************************************************************/
    export const RELOAD_ACTION_KEY: "reload";
    class ReloadAction {
        constructor(openmct: any);
        name: string;
        key: string;
        description: string;
        group: string;
        priority: number;
        cssClass: string;
        openmct: any;
        invoke(objectPath: any, view: any): void;
    }
}
declare module "src/plugins/reloadAction/plugin" {
    export default function plugin(): (openmct: any) => void;
}
declare module "src/plugins/remoteClock/requestInterceptor" {
    export default remoteClockRequestInterceptor;
    /*****************************************************************************
     * Open MCT, Copyright (c) 2014-2024, United States Government
     * as represented by the Administrator of the National Aeronautics and Space
     * Administration. All rights reserved.
     *
     * Open MCT is licensed under the Apache License, Version 2.0 (the
     * "License"); you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     * http://www.apache.org/licenses/LICENSE-2.0.
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
     * License for the specific language governing permissions and limitations
     * under the License.
     *
     * Open MCT includes source code licensed under additional open source
     * licenses. See the Open Source Licenses file (LICENSES.md) included with
     * this source code distribution or the Licensing information page available
     * at runtime from the About dialog for additional information.
     *****************************************************************************/
    function remoteClockRequestInterceptor(openmct: any, _remoteClockIdentifier: any, waitForBounds: any): {
        appliesTo: () => boolean;
        invoke: (request: any) => Promise<any>;
    };
}
declare module "src/plugins/remoteClock/RemoteClock" {
    /**
     * A {@link openmct.TimeAPI.Clock} that updates the temporal bounds of the
     * application based on a time providing telemetry domainObject.
     *
     * @param {openmct} Object Instance of OpenMCT
     * @param {module:openmct.ObjectAPI~Identifier} identifier An object identifier for
     * the time providing telemetry domainObject
     * @constructor
     */
    export default class RemoteClock extends DefaultClock {
        constructor(openmct: any, identifier: any);
        openmct: any;
        identifier: any;
        timeTelemetryObject: any;
        parseTime: ((datum: any) => any) | undefined;
        formatTime: ((datum: any) => any) | undefined;
        metadata: any;
        lastTick: number;
        /**
         * Function to parse the datum from the timeTelemetryObject as well
         * as check if it's valid, calls "tick"
         *
         * @private
         */
        private _processDatum;
        /**
         * Will start a subscription to the timeTelemetryObject as well
         * handle the unsubscribe callback
         *
         * @private
         */
        private _subscribe;
        _unsubscribe: any;
        /**
         * Will request the latest data for the timeTelemetryObject
         *
         * @private
         */
        private _requestLatest;
        /**
         * Callback function for timeSystem change events
         *
         * @private
         */
        private _timeSystemChange;
        #private;
    }
    import DefaultClock from "src/utils/clock/DefaultClock";
}
declare module "src/plugins/remoteClock/plugin" {
    /**
     * Install a clock that uses a configurable telemetry endpoint.
     */
    export default function _default(identifier: any): (openmct: any) => void;
}
declare module "src/plugins/staticRootPlugin/StaticModelProvider" {
    export default StaticModelProvider;
    class StaticModelProvider {
        constructor(importData: any, rootIdentifier: any);
        objectMap: {};
        /**
         * Standard "Get".
         */
        get(identifier: any): any;
        parseObjectLeaf(objectLeaf: any, idMap: any, newRootNamespace: any, oldRootNamespace: any): any;
        parseArrayLeaf(arrayLeaf: any, idMap: any, newRootNamespace: any, oldRootNamespace: any): any;
        parseBranchedLeaf(branchedLeafValue: any, idMap: any, newRootNamespace: any, oldRootNamespace: any): any;
        parseTreeLeaf(leafKey: any, leafValue: any, idMap: any, newRootNamespace: any, oldRootNamespace: any): any;
        rewriteObjectIdentifiers(importData: any, rootIdentifier: any): any;
        /**
         * Converts all objects in an object make from old format objects to new
         * format objects.
         */
        convertToNewObjects(oldObjectMap: any): {};
        setRootLocation(objectMap: any, rootIdentifier: any): any;
        /**
         * Takes importData (as provided by the ImportExport plugin) and exposes
         * an object provider to fetch those objects.
         */
        rewriteModel(importData: any, rootIdentifier: any): void;
    }
}
declare module "src/plugins/staticRootPlugin/plugin" {
    export default function StaticRootPlugin(options: any): (openmct: any) => void;
}
declare module "src/plugins/summaryWidget/src/telemetry/SummaryWidgetMetadataProvider" {
    /*****************************************************************************
     * Open MCT, Copyright (c) 2014-2024, United States Government
     * as represented by the Administrator of the National Aeronautics and Space
     * Administration. All rights reserved.
     *
     * Open MCT is licensed under the Apache License, Version 2.0 (the
     * "License"); you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     * http://www.apache.org/licenses/LICENSE-2.0.
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
     * License for the specific language governing permissions and limitations
     * under the License.
     *
     * Open MCT includes source code licensed under additional open source
     * licenses. See the Open Source Licenses file (LICENSES.md) included with
     * this source code distribution or the Licensing information page available
     * at runtime from the About dialog for additional information.
     *****************************************************************************/
    export default function SummaryWidgetMetadataProvider(openmct: any): void;
    export default class SummaryWidgetMetadataProvider {
        /*****************************************************************************
         * Open MCT, Copyright (c) 2014-2024, United States Government
         * as represented by the Administrator of the National Aeronautics and Space
         * Administration. All rights reserved.
         *
         * Open MCT is licensed under the Apache License, Version 2.0 (the
         * "License"); you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         * http://www.apache.org/licenses/LICENSE-2.0.
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
         * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
         * License for the specific language governing permissions and limitations
         * under the License.
         *
         * Open MCT includes source code licensed under additional open source
         * licenses. See the Open Source Licenses file (LICENSES.md) included with
         * this source code distribution or the Licensing information page available
         * at runtime from the About dialog for additional information.
         *****************************************************************************/
        constructor(openmct: any);
        openmct: any;
        supportsMetadata(domainObject: any): boolean;
        getDomains(domainObject: any): any;
        getMetadata(domainObject: any): {
            values: any;
        };
    }
}
declare module "src/plugins/summaryWidget/src/eventHelpers" {
    export default helperFunctions;
    namespace helperFunctions {
        function listenTo(object: any, event: any, callback: any, context: any): void;
        function stopListening(object: any, event: any, callback: any, context: any): void;
        function extend(object: any): void;
    }
}
declare module "src/plugins/summaryWidget/src/telemetry/operations" {
    export default OPERATIONS;
    namespace OPERATIONS {
        namespace equalTo {
            function operation(input: any): boolean;
            let text: string;
            let appliesTo: string[];
            let inputCount: number;
            function getDescription(values: any): string;
        }
        namespace notEqualTo {
            export function operation_1(input: any): boolean;
            export { operation_1 as operation };
            let text_1: string;
            export { text_1 as text };
            let appliesTo_1: string[];
            export { appliesTo_1 as appliesTo };
            let inputCount_1: number;
            export { inputCount_1 as inputCount };
            export function getDescription_1(values: any): string;
            export { getDescription_1 as getDescription };
        }
        namespace greaterThan {
            export function operation_2(input: any): boolean;
            export { operation_2 as operation };
            let text_2: string;
            export { text_2 as text };
            let appliesTo_2: string[];
            export { appliesTo_2 as appliesTo };
            let inputCount_2: number;
            export { inputCount_2 as inputCount };
            export function getDescription_2(values: any): string;
            export { getDescription_2 as getDescription };
        }
        namespace lessThan {
            export function operation_3(input: any): boolean;
            export { operation_3 as operation };
            let text_3: string;
            export { text_3 as text };
            let appliesTo_3: string[];
            export { appliesTo_3 as appliesTo };
            let inputCount_3: number;
            export { inputCount_3 as inputCount };
            export function getDescription_3(values: any): string;
            export { getDescription_3 as getDescription };
        }
        namespace greaterThanOrEq {
            export function operation_4(input: any): boolean;
            export { operation_4 as operation };
            let text_4: string;
            export { text_4 as text };
            let appliesTo_4: string[];
            export { appliesTo_4 as appliesTo };
            let inputCount_4: number;
            export { inputCount_4 as inputCount };
            export function getDescription_4(values: any): string;
            export { getDescription_4 as getDescription };
        }
        namespace lessThanOrEq {
            export function operation_5(input: any): boolean;
            export { operation_5 as operation };
            let text_5: string;
            export { text_5 as text };
            let appliesTo_5: string[];
            export { appliesTo_5 as appliesTo };
            let inputCount_5: number;
            export { inputCount_5 as inputCount };
            export function getDescription_5(values: any): string;
            export { getDescription_5 as getDescription };
        }
        namespace between {
            export function operation_6(input: any): boolean;
            export { operation_6 as operation };
            let text_6: string;
            export { text_6 as text };
            let appliesTo_6: string[];
            export { appliesTo_6 as appliesTo };
            let inputCount_6: number;
            export { inputCount_6 as inputCount };
            export function getDescription_6(values: any): string;
            export { getDescription_6 as getDescription };
        }
        namespace notBetween {
            export function operation_7(input: any): boolean;
            export { operation_7 as operation };
            let text_7: string;
            export { text_7 as text };
            let appliesTo_7: string[];
            export { appliesTo_7 as appliesTo };
            let inputCount_7: number;
            export { inputCount_7 as inputCount };
            export function getDescription_7(values: any): string;
            export { getDescription_7 as getDescription };
        }
        namespace textContains {
            export function operation_8(input: any): any;
            export { operation_8 as operation };
            let text_8: string;
            export { text_8 as text };
            let appliesTo_8: string[];
            export { appliesTo_8 as appliesTo };
            let inputCount_8: number;
            export { inputCount_8 as inputCount };
            export function getDescription_8(values: any): string;
            export { getDescription_8 as getDescription };
        }
        namespace textDoesNotContain {
            export function operation_9(input: any): any;
            export { operation_9 as operation };
            let text_9: string;
            export { text_9 as text };
            let appliesTo_9: string[];
            export { appliesTo_9 as appliesTo };
            let inputCount_9: number;
            export { inputCount_9 as inputCount };
            export function getDescription_9(values: any): string;
            export { getDescription_9 as getDescription };
        }
        namespace textStartsWith {
            export function operation_10(input: any): any;
            export { operation_10 as operation };
            let text_10: string;
            export { text_10 as text };
            let appliesTo_10: string[];
            export { appliesTo_10 as appliesTo };
            let inputCount_10: number;
            export { inputCount_10 as inputCount };
            export function getDescription_10(values: any): string;
            export { getDescription_10 as getDescription };
        }
        namespace textEndsWith {
            export function operation_11(input: any): any;
            export { operation_11 as operation };
            let text_11: string;
            export { text_11 as text };
            let appliesTo_11: string[];
            export { appliesTo_11 as appliesTo };
            let inputCount_11: number;
            export { inputCount_11 as inputCount };
            export function getDescription_11(values: any): string;
            export { getDescription_11 as getDescription };
        }
        namespace textIsExactly {
            export function operation_12(input: any): boolean;
            export { operation_12 as operation };
            let text_12: string;
            export { text_12 as text };
            let appliesTo_12: string[];
            export { appliesTo_12 as appliesTo };
            let inputCount_12: number;
            export { inputCount_12 as inputCount };
            export function getDescription_12(values: any): string;
            export { getDescription_12 as getDescription };
        }
        namespace isUndefined {
            export function operation_13(input: any): boolean;
            export { operation_13 as operation };
            let text_13: string;
            export { text_13 as text };
            let appliesTo_13: string[];
            export { appliesTo_13 as appliesTo };
            let inputCount_13: number;
            export { inputCount_13 as inputCount };
            export function getDescription_13(): string;
            export { getDescription_13 as getDescription };
        }
        namespace isDefined {
            export function operation_14(input: any): boolean;
            export { operation_14 as operation };
            let text_14: string;
            export { text_14 as text };
            let appliesTo_14: string[];
            export { appliesTo_14 as appliesTo };
            let inputCount_14: number;
            export { inputCount_14 as inputCount };
            export function getDescription_14(): string;
            export { getDescription_14 as getDescription };
        }
        namespace enumValueIs {
            export function operation_15(input: any): boolean;
            export { operation_15 as operation };
            let text_15: string;
            export { text_15 as text };
            let appliesTo_15: string[];
            export { appliesTo_15 as appliesTo };
            let inputCount_15: number;
            export { inputCount_15 as inputCount };
            export function getDescription_15(values: any): string;
            export { getDescription_15 as getDescription };
        }
        namespace enumValueIsNot {
            export function operation_16(input: any): boolean;
            export { operation_16 as operation };
            let text_16: string;
            export { text_16 as text };
            let appliesTo_16: string[];
            export { appliesTo_16 as appliesTo };
            let inputCount_16: number;
            export { inputCount_16 as inputCount };
            export function getDescription_16(values: any): string;
            export { getDescription_16 as getDescription };
        }
    }
}
declare module "src/plugins/summaryWidget/src/telemetry/SummaryWidgetCondition" {
    export default function SummaryWidgetCondition(definition: any): void;
    export default class SummaryWidgetCondition {
        constructor(definition: any);
        object: any;
        key: any;
        values: any;
        evaluate: (() => boolean) | undefined;
        comparator: any;
        evaluateState(state: any): any;
    }
}
declare module "src/plugins/summaryWidget/src/telemetry/SummaryWidgetRule" {
    export default function SummaryWidgetRule(definition: any): void;
    export default class SummaryWidgetRule {
        constructor(definition: any);
        name: any;
        label: any;
        id: any;
        icon: any;
        style: any;
        message: any;
        description: any;
        conditions: any;
        trigger: any;
        /**
         * Evaluate the given rule against a telemetryState and return true if it
         * matches.
         */
        evaluate(telemetryState: any): boolean;
    }
}
declare module "src/plugins/summaryWidget/src/telemetry/SummaryWidgetEvaluator" {
    /**
     * evaluates rules defined in a summary widget against either lad or
     * realtime state.
     *
     */
    export default function SummaryWidgetEvaluator(domainObject: any, openmct: any): void;
    export default class SummaryWidgetEvaluator {
        /**
         * evaluates rules defined in a summary widget against either lad or
         * realtime state.
         *
         */
        constructor(domainObject: any, openmct: any);
        openmct: any;
        baseState: {};
        removeObserver: any;
        loadPromise: any;
        /**
         * Subscribes to realtime telemetry for the given summary widget.
         */
        subscribe(callback: any): () => void;
        /**
         * Returns a promise for a telemetry datum obtained by evaluating the
         * current lad data.
         */
        requestLatest(options: any): any;
        updateRules(domainObject: any): void;
        rules: any;
        addChild(childObject: any): void;
        removeChild(childObject: any): void;
        load(): any;
        /**
         * Return a promise for a 2-deep clone of the base state object: object
         * states are shallow cloned, and then assembled and returned as a new base
         * state.  Allows object states to be mutated while sharing telemetry
         * metadata and formats.
         */
        getBaseStateClone(): any;
        private subscribeToObjectState;
        private updateObjectStateFromLAD;
        private getTimestamps;
        private makeDatumFromRule;
        private evaluateState;
        /**
         * remove all listeners and clean up any resources.
         */
        destroy(): void;
    }
}
declare module "src/plugins/summaryWidget/src/telemetry/EvaluatorPool" {
    export default function EvaluatorPool(openmct: any): void;
    export default class EvaluatorPool {
        constructor(openmct: any);
        openmct: any;
        byObjectId: {};
        byEvaluator: WeakMap<object, any>;
        get(domainObject: any): any;
        release(evaluator: any): void;
    }
}
declare module "src/plugins/summaryWidget/src/telemetry/SummaryWidgetTelemetryProvider" {
    export default function SummaryWidgetTelemetryProvider(openmct: any): void;
    export default class SummaryWidgetTelemetryProvider {
        constructor(openmct: any);
        pool: EvaluatorPool;
        supportsRequest(domainObject: any, options: any): boolean;
        request(domainObject: any, options: any): any;
        supportsSubscribe(domainObject: any): boolean;
        subscribe(domainObject: any, callback: any): () => void;
    }
    import EvaluatorPool from "src/plugins/summaryWidget/src/telemetry/EvaluatorPool";
}
declare module "src/utils/template/templateHelpers" {
    export function convertTemplateToHTML(templateString: any): Element[];
    export function toggleClass(element: any, className: any): void;
}
declare module "src/plugins/summaryWidget/src/ConditionEvaluator" {
    /**
     * Responsible for maintaining the possible operations for conditions
     * in this widget, and evaluating the boolean value of conditions passed as
     * input.
     * @constructor
     * @param {Object} subscriptionCache A cache consisting of the latest available
     *                                   data for any telemetry sources in the widget's
     *                                   composition.
     * @param {Object} compositionObjs The current set of composition objects to
     *                                 evaluate for 'any' and 'all' conditions
     */
    export default function ConditionEvaluator(subscriptionCache: any, compositionObjs: any): void;
    export default class ConditionEvaluator {
        /**
         * Responsible for maintaining the possible operations for conditions
         * in this widget, and evaluating the boolean value of conditions passed as
         * input.
         * @constructor
         * @param {Object} subscriptionCache A cache consisting of the latest available
         *                                   data for any telemetry sources in the widget's
         *                                   composition.
         * @param {Object} compositionObjs The current set of composition objects to
         *                                 evaluate for 'any' and 'all' conditions
         */
        constructor(subscriptionCache: any, compositionObjs: any);
        subscriptionCache: any;
        compositionObjs: any;
        testCache: {};
        useTestCache: boolean;
        /**
         * Maps value types to HTML input field types. These
         * type of inputs will be generated by conditions expecting this data type
         */
        inputTypes: {
            number: string;
            string: string;
            enum: string;
        };
        /**
         * Functions to validate that the input to an operation is of the type
         * that it expects, in order to prevent unexpected behavior. Will be
         * invoked before the corresponding operation is executed
         */
        inputValidators: {
            number: (input: []) => boolean;
            string: (input: []) => boolean;
            enum: (input: []) => boolean;
        };
        /**
         * A library of operations supported by this rule evaluator. Each operation
         * consists of the following fields:
         * operation: a function with boolean return type to be invoked when this
         *            operation is used. Will be called with an array of inputs
         *            where input [0] is the telemetry value and input [1..n] are
         *            any comparison values
         * text: a human-readable description of this operation to populate selects
         * appliesTo: an array of identifiers for types that operation may be used on
         * inputCount: the number of inputs required to get any necessary comparison
         *             values for the operation
         * getDescription: A function returning a human-readable shorthand description of
         *                this operation to populate the 'description' field in the rule header.
         *                Will be invoked with an array of a condition's comparison values.
         */
        operations: {
            equalTo: {
                operation: (input: any) => boolean;
                text: string;
                appliesTo: string[];
                inputCount: number;
                getDescription: (values: any) => string;
            };
            notEqualTo: {
                operation: (input: any) => boolean;
                text: string;
                appliesTo: string[];
                inputCount: number;
                getDescription: (values: any) => string;
            };
            greaterThan: {
                operation: (input: any) => boolean;
                text: string;
                appliesTo: string[];
                inputCount: number;
                getDescription: (values: any) => string;
            };
            lessThan: {
                operation: (input: any) => boolean;
                text: string;
                appliesTo: string[];
                inputCount: number;
                getDescription: (values: any) => string;
            };
            greaterThanOrEq: {
                operation: (input: any) => boolean;
                text: string;
                appliesTo: string[];
                inputCount: number;
                getDescription: (values: any) => string;
            };
            lessThanOrEq: {
                operation: (input: any) => boolean;
                text: string;
                appliesTo: string[];
                inputCount: number;
                getDescription: (values: any) => string;
            };
            between: {
                operation: (input: any) => boolean;
                text: string;
                appliesTo: string[];
                inputCount: number;
                getDescription: (values: any) => string;
            };
            notBetween: {
                operation: (input: any) => boolean;
                text: string;
                appliesTo: string[];
                inputCount: number;
                getDescription: (values: any) => string;
            };
            textContains: {
                operation: (input: any) => any;
                text: string;
                appliesTo: string[];
                inputCount: number;
                getDescription: (values: any) => string;
            };
            textDoesNotContain: {
                operation: (input: any) => any;
                text: string;
                appliesTo: string[];
                inputCount: number;
                getDescription: (values: any) => string;
            };
            textStartsWith: {
                operation: (input: any) => any;
                text: string;
                appliesTo: string[];
                inputCount: number;
                getDescription: (values: any) => string;
            };
            textEndsWith: {
                operation: (input: any) => any;
                text: string;
                appliesTo: string[];
                inputCount: number;
                getDescription: (values: any) => string;
            };
            textIsExactly: {
                operation: (input: any) => boolean;
                text: string;
                appliesTo: string[];
                inputCount: number;
                getDescription: (values: any) => string;
            };
            isUndefined: {
                operation: (input: any) => boolean;
                text: string;
                appliesTo: string[];
                inputCount: number;
                getDescription: () => string;
            };
            isDefined: {
                operation: (input: any) => boolean;
                text: string;
                appliesTo: string[];
                inputCount: number;
                getDescription: () => string;
            };
            enumValueIs: {
                operation: (input: any) => boolean;
                text: string;
                appliesTo: string[];
                inputCount: number;
                getDescription: (values: any) => string;
            };
            enumValueIsNot: {
                operation: (input: any) => boolean;
                text: string;
                appliesTo: string[];
                inputCount: number;
                getDescription: (values: any) => string;
            };
        };
        /**
         * Evaluate the conditions passed in as an argument, and return the boolean
         * value of these conditions. Available evaluation modes are 'any', which will
         * return true if any of the conditions evaluates to true (i.e. logical OR); 'all',
         * which returns true only if all conditions evaluate to true (i.e. logical AND);
         * or 'js', which returns the boolean value of a custom JavaScript conditional.
         * @param {} conditions Either an array of objects with object, key, operation,
         *                      and value fields, or a string representing a JavaScript
         *                      condition.
         * @param {string} mode The key of the mode to use when evaluating the conditions.
         * @return {boolean} The boolean value of the conditions
         */
        execute(conditions: any, mode: string): boolean;
        /**
         * Execute a condition defined as an object.
         * @param {string} object The identifier of the telemetry object to retrieve data from
         * @param {string} key The property of the telemetry object
         * @param {string} operation The key of the operation in this ConditionEvaluator to executeCondition
         * @param {string} values An array of comparison values to invoke the operation with
         * @return {boolean} The value of this condition
         */
        executeCondition(object: string, key: string, operation: string, values: string): boolean;
        /**
         * A function that returns true only if each value in its input argument is
         * of a numerical type
         * @param {[]} input An array of values
         * @returns {boolean}
         */
        validateNumberInput(input: []): boolean;
        /**
         * A function that returns true only if each value in its input argument is
         * a string
         * @param {[]} input An array of values
         * @returns {boolean}
         */
        validateStringInput(input: []): boolean;
        /**
         * Get the keys of operations supported by this evaluator
         * @return {string[]} An array of the keys of supported operations
         */
        getOperationKeys(): string[];
        /**
         * Get the human-readable text corresponding to a given operation
         * @param {string} key The key of the operation
         * @return {string} The text description of the operation
         */
        getOperationText(key: string): string;
        /**
         * Returns true only if the given operation applies to a given type
         * @param {string} key The key of the operation
         * @param {string} type The value type to query
         * @returns {boolean} True if the condition applies, false otherwise
         */
        operationAppliesTo(key: string, type: string): boolean;
        /**
         * Return the number of value inputs required by an operation
         * @param {string} key The key of the operation to query
         * @return {number}
         */
        getInputCount(key: string): number;
        /**
         * Return the human-readable shorthand description of the operation for a rule header
         * @param {string} key The key of the operation to query
         * @param {} values An array of values with which to invoke the getDescription function
         *                  of the operation
         * @return {string} A text description of this operation
         */
        getOperationDescription(key: string, values: any): string;
        /**
         * Return the HTML input type associated with a given operation
         * @param {string} key The key of the operation to query
         * @return {string} The key for an HTML5 input type
         */
        getInputType(key: string): string;
        /**
         * Returns the HTML input type associated with a value type
         * @param {string} dataType The JavaScript value type
         * @return {string} The key for an HTML5 input type
         */
        getInputTypeById(dataType: string): string;
        /**
         * Set the test data cache used by this rule evaluator
         * @param {Object} testCache A mock cache following the format of the real
         *                           subscription cache
         */
        setTestDataCache(testCache: any): void;
        /**
         * Have this RuleEvaluator pull data values from the provided test cache
         * instead of its actual subscription cache when evaluating. If invoked with true,
         * will use the test cache; otherwise, will use the subscription cache
         * @param {boolean} useTestData Boolean flag
         */
        useTestData(useTestCache: any): void;
    }
}
declare module "src/plugins/summaryWidget/src/ConditionManager" {
    /**
     * Provides a centralized content manager for conditions in the summary widget.
     * Loads and caches composition and telemetry subscriptions, and maintains a
     * {ConditionEvaluator} instance to handle evaluation
     * @constructor
     * @param {Object} domainObject the Summary Widget domain object
     * @param {MCT} openmct an MCT instance
     */
    export default function ConditionManager(domainObject: any, openmct: MCT): void;
    export default class ConditionManager {
        /**
         * Provides a centralized content manager for conditions in the summary widget.
         * Loads and caches composition and telemetry subscriptions, and maintains a
         * {ConditionEvaluator} instance to handle evaluation
         * @constructor
         * @param {Object} domainObject the Summary Widget domain object
         * @param {MCT} openmct an MCT instance
         */
        constructor(domainObject: any, openmct: MCT);
        domainObject: any;
        openmct: MCT;
        composition: any;
        compositionObjs: {};
        eventEmitter: EventEmitter<string | symbol, any>;
        supportedCallbacks: string[];
        keywordLabels: {
            any: string;
            all: string;
        };
        telemetryMetadataById: {
            any: {};
            all: {};
        };
        telemetryTypesById: {
            any: {};
            all: {};
        };
        subscriptions: {};
        subscriptionCache: {};
        loadComplete: boolean;
        metadataLoadComplete: boolean;
        evaluator: ConditionEvaluator;
        /**
         * Register a callback with this ConditionManager: supported callbacks are add
         * remove, load, metadata, and receiveTelemetry
         * @param {string} event The key for the event to listen to
         * @param {function} callback The function that this rule will invoke on this event
         * @param {Object} context A reference to a scope to use as the context for
         *                         context for the callback function
         */
        on(event: string, callback: Function, context: any): void;
        /**
         * Given a set of rules, execute the conditions associated with each rule
         * and return the id of the last rule whose conditions evaluate to true
         * @param {string[]} ruleOrder An array of rule IDs indicating what order They
         *                             should be evaluated in
         * @param {Object} rules An object mapping rule IDs to rule configurations
         * @return {string} The ID of the rule to display on the widget
         */
        executeRules(ruleOrder: string[], rules: any): string;
        /**
         * Adds a field to the list of all available metadata fields in the widget
         * @param {Object} metadatum An object representing a set of telemetry metadata
         */
        addGlobalMetadata(metadatum: any): void;
        /**
         * Adds a field to the list of properties for globally available metadata
         * @param {string} key The key for the property this type applies to
         * @param {string} type The type that should be associated with this property
         */
        addGlobalPropertyType(key: string, type: string): void;
        /**
         * Given a telemetry-producing domain object, associate each of it's telemetry
         * fields with a type, parsing from historical data.
         * @param {Object} object a domain object that can produce telemetry
         * @return {Promise} A promise that resolves when a telemetry request
         *                   has completed and types have been parsed
         */
        parsePropertyTypes(object: any): Promise<any>;
        /**
         * Parse types of telemetry fields from all composition objects; used internally
         * to perform a block types load once initial composition load has completed
         * @return {Promise} A promise that resolves when all metadata has been loaded
         *                   and property types parsed
         */
        parseAllPropertyTypes(): Promise<any>;
        private handleSubscriptionCallback;
        createNormalizedDatum(objId: any, telemetryDatum: any): any;
        private onCompositionAdd;
        private onCompositionRemove;
        private onCompositionLoad;
        /**
         * Returns the currently tracked telemetry sources
         * @return {Object} An object mapping object keys to domain objects
         */
        getComposition(): any;
        /**
         * Get the human-readable name of a domain object from its key
         * @param {string} id The key of the domain object
         * @return {string} The human-readable name of the domain object
         */
        getObjectName(id: string): string;
        /**
         * Returns the property metadata associated with a given telemetry source
         * @param {string} id The key associated with the domain object
         * @return {Object} Returns an object with fields representing each telemetry field
         */
        getTelemetryMetadata(id: string): any;
        /**
         * Returns the type associated with a telemetry data field of a particular domain
         * object
         * @param {string} id The key associated with the domain object
         * @param {string} property The telemetry field key to retrieve the type of
         * @return {string} The type name
         */
        getTelemetryPropertyType(id: string, property: string): string;
        /**
         * Returns the human-readable name of a telemetry data field of a particular domain
         * object
         * @param {string} id The key associated with the domain object
         * @param {string} property The telemetry field key to retrieve the type of
         * @return {string} The telemetry field name
         */
        getTelemetryPropertyName(id: string, property: string): string;
        /**
         * Returns the {ConditionEvaluator} instance associated with this condition
         * manager
         * @return {ConditionEvaluator}
         */
        getEvaluator(): ConditionEvaluator;
        /**
         * Returns true if the initial composition load has completed
         * @return {boolean}
         */
        loadCompleted(): boolean;
        /**
         * Returns true if the initial block metadata load has completed
         */
        metadataLoadCompleted(): boolean;
        /**
         * Triggers the telemetryReceive callbacks registered to this ConditionManager,
         * used by the {TestDataManager} to force a rule evaluation when test data is
         * enabled
         */
        triggerTelemetryCallback(): void;
        /**
         * Unsubscribe from all registered telemetry sources and unregister all event
         * listeners registered with the Open MCT APIs
         */
        destroy(): void;
    }
    import { EventEmitter } from "eventemitter3";
    import ConditionEvaluator from "src/plugins/summaryWidget/src/ConditionEvaluator";
}
declare module "src/plugins/summaryWidget/src/input/Select" {
    /**
     * Wraps an HTML select element, and provides methods for dynamically altering
     * its composition from the data model
     * @constructor
     */
    export default function Select(): void;
    export default class Select {
        domElement: Element;
        options: any[];
        eventEmitter: EventEmitter<string | symbol, any>;
        supportedCallbacks: string[];
        /**
         * Get the DOM element representing this Select in the view
         * @return {Element}
         */
        getDOM(): Element;
        /**
         * Register a callback with this select: supported callback is change
         * @param {string} event The key for the event to listen to
         * @param {function} callback The function that this rule will invoke on this event
         * @param {Object} context A reference to a scope to use as the context for
         *                         context for the callback function
         */
        on(event: string, callback: Function, context: any): void;
        /**
         * Unregister a callback from this select.
         * @param {string} event The key for the event to stop listening to
         * @param {function} callback The function to unregister
         * @param {Object} context A reference to a scope to use as the context for the callback function
         */
        off(event: string, callback: Function, context: any): void;
        /**
         * Update the select element in the view from the current state of the data
         * model
         */
        populate(): void;
        /**
         * Add a single option to this select
         * @param {string} value The value for the new option
         * @param {string} label The human-readable text for the new option
         */
        addOption(value: string, label: string): void;
        /**
         * Set the available options for this select. Replaces any existing options
         * @param {string[][]} options An array of [value, label] pairs to display
         */
        setOptions(options: string[][]): void;
        /**
         * Sets the currently selected element an invokes any registered change
         * callbacks with the new value. If the value doesn't exist in this select's
         * model, its state will not change.
         * @param {string} value The value to set as the selected option
         */
        setSelected(value: string): void;
        /**
         * Get the value of the currently selected item
         * @return {string}
         */
        getSelected(): string;
        hide(): void;
        show(): void;
        destroy(): void;
    }
    import { EventEmitter } from "eventemitter3";
}
declare module "src/plugins/summaryWidget/src/input/KeySelect" {
    export default function KeySelect(config: any, objectSelect: any, manager: any, changeCallback: any): Select;
    export default class KeySelect {
        constructor(config: any, objectSelect: any, manager: any, changeCallback: any);
        config: any;
        objectSelect: any;
        manager: any;
        select: Select;
        /**
         * Populate this select with options based on its current composition
         */
        generateOptions(): void;
        destroy(): void;
    }
    import Select from "src/plugins/summaryWidget/src/input/Select";
}
declare module "src/plugins/summaryWidget/src/input/ObjectSelect" {
    /**
     * Create a {Select} element whose composition is dynamically updated with
     * the current composition of the Summary Widget
     * @constructor
     * @param {Object} config The current state of this select. Must have an
     *                        object field
     * @param {ConditionManager} manager A ConditionManager instance from which
     *                                   to receive the current composition status
     * @param {string[][]} baseOptions A set of [value, label] keyword pairs to
     *                                 display regardless of the composition state
     */
    export default function ObjectSelect(config: any, manager: ConditionManager, baseOptions: string[][]): Select;
    export default class ObjectSelect {
        /**
         * Create a {Select} element whose composition is dynamically updated with
         * the current composition of the Summary Widget
         * @constructor
         * @param {Object} config The current state of this select. Must have an
         *                        object field
         * @param {ConditionManager} manager A ConditionManager instance from which
         *                                   to receive the current composition status
         * @param {string[][]} baseOptions A set of [value, label] keyword pairs to
         *                                 display regardless of the composition state
         */
        constructor(config: any, manager: ConditionManager, baseOptions: string[][]);
        config: any;
        manager: ConditionManager;
        select: Select;
        baseOptions: string[][];
        compositionObjs: any;
        /**
         * Populate this select with options based on its current composition
         */
        generateOptions(): void;
    }
    import Select from "src/plugins/summaryWidget/src/input/Select";
}
declare module "src/plugins/summaryWidget/src/input/OperationSelect" {
    export default function OperationSelect(config: any, keySelect: any, manager: any, changeCallback: any): Select;
    export default class OperationSelect {
        constructor(config: any, keySelect: any, manager: any, changeCallback: any);
        config: any;
        keySelect: any;
        manager: any;
        operationKeys: any[];
        evaluator: any;
        loadComplete: boolean;
        select: Select;
        /**
         * Populate this select with options based on its current composition
         */
        generateOptions(): void;
        /**
         * Retrieve the data type associated with a given telemetry property and
         * the applicable operations from the {ConditionEvaluator}
         * @param {string} key The telemetry property to load operations for
         */
        loadOptions(key: string): void;
        destroy(): void;
    }
    import Select from "src/plugins/summaryWidget/src/input/Select";
}
declare module "src/plugins/summaryWidget/src/Condition" {
    /**
     * Represents an individual condition for a summary widget rule. Manages the
     * associated inputs and view.
     * @param {Object} conditionConfig The configuration for this condition, consisting
     *                                of object, key, operation, and values fields
     * @param {number} index the index of this Condition object in it's parent Rule's data model,
     *                        to be injected into callbacks for removes
     * @param {ConditionManager} conditionManager A ConditionManager instance for populating
     *                                            selects with configuration data
     */
    export default function Condition(conditionConfig: any, index: number, conditionManager: ConditionManager): void;
    export default class Condition {
        /**
         * Represents an individual condition for a summary widget rule. Manages the
         * associated inputs and view.
         * @param {Object} conditionConfig The configuration for this condition, consisting
         *                                of object, key, operation, and values fields
         * @param {number} index the index of this Condition object in it's parent Rule's data model,
         *                        to be injected into callbacks for removes
         * @param {ConditionManager} conditionManager A ConditionManager instance for populating
         *                                            selects with configuration data
         */
        constructor(conditionConfig: any, index: number, conditionManager: ConditionManager);
        config: any;
        index: number;
        conditionManager: ConditionManager;
        domElement: Element;
        eventEmitter: EventEmitter<string | symbol, any>;
        supportedCallbacks: string[];
        deleteButton: Element | null;
        duplicateButton: Element | null;
        selects: {};
        valueInputs: any[];
        handleObjectChange: (value: any) => void;
        handleKeyChange: (value: any) => void;
        getDOM(container: any): Element;
        /**
         * Register a callback with this condition: supported callbacks are remove, change,
         * duplicate
         * @param {string} event The key for the event to listen to
         * @param {function} callback The function that this rule will invoke on this event
         * @param {Object} context A reference to a scope to use as the context for
         *                         context for the callback function
         */
        on(event: string, callback: Function, context: any): void;
        /**
         * Hide the appropriate inputs when this is the only condition
         */
        hideButtons(): void;
        /**
         * Remove this condition from the configuration. Invokes any registered
         * remove callbacks
         */
        remove(): void;
        destroy(): void;
        /**
         * Make a deep clone of this condition's configuration and invoke any duplicate
         * callbacks with the cloned configuration and this rule's index
         */
        duplicate(): void;
        /**
         * When an operation is selected, create the appropriate value inputs
         * and add them to the view. If an operation is of type enum, create
         * a drop-down menu instead.
         *
         * @param {string} operation The key of currently selected operation
         */
        generateValueInputs(operation: string): void;
        generateSelectOptions(): DocumentFragment;
    }
    import { EventEmitter } from "eventemitter3";
}
declare module "src/plugins/summaryWidget/src/input/Palette" {
    /**
     * Instantiates a new Open MCT Color Palette input
     * @constructor
     * @param {string} cssClass The class name of the icon which should be applied
     *                          to this palette
     * @param {Element} container The view that contains this palette
     * @param {string[]} items A list of data items that will be associated with each
     *                         palette item in the view; how this data is represented is
     *                         up to the descendent class
     */
    export default function Palette(cssClass: string, container: Element, items: string[]): void;
    export default class Palette {
        /**
         * Instantiates a new Open MCT Color Palette input
         * @constructor
         * @param {string} cssClass The class name of the icon which should be applied
         *                          to this palette
         * @param {Element} container The view that contains this palette
         * @param {string[]} items A list of data items that will be associated with each
         *                         palette item in the view; how this data is represented is
         *                         up to the descendent class
         */
        constructor(cssClass: string, container: Element, items: string[]);
        cssClass: string;
        items: string[];
        container: Element;
        domElement: Element;
        itemElements: {
            nullOption: Element | null;
        };
        eventEmitter: EventEmitter<string | symbol, any>;
        supportedCallbacks: string[];
        value: string;
        nullOption: string;
        button: Element | null;
        menu: Element | null;
        hideMenu: any;
        /**
         * Get the DOM element representing this palette in the view
         */
        getDOM(): Element;
        /**
         * Clean up any event listeners registered to DOM elements external to the widget
         */
        destroy(): void;
        /**
         * Register a callback with this palette: supported callback is change
         * @param {string} event The key for the event to listen to
         * @param {function} callback The function that this rule will invoke on this event
         * @param {Object} context A reference to a scope to use as the context for
         *                         context for the callback function
         */
        on(event: string, callback: Function, context: any): void;
        /**
         * Get the currently selected value of this palette
         * @return {string} The selected value
         */
        getCurrent(): string;
        /**
         * Set the selected value of this palette; if the item doesn't exist in the
         * palette's data model, the selected value will not change. Invokes any
         * change callbacks associated with this palette.
         * @param {string} item The key of the item to set as selected
         */
        set(item: string): void;
        /**
         * Update the view associated with the currently selected item
         */
        updateSelected(item: any): void;
        /**
         * set the property to be used for the 'no selection' item. If not set, this
         * defaults to a single space
         * @param {string} item The key to use as the 'no selection' item
         */
        setNullOption(item: string): void;
        /**
         * Hides the 'no selection' option to be hidden in the view if it doesn't apply
         */
        toggleNullOption(): void;
    }
    import { EventEmitter } from "eventemitter3";
}
declare module "src/plugins/summaryWidget/src/input/ColorPalette" {
    /**
     * Instantiates a new Open MCT Color Palette input
     * @constructor
     * @param {string} cssClass The class name of the icon which should be applied
     *                          to this palette
     * @param {Element} container The view that contains this palette
     * @param {string[]} colors (optional) A list of colors that should be used to instantiate this palette
     */
    export default function ColorPalette(cssClass: string, container: Element, colors: string[]): Palette;
    export default class ColorPalette {
        /**
         * Instantiates a new Open MCT Color Palette input
         * @constructor
         * @param {string} cssClass The class name of the icon which should be applied
         *                          to this palette
         * @param {Element} container The view that contains this palette
         * @param {string[]} colors (optional) A list of colors that should be used to instantiate this palette
         */
        constructor(cssClass: string, container: Element, colors: string[]);
        colors: string[];
        palette: Palette;
    }
    import Palette from "src/plugins/summaryWidget/src/input/Palette";
}
declare module "src/plugins/summaryWidget/src/input/IconPalette" {
    /**
     * Instantiates a new Open MCT Icon Palette input
     * @constructor
     * @param {string} cssClass The class name of the icon which should be applied
     *                          to this palette
     * @param {Element} container The view that contains this palette
     * @param {string[]} icons (optional) A list of icons that should be used to instantiate this palette
     */
    export default function IconPalette(cssClass: string, container: Element, icons: string[]): Palette;
    export default class IconPalette {
        /**
         * Instantiates a new Open MCT Icon Palette input
         * @constructor
         * @param {string} cssClass The class name of the icon which should be applied
         *                          to this palette
         * @param {Element} container The view that contains this palette
         * @param {string[]} icons (optional) A list of icons that should be used to instantiate this palette
         */
        constructor(cssClass: string, container: Element, icons: string[]);
        icons: string[];
        palette: Palette;
        oldIcon: any;
    }
    import Palette from "src/plugins/summaryWidget/src/input/Palette";
}
declare module "src/plugins/summaryWidget/src/Rule" {
    /**
     * An object representing a summary widget rule. Maintains a set of text
     * and css properties for output, and a set of conditions for configuring
     * when the rule will be applied to the summary widget.
     * @constructor
     * @param {Object} ruleConfig A JavaScript object representing the configuration of this rule
     * @param {Object} domainObject The Summary Widget domain object which contains this rule
     * @param {MCT} openmct An MCT instance
     * @param {ConditionManager} conditionManager A ConditionManager instance
     * @param {WidgetDnD} widgetDnD A WidgetDnD instance to handle dragging and dropping rules
     * @param {element} container The DOM element which contains this summary widget
     */
    export default function Rule(ruleConfig: any, domainObject: any, openmct: MCT, conditionManager: ConditionManager, widgetDnD: WidgetDnD, container: element): void;
    export default class Rule {
        /**
         * An object representing a summary widget rule. Maintains a set of text
         * and css properties for output, and a set of conditions for configuring
         * when the rule will be applied to the summary widget.
         * @constructor
         * @param {Object} ruleConfig A JavaScript object representing the configuration of this rule
         * @param {Object} domainObject The Summary Widget domain object which contains this rule
         * @param {MCT} openmct An MCT instance
         * @param {ConditionManager} conditionManager A ConditionManager instance
         * @param {WidgetDnD} widgetDnD A WidgetDnD instance to handle dragging and dropping rules
         * @param {element} container The DOM element which contains this summary widget
         */
        constructor(ruleConfig: any, domainObject: any, openmct: MCT, conditionManager: ConditionManager, widgetDnD: WidgetDnD, container: element);
        config: any;
        domainObject: any;
        openmct: MCT;
        conditionManager: ConditionManager;
        widgetDnD: WidgetDnD;
        container: element;
        domElement: Element;
        eventEmitter: EventEmitter<string | symbol, any>;
        supportedCallbacks: string[];
        conditions: any[];
        dragging: boolean;
        remove: any;
        duplicate: any;
        thumbnail: Element | null;
        thumbnailIcon: Element | null;
        thumbnailLabel: Element | null;
        title: Element | null;
        description: Element | null;
        trigger: Element | null;
        toggleConfigButton: Element | null;
        configArea: Element | null;
        grippy: Element | null;
        conditionArea: Element | null;
        jsConditionArea: Element | null;
        deleteButton: Element | null;
        duplicateButton: Element | null;
        addConditionButton: Element | null;
        /**
         * The text inputs for this rule: any input included in this object will
         * have the appropriate event handlers registered to it, and it's corresponding
         * field in the domain object will be updated with its value
         */
        textInputs: {
            name: Element | null;
            label: Element | null;
            message: Element | null;
            jsCondition: Element | null;
        };
        iconInput: IconPalette;
        colorInputs: {
            'background-color': ColorPalette;
            'border-color': ColorPalette;
            color: ColorPalette;
        };
        /**
         * Return the DOM element representing this rule
         * @return {Element} A DOM element
         */
        getDOM(): Element;
        /**
         * Unregister any event handlers registered with external sources
         */
        destroy(): void;
        /**
         * Register a callback with this rule: supported callbacks are remove, change,
         * conditionChange, and duplicate
         * @param {string} event The key for the event to listen to
         * @param {function} callback The function that this rule will invoke on this event
         * @param {Object} context A reference to a scope to use as the context for
         *                         context for the callback function
         */
        on(event: string, callback: Function, context: any): void;
        /**
         * An event handler for when a condition's configuration is modified
         * @param {} value
         * @param {string} property The path in the configuration to updateDomainObject
         * @param {number} index The index of the condition that initiated this change
         */
        onConditionChange(event: any): void;
        /**
         * During a rule drag event, show the placeholder element after this rule
         */
        showDragIndicator(): void;
        /**
         * Mutate the domain object with this rule's local configuration
         */
        updateDomainObject(): void;
        /**
         * Get a property of this rule by key
         * @param {string} prop They property key of this rule to get
         * @return {} The queried property
         */
        getProperty(prop: string): any;
        /**
         * Initialize a new condition. If called with the sourceConfig and sourceIndex arguments,
         * will insert a new condition with the provided configuration after the sourceIndex
         * index. Otherwise, initializes a new blank rule and inserts it at the end
         * of the list.
         * @param {Object} [config] The configuration to initialize this rule from,
         *                          consisting of sourceCondition and index fields
         */
        initCondition(config?: any): void;
        /**
         * Build {Condition} objects from configuration and rebuild associated view
         */
        refreshConditions(): void;
        /**
         * Remove a condition from this rule's configuration at the given index
         * @param {number} removeIndex The index of the condition to remove
         */
        removeCondition(removeIndex: number): void;
        /**
         * Build a human-readable description from this rule's conditions
         */
        generateDescription(): void;
    }
    import { EventEmitter } from "eventemitter3";
    import IconPalette from "src/plugins/summaryWidget/src/input/IconPalette";
    import ColorPalette from "src/plugins/summaryWidget/src/input/ColorPalette";
}
declare module "src/plugins/summaryWidget/src/TestDataItem" {
    /**
     * An object representing a single mock telemetry value
     * @param {Object} itemConfig the configuration for this item, consisting of
     *                            object, key, and value fields
     * @param {number} index the index of this TestDataItem object in the data
     *                 model of its parent {TestDataManager} o be injected into callbacks
     *                 for removes
     * @param {ConditionManager} conditionManager a conditionManager instance
     *                           for populating selects with configuration data
     * @constructor
     */
    export default function TestDataItem(itemConfig: any, index: number, conditionManager: ConditionManager): void;
    export default class TestDataItem {
        /**
         * An object representing a single mock telemetry value
         * @param {Object} itemConfig the configuration for this item, consisting of
         *                            object, key, and value fields
         * @param {number} index the index of this TestDataItem object in the data
         *                 model of its parent {TestDataManager} o be injected into callbacks
         *                 for removes
         * @param {ConditionManager} conditionManager a conditionManager instance
         *                           for populating selects with configuration data
         * @constructor
         */
        constructor(itemConfig: any, index: number, conditionManager: ConditionManager);
        config: any;
        index: number;
        conditionManager: ConditionManager;
        domElement: Element;
        eventEmitter: EventEmitter<string | symbol, any>;
        supportedCallbacks: string[];
        deleteButton: Element | null;
        duplicateButton: Element | null;
        selects: {};
        valueInputs: any[];
        remove: any;
        duplicate: any;
        /**
         * Gets the DOM associated with this element's view
         * @return {Element}
         */
        getDOM(container: any): Element;
        /**
         * Register a callback with this item: supported callbacks are remove, change,
         * and duplicate
         * @param {string} event The key for the event to listen to
         * @param {function} callback The function that this rule will invoke on this event
         * @param {Object} context A reference to a scope to use as the context for
         *                         context for the callback function
         */
        on(event: string, callback: Function, context: any): void;
        /**
         * Implement "off" to complete event emitter interface.
         */
        off(event: any, callback: any, context: any): void;
        /**
         * Hide the appropriate inputs when this is the only item
         */
        hideButtons(): void;
        /**
         * When a telemetry property key is selected, create the appropriate value input
         * and add it to the view
         * @param {string} key The key of currently selected telemetry property
         */
        generateValueInput(key: string): void;
        valueInput: HTMLInputElement | undefined;
    }
    import { EventEmitter } from "eventemitter3";
}
declare module "src/plugins/summaryWidget/src/TestDataManager" {
    /**
     * Controls the input and usage of test data in the summary widget.
     * @constructor
     * @param {Object} domainObject The summary widget domain object
     * @param {ConditionManager} conditionManager A conditionManager instance
     * @param {MCT} openmct and MCT instance
     */
    export default function TestDataManager(domainObject: any, conditionManager: ConditionManager, openmct: MCT): void;
    export default class TestDataManager {
        /**
         * Controls the input and usage of test data in the summary widget.
         * @constructor
         * @param {Object} domainObject The summary widget domain object
         * @param {ConditionManager} conditionManager A conditionManager instance
         * @param {MCT} openmct and MCT instance
         */
        constructor(domainObject: any, conditionManager: ConditionManager, openmct: MCT);
        domainObject: any;
        manager: ConditionManager;
        openmct: MCT;
        evaluator: any;
        domElement: Element;
        config: any;
        testCache: {};
        itemArea: Element | null;
        addItemButton: Element | null;
        testDataInput: Element | null;
        /**
         * Get the DOM element representing this test data manager in the view
         */
        getDOM(): Element;
        /**
         * Initialize a new test data item, either from a source configuration, or with
         * the default empty configuration
         * @param {Object} [config] An object with sourceItem and index fields to instantiate
         *                          this rule from, optional
         */
        initItem(config?: any): void;
        /**
         * Remove an item from this TestDataManager at the given index
         * @param {number} removeIndex The index of the item to remove
         */
        removeItem(removeIndex: number): void;
        /**
         * Change event handler for the test data items which compose this
         * test data generator
         * @param {Object} event An object representing this event, with value, property,
         *                       and index fields
         */
        onItemChange(event: any): void;
        /**
         * Builds the test cache from the current item configuration, and passes
         * the new test cache to the associated {ConditionEvaluator} instance
         */
        updateTestCache(): void;
        /**
         * Instantiate {TestDataItem} objects from the current configuration, and
         * update the view accordingly
         */
        refreshItems(): void;
        items: any[] | undefined;
        /**
         * Builds a test data cache in the format of a telemetry subscription cache
         * as expected by a {ConditionEvaluator}
         */
        generateTestCache(): void;
        /**
         * Update the domain object configuration associated with this test data manager
         */
        updateDomainObject(): void;
        destroy(): void;
    }
}
declare module "src/plugins/summaryWidget/src/WidgetDnD" {
    /**
     * Manages the Sortable List interface for reordering rules by drag and drop
     * @param {Element} container The DOM element that contains this Summary Widget's view
     * @param {string[]} ruleOrder An array of rule IDs representing the current rule order
     * @param {Object} rulesById An object mapping rule IDs to rule configurations
     */
    export default function WidgetDnD(container: Element, ruleOrder: string[], rulesById: any): void;
    export default class WidgetDnD {
        /**
         * Manages the Sortable List interface for reordering rules by drag and drop
         * @param {Element} container The DOM element that contains this Summary Widget's view
         * @param {string[]} ruleOrder An array of rule IDs representing the current rule order
         * @param {Object} rulesById An object mapping rule IDs to rule configurations
         */
        constructor(container: Element, ruleOrder: string[], rulesById: any);
        container: Element;
        ruleOrder: string[];
        rulesById: any;
        imageContainer: Element;
        image: Element | null;
        draggingId: string;
        draggingRulePrevious: string;
        eventEmitter: EventEmitter<string | symbol, any>;
        supportedCallbacks: string[];
        drag: any;
        drop: any;
        /**
         * Remove event listeners registered to elements external to the widget
         */
        destroy(): void;
        /**
         * Register a callback with this WidgetDnD: supported callback is drop
         * @param {string} event The key for the event to listen to
         * @param {function} callback The function that this rule will invoke on this event
         * @param {Object} context A reference to a scope to use as the context for
         *                         context for the callback function
         */
        on(event: string, callback: Function, context: any): void;
        /**
         * Sets the image for the dragged element to the given DOM element
         * @param {Element} image The HTML element to set as the drap image
         */
        setDragImage(image: Element): void;
        /**
           * Calculate where this rule has been dragged relative to the other rules
           * @param {Event} event The mousemove or mouseup event that triggered this
                                  event handler
            * @return {string} The ID of the rule whose drag indicator should be displayed
            */
        getDropLocation(event: Event): string;
        /**
         * Called by a {Rule} instance that initiates a drag gesture
         * @param {string} ruleId The identifier of the rule which is being dragged
         */
        dragStart(ruleId: string): void;
    }
    import { EventEmitter } from "eventemitter3";
}
declare module "src/plugins/summaryWidget/src/SummaryWidget" {
    /**
     * A Summary Widget object, which allows a user to configure rules based
     * on telemetry producing domain objects, and update a compact display
     * accordingly.
     * @constructor
     * @param {Object} domainObject The domain Object represented by this Widget
     * @param {MCT} openmct An MCT instance
     */
    export default function SummaryWidget(domainObject: any, openmct: MCT): void;
    export default class SummaryWidget {
        /**
         * A Summary Widget object, which allows a user to configure rules based
         * on telemetry producing domain objects, and update a compact display
         * accordingly.
         * @constructor
         * @param {Object} domainObject The domain Object represented by this Widget
         * @param {MCT} openmct An MCT instance
         */
        constructor(domainObject: any, openmct: MCT);
        domainObject: any;
        openmct: MCT;
        activeId: string;
        rulesById: {};
        domElement: Element;
        toggleRulesControl: Element | null;
        toggleTestDataControl: Element | null;
        widgetButton: Element | null;
        editing: boolean;
        container: string;
        editListenerUnsubscribe: () => void;
        outerWrapper: Element | null;
        ruleArea: Element | null;
        configAreaRules: Element | null;
        testDataArea: Element | null;
        addRuleButton: Element | null;
        conditionManager: ConditionManager;
        testDataManager: TestDataManager;
        watchForChanges: any;
        show: any;
        destroy: any;
        addRule: any;
        /**
         * adds or removes href to widget button and adds or removes openInNewTab
         * @param {string} url String that denotes the url to be opened
         * @param {string} openNewTab String that denotes wether to open link in new tab or not
         */
        addHyperlink(url: string, openNewTab: string): void;
        watchForChangesUnsubscribe: any;
        widgetDnD: WidgetDnD | undefined;
        /**
         * Update the view from the current rule configuration and order
         */
        refreshRules(): void;
        addOrRemoveDragIndicator(): void;
        /**
         * Update the widget's appearance from the configuration of the active rule
         */
        updateWidget(): void;
        /**
         * Get the active rule and update the Widget's appearance.
         */
        executeRules(): void;
        /**
         * Duplicate an existing widget rule from its configuration and splice it in
         * after the rule it duplicates
         * @param {Object} sourceConfig The configuration properties of the rule to be
         *                              instantiated
         */
        duplicateRule(sourceConfig: any): void;
        /**
         * Initialize a new rule from a default configuration, or build a {Rule} object
         * from it if already exists
         * @param {string} ruleId An key to be used to identify this ruleId, or the key
                                  of the rule to be instantiated
          * @param {string} ruleName The initial human-readable name of this rule
          */
        initRule(ruleId: string, ruleName: string): void;
        /**
         * Given two ruleIds, move the source rule after the target rule and update
         * the view.
         * @param {Object} event An event object representing this drop with draggingId
         *                       and dropTarget fields
         */
        reorder(event: any): void;
        /**
         * Apply a list of css properties to an element
         * @param {element} elem The DOM element to which the rules will be applied
         * @param {Object} style an object representing the style
         */
        applyStyle(elem: element, style: any): void;
        /**
         * Mutate this domain object's configuration with the current local configuration
         */
        updateDomainObject(): void;
    }
    import ConditionManager from "src/plugins/summaryWidget/src/ConditionManager";
    import TestDataManager from "src/plugins/summaryWidget/src/TestDataManager";
    import WidgetDnD from "src/plugins/summaryWidget/src/WidgetDnD";
}
declare module "src/plugins/summaryWidget/src/views/SummaryWidgetView" {
    export default SummaryWidgetView;
    class SummaryWidgetView {
        constructor(domainObject: any, openmct: any);
        openmct: any;
        domainObject: any;
        hasUpdated: boolean;
        render(): void;
        updateState(datum: any): void;
        widget: any;
        icon: any;
        label: any;
        renderTracker: {} | undefined;
        unsubscribe: any;
        show(container: any): void;
        container: any;
        removeMutationListener: any;
        onMutation(domainObject: any): void;
        destroy(): void;
        destroyed: boolean | undefined;
        #private;
    }
}
declare module "src/plugins/summaryWidget/src/views/SummaryWidgetViewProvider" {
    export default function SummaryWidgetViewProvider(openmct: any): {
        key: string;
        name: string;
        cssClass: string;
        canView: (domainObject: any) => boolean;
        canEdit: (domainObject: any) => boolean;
        view: (domainObject: any) => SummaryWidgetView;
        edit: (domainObject: any) => SummaryWidgetEditView;
        priority: (domainObject: any) => number;
    };
    import SummaryWidgetView from "src/plugins/summaryWidget/src/views/SummaryWidgetView";
    import SummaryWidgetEditView from "src/plugins/summaryWidget/src/SummaryWidget";
}
declare module "src/plugins/summaryWidget/SummaryWidgetsCompositionPolicy" {
    /*****************************************************************************
     * Open MCT, Copyright (c) 2014-2024, United States Government
     * as represented by the Administrator of the National Aeronautics and Space
     * Administration. All rights reserved.
     *
     * Open MCT is licensed under the Apache License, Version 2.0 (the
     * "License"); you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     * http://www.apache.org/licenses/LICENSE-2.0.
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
     * License for the specific language governing permissions and limitations
     * under the License.
     *
     * Open MCT includes source code licensed under additional open source
     * licenses. See the Open Source Licenses file (LICENSES.md) included with
     * this source code distribution or the Licensing information page available
     * at runtime from the About dialog for additional information.
     *****************************************************************************/
    export default function SummaryWidgetsCompositionPolicy(openmct: any): void;
    export default class SummaryWidgetsCompositionPolicy {
        /*****************************************************************************
         * Open MCT, Copyright (c) 2014-2024, United States Government
         * as represented by the Administrator of the National Aeronautics and Space
         * Administration. All rights reserved.
         *
         * Open MCT is licensed under the Apache License, Version 2.0 (the
         * "License"); you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         * http://www.apache.org/licenses/LICENSE-2.0.
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
         * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
         * License for the specific language governing permissions and limitations
         * under the License.
         *
         * Open MCT includes source code licensed under additional open source
         * licenses. See the Open Source Licenses file (LICENSES.md) included with
         * this source code distribution or the Licensing information page available
         * at runtime from the About dialog for additional information.
         *****************************************************************************/
        constructor(openmct: any);
        openmct: any;
        allow(parent: any, child: any): boolean;
    }
}
declare module "src/plugins/summaryWidget/plugin" {
    export default function plugin(): (openmct: any) => void;
}
declare module "src/plugins/tabs/tabs" {
    export default class Tabs {
        constructor(openmct: any);
        openmct: any;
        key: string;
        name: string;
        cssClass: string;
        destroy: any;
        canView(domainObject: any): boolean;
        canEdit(domainObject: any): boolean;
        view(domainObject: any, objectPath: any): {
            show(element: any, editMode: any): void;
            onEditModeChange(editMode: any): void;
            destroy: (element: any) => void;
        };
        priority(): number;
    }
}
declare module "src/plugins/tabs/plugin" {
    export default function plugin(options: any): (openmct: any) => void;
}
declare module "src/plugins/telemetryMean/src/TelemetryAverager" {
    /*****************************************************************************
     * Open MCT, Copyright (c) 2014-2024, United States Government
     * as represented by the Administrator of the National Aeronautics and Space
     * Administration. All rights reserved.
     *
     * Open MCT is licensed under the Apache License, Version 2.0 (the
     * "License"); you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     * http://www.apache.org/licenses/LICENSE-2.0.
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
     * License for the specific language governing permissions and limitations
     * under the License.
     *
     * Open MCT includes source code licensed under additional open source
     * licenses. See the Open Source Licenses file (LICENSES.md) included with
     * this source code distribution or the Licensing information page available
     * at runtime from the About dialog for additional information.
     *****************************************************************************/
    export default function TelemetryAverager(telemetryAPI: any, timeAPI: any, domainObject: any, samples: any, averageDatumCallback: any): void;
    export default class TelemetryAverager {
        /*****************************************************************************
         * Open MCT, Copyright (c) 2014-2024, United States Government
         * as represented by the Administrator of the National Aeronautics and Space
         * Administration. All rights reserved.
         *
         * Open MCT is licensed under the Apache License, Version 2.0 (the
         * "License"); you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         * http://www.apache.org/licenses/LICENSE-2.0.
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
         * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
         * License for the specific language governing permissions and limitations
         * under the License.
         *
         * Open MCT includes source code licensed under additional open source
         * licenses. See the Open Source Licenses file (LICENSES.md) included with
         * this source code distribution or the Licensing information page available
         * at runtime from the About dialog for additional information.
         *****************************************************************************/
        constructor(telemetryAPI: any, timeAPI: any, domainObject: any, samples: any, averageDatumCallback: any);
        telemetryAPI: any;
        timeAPI: any;
        domainObject: any;
        samples: any;
        averagingWindow: any[];
        rangeKey: any;
        rangeFormatter: any;
        domainKey: any;
        domainFormatter: any;
        averageDatumCallback: any;
        createAverageDatum(telemetryDatum: any): void;
        private calculateMean;
        private setDomainKeyAndFormatter;
        private setRangeKeyAndFormatter;
        private getFormatter;
    }
}
declare module "src/plugins/telemetryMean/src/MeanTelemetryProvider" {
    export default function MeanTelemetryProvider(openmct: any): void;
    export default class MeanTelemetryProvider {
        constructor(openmct: any);
        openmct: any;
        telemetryAPI: any;
        timeAPI: any;
        objectAPI: any;
        perObjectProviders: {};
        canProvideTelemetry(domainObject: any): boolean;
        supportsRequest: any;
        supportsSubscribe: any;
        subscribe(domainObject: any, callback: any): () => void;
        subscribeToAverage(domainObject: any, samples: any, callback: any): any;
        request(domainObject: any, request: any): any;
        private requestAverageTelemetry;
        private getLinkedObject;
    }
}
declare module "src/plugins/telemetryMean/plugin" {
    export default function plugin(): (openmct: any) => void;
}
declare module "src/plugins/telemetryTable/TelemetryTableConfiguration" {
    export default class TelemetryTableConfiguration extends EventEmitter<string | symbol, any> {
        constructor(domainObject: any, openmct: any, options: any);
        domainObject: any;
        openmct: any;
        defaultOptions: any;
        columns: {};
        removeColumnsForObject(objectIdentifier: any): void;
        /**
         * @private
         * @param {*} object
         */
        private objectMutated;
        unlistenFromMutation: any;
        notPersistable: boolean;
        getConfiguration(): any;
        updateConfiguration(configuration: any): void;
        addSingleColumnForObject(telemetryObject: any, column: any, position: any): void;
        hasColumnWithKey(columnKey: any): boolean;
        getColumns(): {};
        getAllHeaders(): any;
        getVisibleHeaders(): any;
        getTelemetryMode(): any;
        setTelemetryMode(mode: any): void;
        getRowLimit(): any;
        setRowLimit(limit: any): void;
        getPersistModeChange(): any;
        setPersistModeChange(value: any): void;
        getColumnWidths(): any;
        setColumnWidths(columnWidths: any): void;
        getColumnOrder(): any;
        setColumnOrder(columnOrder: any): void;
        destroy(): void;
    }
    import { EventEmitter } from "eventemitter3";
}
declare module "src/plugins/telemetryTable/TableConfigurationViewProvider" {
    export default function TableConfigurationViewProvider(openmct: any, options: any): {
        key: string;
        name: string;
        canView: (selection: any) => any;
        view: (selection: any) => {
            show: (element: any) => void;
            showTab: (isEditing: any) => any;
            priority: () => number;
            destroy: () => void;
        };
    };
}
declare module "src/plugins/telemetryTable/TelemetryTableType" {
    /*****************************************************************************
     * Open MCT, Copyright (c) 2014-2024, United States Government
     * as represented by the Administrator of the National Aeronautics and Space
     * Administration. All rights reserved.
     *
     * Open MCT is licensed under the Apache License, Version 2.0 (the
     * "License"); you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     * http://www.apache.org/licenses/LICENSE-2.0.
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
     * License for the specific language governing permissions and limitations
     * under the License.
     *
     * Open MCT includes source code licensed under additional open source
     * licenses. See the Open Source Licenses file (LICENSES.md) included with
     * this source code distribution or the Licensing information page available
     * at runtime from the About dialog for additional information.
     *****************************************************************************/
    export default function getTelemetryTableType(options: any): {
        name: string;
        description: string;
        creatable: boolean;
        cssClass: string;
        form: ({
            key: string;
            name: string;
            control: string;
            options: {
                value: string;
                name: string;
            }[];
            cssClass: string;
            property: string[];
        } | {
            name: string;
            control: string;
            cssClass: string;
            key: string;
            property: string[];
            options?: undefined;
        })[];
        initialize(domainObject: any): void;
    };
}
declare module "src/utils/staleness" {
    export default StalenessUtils;
    /*****************************************************************************
     * Open MCT, Copyright (c) 2014-2024, United States Government
     * as represented by the Administrator of the National Aeronautics and Space
     * Administration. All rights reserved.
     *
     * Open MCT is licensed under the Apache License, Version 2.0 (the
     * "License"); you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     * http://www.apache.org/licenses/LICENSE-2.0.
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
     * License for the specific language governing permissions and limitations
     * under the License.
     *
     * Open MCT includes source code licensed under additional open source
     * licenses. See the Open Source Licenses file (LICENSES.md) included with
     * this source code distribution or the Licensing information page available
     * at runtime from the About dialog for additional information.
     *****************************************************************************/
    class StalenessUtils {
        constructor(openmct: any, domainObject: any);
        openmct: any;
        domainObject: any;
        metadata: any;
        lastStalenessResponseTime: number;
        timeSystemKey: any;
        shouldUpdateStaleness(stalenessResponse: any, id: any): boolean;
        watchTimeSystem(): void;
        unwatchTimeSystem(): void;
        setTimeSystem(timeSystem: any): void;
        timeSystem: any;
        parseTime(stalenessResponse: any): any;
        destroy(): void;
    }
}
declare module "src/plugins/telemetryTable/collections/TableRowCollection" {
    /**
     * @constructor
     */
    export default class TableRowCollection extends EventEmitter<string | symbol, any> {
        constructor();
        rows: any[];
        columnFilters: {};
        addRows(rows: any): void;
        removeRowsByObject(keyString: any): void;
        removeRowsByData(data: any): void;
        clear(): void;
        clearRowsFromTableAndFilter(rows: any): void;
        filterRows(rows: any): any;
        sortAndMergeRows(rows: any): void;
        getInPlaceUpdateIndex(row: any): number;
        updateRowInPlace(row: any, index: any): void;
        setLimit(rowLimit: any): void;
        rowLimit: any;
        removeLimit(): void;
        sortCollection(rows: any): any[];
        insertOrUpdateRows(rowsToAdd: any, addToBeginning: any): void;
        mergeSortedRows(incomingRows: any): void;
        firstRowInSortOrder(row1: any, row2: any): any;
        /**
         * Sorts the telemetry collection based on the provided sort field
         * specifier. Subsequent inserts are sorted to maintain specified sport
         * order.
         *
         * @example
         * // First build some mock telemetry for the purpose of an example
         * let now = Date.now();
         * let telemetry = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10].map(function (value) {
         *     return {
         *         // define an object property to demonstrate nested paths
         *         timestamp: {
         *             ms: now - value * 1000,
         *             text:
         *         },
         *         value: value
         *     }
         * });
         * let collection = new TelemetryCollection();
         *
         * collection.add(telemetry);
         *
         * // Sort by telemetry value
         * collection.sortBy({
         *  key: 'value', direction: 'asc'
         * });
         *
         * // Sort by ms since epoch
         * collection.sort({
         *  key: 'timestamp.ms',
         *  direction: 'asc'
         * });
         *
         * // Sort by 'text' attribute, descending
         * collection.sort("timestamp.text");
         *
         *
         * @param {Object} sortOptions An object specifying a sort key, and direction.
         */
        sortBy(sortOptions: any, ...args: any[]): any;
        sortOptions: any;
        setColumnFilter(columnKey: any, filter: any): void;
        setColumnRegexFilter(columnKey: any, filter: any): void;
        getColumnMapForObject(objectKeyString: any): any;
        isSubsetOfCurrentFilter(columnKey: any, filter: any): any;
        /**
         * @private
         */
        private matchesFilters;
        rowHasColumn(row: any, key: any): boolean;
        getRows(): any[];
        getRowsLength(): any;
        getValueForSortColumn(row: any): any;
        destroy(): void;
    }
    import { EventEmitter } from "eventemitter3";
}
declare module "src/plugins/telemetryTable/TelemetryTableColumn" {
    /*****************************************************************************
     * Open MCT, Copyright (c) 2014-2024, United States Government
     * as represented by the Administrator of the National Aeronautics and Space
     * Administration. All rights reserved.
     *
     * Open MCT is licensed under the Apache License, Version 2.0 (the
     * "License"); you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     * http://www.apache.org/licenses/LICENSE-2.0.
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
     * License for the specific language governing permissions and limitations
     * under the License.
     *
     * Open MCT includes source code licensed under additional open source
     * licenses. See the Open Source Licenses file (LICENSES.md) included with
     * this source code distribution or the Licensing information page available
     * at runtime from the About dialog for additional information.
     *****************************************************************************/
    export default class TelemetryTableColumn {
        constructor(openmct: any, metadatum: any, options?: {
            selectable: boolean;
        });
        metadatum: any;
        formatter: any;
        titleValue: any;
        selectable: boolean;
        getKey(): any;
        getTitle(): any;
        getMetadatum(): any;
        hasValueForDatum(telemetryDatum: any): boolean;
        getRawValue(telemetryDatum: any): any;
        getFormattedValue(telemetryDatum: any): any;
        getParsedValue(telemetryDatum: any): any;
    }
}
declare module "src/plugins/telemetryTable/TelemetryTableNameColumn" {
    export default class TelemetryTableNameColumn extends TelemetryTableColumn {
        constructor(openmct: any, telemetryObject: any, metadatum: any);
        telemetryObject: any;
        getRawValue(): any;
        getFormattedValue(): any;
    }
    import TelemetryTableColumn from "src/plugins/telemetryTable/TelemetryTableColumn";
}
declare module "src/plugins/telemetryTable/TelemetryTableRow" {
    export default class TelemetryTableRow {
        constructor(datum: any, columns: any, objectKeyString: any, limitEvaluator: any, inPlaceUpdateKey: any);
        columns: any;
        datum: any;
        fullDatum: any;
        limitEvaluator: any;
        objectKeyString: any;
        inPlaceUpdateKey: any;
        getFormattedDatum(headers: any): {};
        getFormattedValue(key: any): any;
        getParsedValue(key: any): any;
        getCellComponentName(key: any): any;
        getRowClass(): any;
        rowClass: any;
        getCellLimitClasses(): any;
        cellLimitClasses: any;
        getContextualDomainObject(openmct: any, objectKeyString: any): any;
        getContextMenuActions(): any[];
        updateWithDatum(updatesToDatum: any): void;
    }
}
declare module "src/plugins/telemetryTable/TelemetryTableUnitColumn" {
    export default TelemetryTableUnitColumn;
    class TelemetryTableUnitColumn extends TelemetryTableColumn {
        constructor(openmct: any, metadatum: any);
        isUnit: boolean;
        formatter: {
            format: (datum: any) => any;
            parse: (datum: any) => any;
        };
        getKey(): string;
        getTitle(): string;
    }
    import TelemetryTableColumn from "src/plugins/telemetryTable/TelemetryTableColumn";
}
declare module "src/plugins/telemetryTable/TelemetryTable" {
    export default class TelemetryTable extends EventEmitter<string | symbol, any> {
        constructor(domainObject: any, openmct: any, options: any);
        domainObject: any;
        openmct: any;
        tableComposition: any;
        datumCache: any[];
        configuration: TelemetryTableConfiguration;
        telemetryMode: any;
        rowLimit: any;
        paused: boolean;
        keyString: any;
        telemetryObjects: {};
        subscribedStaleObjects: Map<any, any>;
        telemetryCollections: {};
        delayedActions: any[];
        outstandingRequests: number;
        stalenessSubscription: {};
        addTelemetryObject(telemetryObject: any): void;
        removeTelemetryObject(objectIdentifier: any): void;
        removeTelemetryCollection(keyString: any): void;
        /**
         * @private
         */
        private incrementOutstandingRequests;
        /**
         * @private
         */
        private decrementOutstandingRequests;
        resetRowsFromAllData(): void;
        isTelemetryObject(domainObject: any): boolean;
        updateFilters(updatedFilters: any): void;
        clearData(): void;
        buildOptionsFromConfiguration(telemetryObject: any): {
            filters: any;
        };
        filterObserver: any;
        resubscribeToStaleness: () => void;
        /**
         * @private
         */
        private addNameColumn;
        initialize(): void;
        filters: any;
        updateTelemetryMode(mode: any): void;
        updateRowLimit(rowLimit: any): void;
        createTableRowCollections(): void;
        tableRows: TableRowCollection | undefined;
        loadComposition(): void;
        resubscribeAllObjectsToStaleness(): void;
        subscribeToStaleness(domainObject: any): void;
        handleStaleness(keyString: any, stalenessResponse: any, skipCheck?: boolean): void;
        getTelemetryProcessor(keyString: any, columnMap: any, limitEvaluator: any): (telemetry: any) => void;
        getTelemetryRemover(): (telemetry: any) => void;
        clearAndResubscribe(): void;
        unsubscribeFromStaleness(objectIdentifier: any): void;
        addColumnsForObject(telemetryObject: any): void;
        getColumnMapForObject(objectKeyString: any): any;
        createColumn(metadatum: any): TelemetryTableColumn;
        createUnitColumn(metadatum: any): TelemetryTableUnitColumn;
        sortBy(sortOptions: any): void;
        runDelayedActions(): void;
        pause(): void;
        unpause(): void;
        destroy(): void;
    }
    import { EventEmitter } from "eventemitter3";
    import TelemetryTableConfiguration from "src/plugins/telemetryTable/TelemetryTableConfiguration";
    import TableRowCollection from "src/plugins/telemetryTable/collections/TableRowCollection";
    import TelemetryTableColumn from "src/plugins/telemetryTable/TelemetryTableColumn";
    import TelemetryTableUnitColumn from "src/plugins/telemetryTable/TelemetryTableUnitColumn";
}
declare module "src/plugins/telemetryTable/TelemetryTableView" {
    export default class TelemetryTableView {
        constructor(openmct: any, domainObject: any, objectPath: any, options: any);
        openmct: any;
        domainObject: any;
        objectPath: any;
        _destroy: any;
        component: any;
        getViewContext(): any;
        onEditModeChange(editMode: any): void;
        onClearData(): void;
        getTable(): any;
        destroy(): void;
        show(element: any, editMode: any, { renderWhenVisible }: {
            renderWhenVisible: any;
        }): void;
    }
}
declare module "src/plugins/telemetryTable/TelemetryTableViewProvider" {
    export default function TelemetryTableViewProvider(openmct: any, options: any): {
        key: string;
        name: string;
        cssClass: string;
        canView(domainObject: any): boolean;
        canEdit(domainObject: any): boolean;
        view(domainObject: any, objectPath: any): TelemetryTableView;
        priority(): number;
    };
    import TelemetryTableView from "src/plugins/telemetryTable/TelemetryTableView";
}
declare module "src/plugins/telemetryTable/ViewActions" {
    export default viewActions;
    const viewActions: {
        name: string;
        key: string;
        description: string;
        cssClass: string;
        invoke: (objectPath: any, view: any) => void;
        group: string;
    }[];
}
declare module "src/plugins/telemetryTable/plugin" {
    export default function plugin(options?: {
        telemetryMode: string;
        persistModeChange: boolean;
        rowLimit: number;
    }): (openmct: any) => void;
}
declare module "src/plugins/themes/installTheme" {
    export function installTheme(openmct: any, themeName: any): void;
}
declare module "src/plugins/themes/darkmatter" {
    export default function plugin(): (openmct: any) => void;
}
declare module "src/plugins/themes/espresso" {
    export default function plugin(): (openmct: any) => void;
}
declare module "src/plugins/themes/snow" {
    export default function plugin(): (openmct: any) => void;
}
declare module "src/plugins/timeConductor/plugin" {
    export default function _default(config: any): (openmct: any) => void;
}
declare module "src/plugins/timeline/TimelineCompositionPolicy" {
    export default function TimelineCompositionPolicy(openmct: any): {
        allow: (parent: any, child: any) => boolean;
    };
}
declare module "src/plugins/timeline/timelineInterceptor" {
    /*****************************************************************************
     * Open MCT, Copyright (c) 2014-2024, United States Government
     * as represented by the Administrator of the National Aeronautics and Space
     * Administration. All rights reserved.
     *
     * Open MCT is licensed under the Apache License, Version 2.0 (the
     * "License"); you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     * http://www.apache.org/licenses/LICENSE-2.0.
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
     * License for the specific language governing permissions and limitations
     * under the License.
     *
     * Open MCT includes source code licensed under additional open source
     * licenses. See the Open Source Licenses file (LICENSES.md) included with
     * this source code distribution or the Licensing information page available
     * at runtime from the About dialog for additional information.
     *****************************************************************************/
    export default function timelineInterceptor(openmct: any): void;
}
declare module "src/plugins/timeline/TimelineViewProvider" {
    export default function TimelineViewProvider(openmct: any): {
        key: string;
        name: string;
        cssClass: string;
        canView(domainObject: any): boolean;
        canEdit(domainObject: any): boolean;
        view: (domainObject: any, objectPath: any) => {
            show: (element: any) => void;
            destroy: () => void;
        };
    };
}
declare module "src/plugins/timeline/plugin" {
    export default function _default(): (openmct: any) => void;
}
declare module "src/plugins/timelist/constants" {
    export const SORT_ORDER_OPTIONS: {
        label: string;
        property: string;
        direction: string;
    }[];
    export const TIMELIST_TYPE: "timelist";
    export const CURRENT_CSS_SUFFIX: "--is-current";
    export const PAST_CSS_SUFFIX: "--is-past";
    export const FUTURE_CSS_SUFFIX: "--is-future";
}
declare module "src/plugins/timelist/inspector/TimeListInspectorViewProvider" {
    export default function TimeListInspectorViewProvider(openmct: any): {
        key: string;
        name: string;
        canView: (selection: any) => any;
        view: (selection: any) => {
            show: (element: any) => void;
            priority: () => any;
            destroy: () => void;
        };
    };
}
declare module "src/plugins/timelist/TimelistViewProvider" {
    export default function TimelistViewProvider(openmct: any): {
        key: string;
        name: string;
        cssClass: string;
        canView(domainObject: any): boolean;
        canEdit(domainObject: any): boolean;
        view: (domainObject: any, objectPath: any) => {
            show: (element: any) => void;
            destroy: () => void;
        };
    };
}
declare module "src/plugins/timelist/plugin" {
    export default function _default(): (openmct: any) => void;
}
declare module "src/plugins/timer/actions/PauseTimerAction" {
    export default PauseTimerAction;
    /*****************************************************************************
     * Open MCT, Copyright (c) 2014-2024, United States Government
     * as represented by the Administrator of the National Aeronautics and Space
     * Administration. All rights reserved.
     *
     * Open MCT is licensed under the Apache License, Version 2.0 (the
     * "License"); you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     * http://www.apache.org/licenses/LICENSE-2.0.
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
     * License for the specific language governing permissions and limitations
     * under the License.
     *
     * Open MCT includes source code licensed under additional open source
     * licenses. See the Open Source Licenses file (LICENSES.md) included with
     * this source code distribution or the Licensing information page available
     * at runtime from the About dialog for additional information.
     *****************************************************************************/
    export const PAUSE_TIMER_ACTION_KEY: "timer.pause";
    class PauseTimerAction {
        constructor(openmct: any);
        name: string;
        key: string;
        description: string;
        group: string;
        cssClass: string;
        priority: number;
        openmct: any;
        invoke(objectPath: any): Error | undefined;
        appliesTo(objectPath: any, view?: {}): boolean | undefined;
    }
}
declare module "src/plugins/timer/actions/RestartTimerAction" {
    export default RestartTimerAction;
    /*****************************************************************************
     * Open MCT, Copyright (c) 2014-2024, United States Government
     * as represented by the Administrator of the National Aeronautics and Space
     * Administration. All rights reserved.
     *
     * Open MCT is licensed under the Apache License, Version 2.0 (the
     * "License"); you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     * http://www.apache.org/licenses/LICENSE-2.0.
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
     * License for the specific language governing permissions and limitations
     * under the License.
     *
     * Open MCT includes source code licensed under additional open source
     * licenses. See the Open Source Licenses file (LICENSES.md) included with
     * this source code distribution or the Licensing information page available
     * at runtime from the About dialog for additional information.
     *****************************************************************************/
    export const RESTART_TIMER_ACTION_KEY: "timer.restart";
    class RestartTimerAction {
        constructor(openmct: any);
        name: string;
        key: string;
        description: string;
        group: string;
        cssClass: string;
        priority: number;
        openmct: any;
        invoke(objectPath: any): Error | undefined;
        appliesTo(objectPath: any, view?: {}): boolean | undefined;
    }
}
declare module "src/plugins/timer/actions/StartTimerAction" {
    export default StartTimerAction;
    /*****************************************************************************
     * Open MCT, Copyright (c) 2014-2024, United States Government
     * as represented by the Administrator of the National Aeronautics and Space
     * Administration. All rights reserved.
     *
     * Open MCT is licensed under the Apache License, Version 2.0 (the
     * "License"); you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     * http://www.apache.org/licenses/LICENSE-2.0.
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
     * License for the specific language governing permissions and limitations
     * under the License.
     *
     * Open MCT includes source code licensed under additional open source
     * licenses. See the Open Source Licenses file (LICENSES.md) included with
     * this source code distribution or the Licensing information page available
     * at runtime from the About dialog for additional information.
     *****************************************************************************/
    export const START_TIMER_ACTION_KEY: "timer.start";
    class StartTimerAction {
        constructor(openmct: any);
        name: string;
        key: string;
        description: string;
        group: string;
        cssClass: string;
        priority: number;
        openmct: any;
        invoke(objectPath: any): Error | undefined;
        appliesTo(objectPath: any, view?: {}): boolean | undefined;
    }
}
declare module "src/plugins/timer/actions/StopTimerAction" {
    export default StopTimerAction;
    /*****************************************************************************
     * Open MCT, Copyright (c) 2014-2024, United States Government
     * as represented by the Administrator of the National Aeronautics and Space
     * Administration. All rights reserved.
     *
     * Open MCT is licensed under the Apache License, Version 2.0 (the
     * "License"); you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     * http://www.apache.org/licenses/LICENSE-2.0.
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
     * License for the specific language governing permissions and limitations
     * under the License.
     *
     * Open MCT includes source code licensed under additional open source
     * licenses. See the Open Source Licenses file (LICENSES.md) included with
     * this source code distribution or the Licensing information page available
     * at runtime from the About dialog for additional information.
     *****************************************************************************/
    export const STOP_TIMER_ACTION_KEY: "timer.stop";
    class StopTimerAction {
        constructor(openmct: any);
        name: string;
        key: string;
        description: string;
        group: string;
        cssClass: string;
        priority: number;
        openmct: any;
        invoke(objectPath: any): Error | undefined;
        appliesTo(objectPath: any, view?: {}): boolean | undefined;
    }
}
declare module "src/plugins/timer/TimerViewProvider" {
    export default function TimerViewProvider(openmct: any): {
        key: string;
        name: string;
        cssClass: string;
        canView(domainObject: any): boolean;
        view: (domainObject: any, objectPath: any) => {
            show: (element: any) => void;
            destroy: () => void;
        };
    };
}
declare module "src/plugins/timer/plugin" {
    /** @type {OpenMCTPlugin} */
    export default function TimerPlugin(): (openmct: any) => void;
}
declare module "src/plugins/URLIndicatorPlugin/URLIndicator" {
    export default function URLIndicator(options: any, simpleIndicator: any): void;
    export default class URLIndicator {
        constructor(options: any, simpleIndicator: any);
        count: number;
        indicator: any;
        setIndicatorToState: (state: any) => void;
        fetchUrl: () => void;
        handleError: (e: any) => void;
        handleSuccess: () => void;
        setDefaultsFromOptions(options: any): void;
        URLpath: any;
        label: any;
        interval: any;
        bindMethods(): void;
    }
}
declare module "src/plugins/URLIndicatorPlugin/URLIndicatorPlugin" {
    export default function URLIndicatorPlugin(opts: any): (openmct: any) => URLIndicator;
    import URLIndicator from "src/plugins/URLIndicatorPlugin/URLIndicator";
}
declare module "src/plugins/URLTimeSettingsSynchronizer/URLTimeSettingsSynchronizer" {
    export default class URLTimeSettingsSynchronizer {
        constructor(openmct: any);
        openmct: any;
        isUrlUpdateInProgress: boolean;
        initialize(): void;
        destroy(): void;
        updateTimeSettings(): void;
        setUrlFromTimeApi(): void;
        updateBounds(bounds: any, isTick: any): void;
        parseParametersFromUrl(): {
            mode: any;
            timeSystem: any;
            bounds: {
                start: number;
                end: number;
            };
            clockOffsets: {
                start: number;
                end: number;
            };
        };
        setTimeApiFromUrl(timeParameters: any): void;
        areTimeParametersValid(timeParameters: any): boolean;
        areStartAndEndValid(bounds: any): boolean;
        isTimeSystemValid(timeSystem: any): boolean;
        isModeValid(mode: any): boolean;
        areStartAndEndEqual(firstBounds: any, secondBounds: any): boolean;
    }
}
declare module "src/plugins/URLTimeSettingsSynchronizer/plugin" {
    export default function _default(): (openmct: any) => URLTimeSettingsSynchronizer;
    import URLTimeSettingsSynchronizer from "src/plugins/URLTimeSettingsSynchronizer/URLTimeSettingsSynchronizer";
}
declare module "src/plugins/userIndicator/plugin" {
    export default function UserIndicatorPlugin(): (openmct: any) => void;
}
declare module "src/plugins/utcTimeSystem/DurationFormat" {
    export default DurationFormat;
    /**
     * Formatter for duration. Uses moment to produce a date from a given
     * value, but output is formatted to display only time. Can be used for
     * specifying a time duration. For specifying duration, it's best to
     * specify a date of January 1, 1970, as the ms offset will equal the
     * duration represented by the time.
     *
     * @implements {Format}
     * @constructor
     */
    class DurationFormat implements Format {
        key: string;
        format(value: any): string;
        parse(text: any): number;
        validate(text: any): boolean;
    }
}
declare module "src/plugins/utcTimeSystem/LocalClock" {
    /**
     * A {@link openmct.TimeAPI.Clock} that updates the temporal bounds of the
     * application based on UTC time values provided by a ticking local clock,
     * with the periodicity specified.
     * @param {number} period The periodicity with which the clock should tick
     * @constructor
     */
    export default class LocalClock extends DefaultClock {
        constructor(period?: number);
        period: number;
        timeoutHandle: NodeJS.Timeout | undefined;
        lastTick: number;
        tick(): void;
    }
    import DefaultClock from "src/utils/clock/DefaultClock";
}
declare module "src/plugins/utcTimeSystem/UTCTimeFormat" {
    /**
     * Formatter for UTC timestamps. Interprets numeric values as
     * milliseconds since the start of 1970.
     *
     * @implements {Format}
     * @constructor
     */
    export default class UTCTimeFormat implements Format {
        key: string;
        DATE_FORMAT: string;
        DATE_FORMATS: {
            PRECISION_DEFAULT: string;
            PRECISION_DEFAULT_WITH_ZULU: string;
            PRECISION_SECONDS: string;
            PRECISION_MINUTES: string;
            PRECISION_DAYS: string;
            PRECISION_SECONDS_TIME_ONLY: string;
            PRECISION_MINUTES_TIME_ONLY: string;
        };
        /**
         * @param {string} formatString
         * @returns the value of formatString if the value is a string type and exists in the DATE_FORMATS array; otherwise the DATE_FORMAT value.
         */
        isValidFormatString(formatString: string): boolean;
        /**
         * @param {number} value The value to format.
         * @returns {string} the formatted date(s). If multiple values were requested, then an array of
         * formatted values will be returned. Where a value could not be formatted, `undefined` will be returned at its position
         * in the array.
         */
        format(value: number, formatString: any): string;
        parse(text: any): number;
        validate(text: any): boolean;
    }
}
declare module "src/plugins/utcTimeSystem/UTCTimeSystem" {
    export default UTCTimeSystem;
    /*****************************************************************************
     * Open MCT Web, Copyright (c) 2014-2024, United States Government
     * as represented by the Administrator of the National Aeronautics and Space
     * Administration. All rights reserved.
     *
     * Open MCT Web is licensed under the Apache License, Version 2.0 (the
     * "License"); you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     * http://www.apache.org/licenses/LICENSE-2.0.
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
     * License for the specific language governing permissions and limitations
     * under the License.
     *
     * Open MCT Web includes source code licensed under additional open source
     * licenses. See the Open Source Licenses file (LICENSES.md) included with
     * this source code distribution or the Licensing information page available
     * at runtime from the About dialog for additional information.
     *****************************************************************************/
    /**
     * This time system supports UTC dates.
     * @implements TimeSystem
     * @constructor
     */
    class UTCTimeSystem implements TimeSystem {
        key: string;
        name: string;
        cssClass: string;
        timeFormat: string;
        durationFormat: string;
        isUTCBased: boolean;
    }
}
declare module "src/plugins/utcTimeSystem/plugin" {
    /**
     * Install a time system that supports UTC times. It also installs a local
     * clock source that ticks every 100ms, providing UTC times.
     */
    export default function _default(): (openmct: any) => void;
}
declare module "src/plugins/viewDatumAction/ViewDatumAction" {
    export default ViewDatumAction;
    export const VIEW_DATUM_ACTION_KEY: "viewDatumAction";
    class ViewDatumAction {
        constructor(openmct: any);
        name: string;
        key: string;
        description: string;
        cssClass: string;
        openmct: any;
        invoke(objectPath: any, view: any): void;
        appliesTo(objectPath: any, view?: {}): boolean;
    }
}
declare module "src/plugins/viewDatumAction/plugin" {
    export default function plugin(): (openmct: any) => void;
}
declare module "src/plugins/viewLargeAction/viewLargeAction" {
    export default ViewLargeAction;
    export const VIEW_LARGE_ACTION_KEY: "large.view";
    class ViewLargeAction {
        constructor(openmct: any);
        openmct: any;
        cssClass: string;
        description: string;
        group: string;
        key: string;
        name: string;
        priority: number;
        showInStatusBar: boolean;
        destroy: (() => void) | null;
        preview: any;
        invoke(objectPath: any, view: any): void;
        appliesTo(objectPath: any, view: any): any;
        _expand(objectPath: any, view: any): void;
        overlay: any;
        _getPreview(objectPath: any, view: any): any;
    }
}
declare module "src/plugins/viewLargeAction/plugin" {
    export default function plugin(): (openmct: any) => void;
}
declare module "src/plugins/webPage/WebPageViewProvider" {
    export default function WebPage(openmct: any): {
        key: string;
        name: string;
        cssClass: string;
        canView: (domainObject: any) => boolean;
        view: (domainObject: any) => {
            show: (element: any) => void;
            destroy: () => void;
        };
        priority: () => number;
    };
}
declare module "src/plugins/webPage/plugin" {
    export default function plugin(): (openmct: any) => void;
}
declare module "src/plugins/plugins" {
    export default plugins;
    /**
     * @type {Object}
     */
    const plugins: any;
}
declare module "src/plugins/remove/RemoveAction" {
    export default RemoveAction;
    export const REMOVE_ACTION_KEY: "remove";
    class RemoveAction {
        constructor(openmct: any);
        name: string;
        key: string;
        description: string;
        cssClass: string;
        group: string;
        priority: number;
        openmct: any;
        removeFromComposition(parent: any, child: any, objectPath: any): Promise<void>;
        invoke(objectPath: any): Promise<void>;
        showConfirmDialog(child: any, parent: any): Promise<any>;
        inNavigationPath(object: any): any;
        navigateTo(objectPath: any): void;
        appliesTo(objectPath: any): any;
        startTransaction(): void;
        saveTransaction(): Promise<void>;
        #private;
    }
}
declare module "src/plugins/remove/plugin" {
    export default function _default(): (openmct: any) => void;
}
declare module "src/selection/Selection" {
    /**
     * @typedef {Object} Selectable
     * @property {HTMLElement} element The HTML element that is selectable
     * @property {Object} context The context of the selectable, which may include a DomainObject
     */
    /**
     * @typedef {import('../../src/MCT').MCT} OpenMCT
     */
    /**
     * Manages selection state for Open MCT
     * @constructor
     * @extends EventEmitter
     */
    export default class Selection extends EventEmitter<string | symbol, any> {
        /**
         * @param {OpenMCT} openmct The Open MCT instance
         */
        constructor(openmct: OpenMCT);
        /** @type {OpenMCT} */
        openmct: OpenMCT;
        /** @type {Selectable[]} */
        selected: Selectable[];
        /**
         * Gets the selected object.
         * @returns {Selectable[]} The currently selected objects
         * @public
         */
        public get(): Selectable[];
        /**
         * Selects the selectable object and emits the 'change' event.
         *
         * @param {Selectable|Selectable[]} selectable An object or array of objects with element and context properties
         * @param {boolean} isMultiSelectEvent flag indication shift key is pressed or not
         * @private
         */
        private select;
        /**
         * @private
         */
        private handleMultiSelect;
        /**
         * @private
         */
        private handleSingleSelect;
        /**
         * @private
         */
        private elementSelected;
        /**
         * @private
         */
        private remove;
        /**
         * @private
         */
        private setSelectionStyles;
        removeSelectionAttributes(selectionPath: any, keepParentStyle: any): void;
        /**
         * Adds selection attributes to the selected element and its parent.
         * @private
         */
        private addSelectionAttributes;
        /**
         * @private
         */
        private parentSupportsMultiSelect;
        /**
         * @private
         */
        private selectionContainsParent;
        /**
         * @private
         */
        private isPeer;
        /**
         * @private
         */
        private isSelectable;
        /**
         * @private
         */
        private capture;
        capturing: any[] | undefined;
        /**
         * @private
         */
        private selectCapture;
        /**
         * Attaches the click handlers to the element.
         *
         * @param element an html element
         * @param context object which defines item or other arbitrary properties.
         * e.g. {
         *          item: domainObject,
         *          elementProxy: element,
         *          controller: fixedController
         *       }
         * @param select a flag to select the element if true
         * @returns a function that removes the click handlers from the element
         * @public
         */
        public selectable(element: any, context: any, select: any): () => void;
    }
    export type Selectable = {
        /**
         * The HTML element that is selectable
         */
        element: HTMLElement;
        /**
         * The context of the selectable, which may include a DomainObject
         */
        context: any;
    };
    export type OpenMCT = import("src/MCT").MCT;
    import { EventEmitter } from "eventemitter3";
}
declare module "src/ui/preview/PreviewAction" {
    export default PreviewAction;
    export const PREVIEW_ACTION_KEY: "preview";
    class PreviewAction extends EventEmitter<string | symbol, any> {
        constructor(openmct: any);
        /**
         * Metadata
         */
        name: string;
        key: string;
        description: string;
        cssClass: string;
        group: string;
        priority: number;
        /**
         * Dependencies
         */
        _openmct: any;
        invoke(objectPath: any, viewOptions: any): void;
        appliesTo(objectPath: any, view?: {}): boolean;
        _preventPreview(objectPath: any): boolean;
    }
    import { EventEmitter } from "eventemitter3";
}
declare module "src/ui/preview/ViewHistoricalDataAction" {
    export default ViewHistoricalDataAction;
    export const VIEW_HISTORICAL_DATA_ACTION_KEY: "viewHistoricalData";
    class ViewHistoricalDataAction extends PreviewAction {
        hideInDefaultMenu: boolean;
        appliesTo(objectPath: any, view?: {}): any;
    }
    import PreviewAction from "src/ui/preview/PreviewAction";
}
declare module "src/ui/preview/plugin" {
    export default function _default(): (openmct: any) => void;
}
declare module "src/ui/registries/InspectorViewRegistry" {
    /**
     * A InspectorViewRegistry maintains the definitions for views
     * that may occur in the inspector.
     */
    export default class InspectorViewRegistry {
        /** @type {Record<string, ViewProvider>} */
        providers: Record<string, ViewProvider>;
        /**
         *
         * @param {DomainObject} selection the object to be viewed
         * @returns {ViewProvider[]} any providers
         *          which can provide views of this object
         * @private for platform-internal use
         */
        private get;
        /**
         * Registers a new inspector view provider.
         *
         * @param {ViewProvider} provider the provider for this view
         */
        addProvider(provider: ViewProvider): void;
        /**
         * Retrieves a view provider by its key.
         * @param {string} key the key of the view provider
         * @returns {ViewProvider} the view provider
         */
        getByProviderKey(key: string): ViewProvider;
        #private;
    }
    export type View = import("openmct").View;
    export type ViewProvider = import("openmct").ViewProvider;
    export type DomainObject = import("openmct").DomainObject;
}
declare module "src/ui/registries/ToolbarRegistry" {
    /*****************************************************************************
     * Open MCT, Copyright (c) 2014-2024, United States Government
     * as represented by the Administrator of the National Aeronautics and Space
     * Administration. All rights reserved.
     *
     * Open MCT is licensed under the Apache License, Version 2.0 (the
     * "License"); you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     * http://www.apache.org/licenses/LICENSE-2.0.
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
     * License for the specific language governing permissions and limitations
     * under the License.
     *
     * Open MCT includes source code licensed under additional open source
     * licenses. See the Open Source Licenses file (LICENSES.md) included with
     * this source code distribution or the Licensing information page available
     * at runtime from the About dialog for additional information.
     *****************************************************************************/
    /**
     * A ToolbarRegistry maintains the definitions for toolbars.
     *
     * @interface ToolbarRegistry
     */
    export default function ToolbarRegistry(): void;
    export default class ToolbarRegistry {
        providers: {};
        private get;
        private getAllProviders;
        private getByProviderKey;
        /**
         * Registers a new type of toolbar.
         *
         * @param {module:openmct.ToolbarRegistry} provider the provider for this toolbar
         * @method addProvider
         */
        addProvider(provider: any): void;
    }
}
declare module "src/ui/registries/ViewRegistry" {
    /**
     * A ViewRegistry maintains the definitions for different kinds of views
     * that may occur in different places in the user interface.
     */
    export default class ViewRegistry extends EventEmitter<string | symbol, any> {
        constructor();
        /** @type {Record<string, ViewProvider>} */
        providers: Record<string, ViewProvider>;
        /**
         * for platform-internal use
         * @param {import('openmct').DomainObject} item the object to be viewed
         * @param {import('openmct').ObjectPath} objectPath - The current contextual object path of the view object
         * @returns {ViewProvider[]} a list of providers that can provide views for this object, sorted by
         * descending priority
         */
        get(item: import('openmct').DomainObject, objectPath: import('openmct').ObjectPath): ViewProvider[];
        /**
         * @private
         */
        private getAllProviders;
        /**
         * Register a new type of view.
         *
         * @param {ViewProvider} provider the provider for this view
         */
        addProvider(provider: ViewProvider): void;
        /**
         * Returns the view provider by key
         * @param {string} key
         * @returns {ViewProvider}
         */
        getByProviderKey(key: string): ViewProvider;
        /**
         * Used internally to support seamless usage of new views with old
         * views.
         * @private
         */
        private getByVPID;
    }
    export type DomainObject = import("openmct").DomainObject;
    export type ObjectPath = import("openmct").ObjectPath;
    export type ViewOptions = {
        /**
         * This function can be used for all rendering logic that would otherwise be executed within a
         * `requestAnimationFrame` call. When called, `renderWhenVisible` will either execute the provided
         * function immediately (via `requestAnimationFrame`) if the view is currently visible, or defer its
         * execution until the view becomes visible.
         *
         * Additionally, `renderWhenVisible` returns a boolean value indicating whether the provided
         * function was executed immediately (`true`) or deferred (`false`).
         * Monitoring of visibility begins after the first call to `renderWhenVisible` is made.
         */
        renderWhenVisible?: (() => void) | undefined;
    };
    /**
     * A View is used to provide displayable content, and to react to
     * associated life cycle events.
     */
    export type View = {
        /**
         * Populate the supplied DOM element with the contents of this view.
         * View implementations should use this method to attach any
         * listeners or acquire other resources that are necessary to keep
         * the contents of this view up-to-date.
         *
         * - `container`: The DOM element where the view should be rendered.
         * - `isEditing`: Indicates whether the view is in editing mode.
         * - `viewOptions`: An object with configuration options for the view.
         */
        show: (container: HTMLElement, isEditing: boolean | undefined, viewOptions: ViewOptions | undefined) => void;
        /**
         * - Release any resources associated with this view.
         * View implementations should use this method to detach any listeners or release other resources
         * that are no longer necessary once a view is no longer used.
         */
        destroy: () => void;
        /**
         * A function that returns the selection context of the view.
         *
         * View implementations may use this method to customize the selection context.
         */
        getSelectionContext?: (() => {
            item: DomainObject;
            isMultiSelectEvent: boolean;
        }) | undefined;
    };
    /**
     * Exposes types of views in Open MCT.
     */
    export type ViewProvider = {
        /**
         * - The unique key that identifies this view
         */
        key: string;
        /**
         * - The name of the view
         */
        name: string;
        /**
         * - The CSS class to apply to labels for this view (to add icons,
         * for instance)
         */
        cssClass?: string | undefined;
        /**
         * Returns true if this provider is able to supply views for the given {@link DomainObject }.
         *
         * When called by Open MCT, this may include additional arguments
         * which are on the path to the object to be viewed; for instance,
         * when viewing "A Folder" within "My Items", this method will be
         * invoked with "A Folder" (as a {@link DomainObject }) as the first argument.
         */
        canView: (domainObject: DomainObject, objectPath: import("openmct").ObjectPath) => boolean;
        /**
         * An optional function that defines whether or not this view can be used to edit a given object.
         * If not provided, will default to `false` and the view will not support editing.
         */
        canEdit?: ((domainObject: DomainObject, objectPath: import("openmct").ObjectPath) => boolean) | undefined;
        /**
         * A function that
         * provides a view for the provided domain object.
         */
        view: (domainObject: DomainObject, objectPath: import("openmct").ObjectPath) => View;
        /**
         * A function that returns the priority of the view. The more positive the value, the higher the
         * priority. Similarly, the more negative the value, the lower the priority.
         *
         * If not provided, the default priority of 100 will be used. This value is used to sort the views
         * by descending priority if there are multiple views that can be shown for a given object.
         */
        priority?: ((domainObject: DomainObject) => number) | undefined;
    };
    import { EventEmitter } from "eventemitter3";
}
declare module "src/ui/router/ApplicationRouter" {
    export default ApplicationRouter;
    class ApplicationRouter extends EventEmitter<string | symbol, any> {
        /**
         * events
         * change:params -> notify listeners w/ new, old, and changed.
         * change:path -> notify listeners w/ new, old paths.
         *
         * methods:
         * update(path, params) -> updates path and params at the same time.  Only
         *   updates specified params, other params are not modified.
         * updateParams(newParams) -> update only specified params, leaving rest
         *      intact.  Does not modify path.
         * updatePath(path);
         *
         * route(path, handler);
         * start(); Start routing.
         * @param {import('../../../openmct').OpenMCT} openmct
         */
        constructor(openmct: import('../../../openmct').OpenMCT);
        locationBar: any;
        openmct: import("src/MCT").MCT;
        routes: any[];
        started: boolean;
        path: any;
        /**
         * @private
         * Set new hash for url
         *
         * @param {string} hash new hash for url
         */
        private setHash;
        destroy(): void;
        /**
         * Delete a given query parameter from current url
         *
         * @param {string} paramName name of searchParam to delete from current url searchParams
         */
        deleteSearchParam(paramName: string): void;
        /**
         * object for accessing all current search parameters
         *
         * @returns {URLSearchParams} A {@link https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams/entries|URLSearchParams}
         */
        getAllSearchParams(): URLSearchParams;
        /**
         * Uniquely identifies a domain object.
         *
         * @typedef CurrentLocation
         * @property {URL} url current url location
         * @property {string} path current url location pathname
         * @property {string} getQueryString a function which returns url search query
         * @property {Object} params object representing url searchParams
         */
        /**
         * object for accessing current url location and search params
         *
         * @returns {CurrentLocation} A {@link CurrentLocation}
         */
        getCurrentLocation(): {
            /**
             * current url location
             */
            url: URL;
            /**
             * current url location pathname
             */
            path: string;
            /**
             * a function which returns url search query
             */
            getQueryString: string;
            /**
             * object representing url searchParams
             */
            params: any;
        };
        /**
         * Get current location URL Object
         *
         * @returns {URL} current url location
         */
        getHashRelativeURL(): URL;
        /**
         * Get current location URL Object searchParams
         *
         * @returns {Object} object representing current url searchParams
         */
        getParams(): any;
        /**
         * Get a value of given param from current url searchParams
         *
         * @returns {string} value of paramName from current url searchParams
         */
        getSearchParam(paramName: any): string;
        /**
         * Navigate to given hash, update current location object, and notify listeners about location change
         *
         * @param {string} hash The URL hash to navigate to in the form of "#/browse/mine/{keyString}/{keyString}".
         * Should not include any params.
         */
        navigate(hash: string): void;
        /**
         * Check if a given object and current location object are same
         *
         * @param {Array<Object>} objectPath Object path of a given Domain Object
         *
         * @returns {boolean}
         */
        isNavigatedObject(objectPath: Array<any>): boolean;
        /**
         * Add routes listeners
         *
         * @param {RegExp} matcher Regex to match value in url
         * @param {Function} callback function called when found match in url
         */
        route(matcher: RegExp, callback: Function): void;
        /**
         * Set url hash using path and queryString
         *
         * @param {string} path path for url
         * @param {string} queryString queryString for url
         */
        set(path: string, queryString: string): void;
        /**
         * Will replace all current search parameters with the ones defined in urlSearchParams
         */
        setAllSearchParams(): void;
        /**
         * To force update url based on value in currentLocation object
         */
        setLocationFromUrl(): void;
        /**
         * Set url hash using path
         *
         * @param {string} path path for url
         */
        setPath(path: string): void;
        /**
         * Update param value from current url searchParams
         *
         * @param {string} paramName param name from current url searchParams
         * @param {string} paramValue param value from current url searchParams
         */
        setSearchParam(paramName: string, paramValue: string): void;
        /**
         * start application routing, should be done after handlers are registered.
         */
        start(): void;
        /**
         * Set url hash using path and searchParams object
         *
         * @param {string} path path for url
         * @param {string} params oject representing searchParams key/value
         */
        update(path: string, params: string): void;
        /**
         * Update route params. Takes an object of updates.  New parameters
         */
        updateParams(updateParams: any): void;
        /**
         * To force update url based on value in currentLocation object
         */
        updateTimeSettings(): void;
        /**
         * @private
         * Create currentLocation object
         *
         * @param {string} pathString USVString representing relative URL.
         *
         * @returns {CurrentLocation} A {@link CurrentLocation}
         */
        private createLocation;
        /**
         * @private
         * Compare new and old path and on change emit event 'change:path'
         *
         * @param {string} newPath new path of url
         * @param {string} oldPath old path of url
         * @returns {boolean} true if path changed, false otherwise
         */
        private doPathChange;
        /**
         * @private
         * Compare new and old params and on change emit event 'change:params'
         *
         * @param {Object} newParams new params of url
         * @param {Object} oldParams old params of url
         * @returns {boolean} true if params changed, false otherwise
         */
        private doParamsChange;
        /**
         * @private
         * On location change, update currentLocation object and emit appropriate events
         *
         * @param {string} pathString USVString representing relative URL.
         */
        private handleLocationChange;
        currentLocation: {
            /**
             * current url location
             */
            url: URL;
            /**
             * current url location pathname
             */
            path: string;
            /**
             * a function which returns url search query
             */
            getQueryString: string;
            /**
             * object representing url searchParams
             */
            params: any;
        } | undefined;
        /**
         * @private
         * On hash changed, update currentLocation object and emit appropriate events
         *
         * @param {string} hash new hash for url
         */
        private hashChanged;
        /**
         * @private
         * Set queryString part of current url
         *
         * @param {string} queryString queryString part of url
         */
        private setQueryString;
    }
    import { EventEmitter } from "eventemitter3";
}
declare module "src/ui/router/Browse" {
    export default Browse;
    /*****************************************************************************
     * Open MCT, Copyright (c) 2014-2024, United States Government
     * as represented by the Administrator of the National Aeronautics and Space
     * Administration. All rights reserved.
     *
     * Open MCT is licensed under the Apache License, Version 2.0 (the
     * "License"); you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     * http://www.apache.org/licenses/LICENSE-2.0.
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
     * License for the specific language governing permissions and limitations
     * under the License.
     *
     * Open MCT includes source code licensed under additional open source
     * licenses. See the Open Source Licenses file (LICENSES.md) included with
     * this source code distribution or the Licensing information page available
     * at runtime from the About dialog for additional information.
     *****************************************************************************/
    class Browse {
        /**
         *
         * @param {import('../../../openmct').OpenMCT} openmct
         */
        constructor(openmct: import('../../../openmct').OpenMCT);
        #private;
    }
}
declare module "src/MCT" {
    /**
     * Open MCT is an extensible web application for building mission
     * control user interfaces. This module is itself an instance of
     * [MCT]{@link module:openmct.MCT}, which provides an interface for
     * configuring and executing the application.
     *
     * @exports openmct
     */
    /**
     * The Open MCT application. This may be configured by installing plugins
     * or registering extensions before the application is started.
     * @constructor
     */
    export class MCT extends EventEmitter<string | symbol, any> {
        constructor();
        /**
         * @type {import('openmct.js').BuildInfo}
         */
        buildInfo: import("openmct").BuildInfo;
        /**
         * @type {string}
         */
        defaultClock: string;
        /**
         * @type {Record<string, OpenMCTPlugin>}
         */
        plugins: Record<string, OpenMCTPlugin>;
        /**
         * Tracks current selection state of the application.
         * @type {Selection}
         */
        selection: Selection;
        destroy(): void;
        /**
         * @type {TimeAPI}
         */
        time: TimeAPI;
        /**
         * An interface for interacting with the composition of domain objects.
         * The composition of a domain object is the list of other domain
         * objects it "contains" (for instance, that should be displayed
         * beneath it in the tree.)
         *
         * `composition` may be called as a function, in which case it acts
         * as [`composition.get`]{@link module:openmct.CompositionAPI#get}.
         *
         * @type {CompositionAPI}
         */
        composition: CompositionAPI;
        /**
         * Registry for views of domain objects which should appear in the
         * main viewing area.
         *
         * @type {ViewRegistry}
         */
        objectViews: ViewRegistry;
        /**
         * Registry for views which should appear in the Inspector area.
         * These views will be chosen based on the selection state.
         *
         * @type {InspectorViewRegistry}
         */
        inspectorViews: InspectorViewRegistry;
        /**
         * Registry for views which should appear in Edit Properties
         * dialogs, and similar user interface elements used for
         * modifying domain objects external to its regular views.
         *
         * @type {ViewRegistry}
         */
        propertyEditors: ViewRegistry;
        /**
         * Registry for views which should appear in the toolbar area while
         * editing. These views will be chosen based on the selection state.
         *
         * @type {ToolbarRegistry}
         */
        toolbars: ToolbarRegistry;
        /**
         * Registry for domain object types which may exist within this
         * instance of Open MCT.
         *
         * @type {TypeRegistry}
         */
        types: TypeRegistry;
        /**
         * An interface for interacting with domain objects and the domain
         * object hierarchy.
         *
         * @type {ObjectAPI}
         */
        objects: ObjectAPI;
        /**
         * An interface for retrieving and interpreting telemetry data associated
         * with a domain object.
         *
         * @type {TelemetryAPI}
         */
        telemetry: TelemetryAPI;
        /**
         * An interface for creating new indicators and changing them dynamically.
         *
         * @type {IndicatorAPI}
         */
        indicators: IndicatorAPI;
        /**
         * MCT's user awareness management, to enable user and
         * role specific functionality.
         * @type {UserAPI}
         */
        user: UserAPI;
        /**
         * An interface for managing notifications and alerts.
         * @type {NotificationAPI}
         */
        notifications: NotificationAPI;
        /**
         * An interface for editing domain objects.
         * @type {EditorAPI}
         */
        editor: EditorAPI;
        /**
         * An interface for managing overlays.
         * @type {OverlayAPI}
         */
        overlays: OverlayAPI;
        /**
         * An interface for managing tooltips.
         * @type {ToolTipAPI}
         */
        tooltips: ToolTipAPI;
        /**
         * An interface for managing menus.
         * @type {MenuAPI}
         */
        menus: MenuAPI;
        /**
         * An interface for managing menu actions.
         * @type {ActionsAPI}
         */
        actions: ActionsAPI;
        /**
         * An interface for managing statuses.
         * @type {StatusAPI}
         */
        status: StatusAPI;
        /**
         * An object defining constants for priority levels.
         * @type {PriorityAPI}
         */
        priority: Readonly<{
            HIGH: 1000;
            DEFAULT: 0;
            LOW: -1000;
        }>;
        /**
         * An interface for routing application traffic.
         * @type {ApplicationRouter}
         */
        router: ApplicationRouter;
        /**
         * An interface for managing faults.
         * @type {FaultManagementAPI}
         */
        faults: FaultManagementAPI;
        /**
         * An interface for managing forms.
         * @type {FormsAPI}
         */
        forms: FormsAPI;
        /**
         * An interface for branding the application.
         * @type {BrandingAPI}
         */
        branding: typeof BrandingAPI;
        /**
         * MCT's annotation API that enables
         * human-created comments and categorization linked to data products
         * @type {AnnotationAPI}
         */
        annotation: AnnotationAPI;
        /**
         * Set path to where assets are hosted.  This should be the path to main.js.
         * @method setAssetPath
         */
        setAssetPath(assetPath: any): void;
        _assetPath: any;
        /**
         * Get path to where assets are hosted.
         * @method getAssetPath
         */
        getAssetPath(): any;
        /**
         * Start running Open MCT. This should be called only after any plugins
         * have been installed.
         * @fires module:openmct.MCT~start
         * @method start
         * @param {Element?} domElement the DOM element in which to run
         *        MCT; if undefined, MCT will be run in the body of the document
         */
        start(domElement?: Element | null, isHeadlessMode?: boolean): void;
        element: Element | undefined;
        layout: import("vue").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("vue").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string, {}>, {}, {}> | undefined;
        app: import("vue").App<Element> | undefined;
        browseRoutes: Browse | undefined;
        startHeadless(): void;
        /**
         * Install a plugin in MCT.
         *
         * @param {Function} plugin a plugin install function which will be
         *     invoked with the mct instance.
         */
        install(plugin: Function): void;
    }
    export type OpenMCTPlugin = import("openmct").OpenMCTPlugin;
    import { EventEmitter } from "eventemitter3";
    import Selection from "src/selection/Selection";
    import TimeAPI from "src/api/time/TimeAPI";
    import CompositionAPI from "src/api/composition/CompositionAPI";
    import ViewRegistry from "src/ui/registries/ViewRegistry";
    import InspectorViewRegistry from "src/ui/registries/InspectorViewRegistry";
    import ToolbarRegistry from "src/ui/registries/ToolbarRegistry";
    import TypeRegistry from "src/api/types/TypeRegistry";
    import ObjectAPI from "src/api/objects/ObjectAPI";
    import TelemetryAPI from "src/api/telemetry/TelemetryAPI";
    import IndicatorAPI from "src/api/indicators/IndicatorAPI";
    import UserAPI from "src/api/user/UserAPI";
    import NotificationAPI from "src/api/notifications/NotificationAPI";
    import EditorAPI from "src/api/Editor";
    import OverlayAPI from "src/api/overlays/OverlayAPI";
    import ToolTipAPI from "src/api/tooltips/ToolTipAPI";
    import MenuAPI from "src/api/menu/MenuAPI";
    import ActionsAPI from "src/api/actions/ActionsAPI";
    import StatusAPI from "src/api/status/StatusAPI";
    import ApplicationRouter from "src/ui/router/ApplicationRouter";
    import FaultManagementAPI from "src/api/faultmanagement/FaultManagementAPI";
    import FormsAPI from "src/api/forms/FormsAPI";
    import BrandingAPI from "src/api/Branding";
    import AnnotationAPI from "src/api/annotation/AnnotationAPI";
    import Browse from "src/ui/router/Browse";
}
declare module "openmct" {
    export default openmct;
    export type OpenMCT = MCT;
    export type DomainObject = import("src/api/objects/ObjectAPI").DomainObject;
    export type Identifier = import("src/api/objects/ObjectAPI").Identifier;
    export type Transaction = import("src/api/objects/Transaction").default;
    export type Action = import("src/api/actions/ActionsAPI").Action;
    export type ActionCollection = import("src/api/actions/ActionCollection").default;
    export type CompositionCollection = import("src/api/composition/CompositionCollection").default;
    export type CompositionProvider = import("src/api/composition/CompositionProvider").default;
    export type ViewProvider = import("src/ui/registries/ViewRegistry").ViewProvider;
    export type View = import("src/ui/registries/ViewRegistry").View;
    export type ObjectPath = DomainObject[];
    /**
     * An OpenMCT Plugin returns a function that receives an instance of
     * the OpenMCT API and uses it to install itself.
     */
    export type OpenMCTPlugin = (...args: any[]) => (openmct: OpenMCT) => void;
    export type BuildInfo = {
        version: string;
        buildDate: string;
        revision: string;
        branch: string;
    };
    const openmct: MCT;
    import { MCT } from "src/MCT";
}
declare module "src/api/actions/ActionCollection" {
    export default ActionCollection;
    export type Action = import("openmct").Action;
    /**
     * A collection of actions applicable to a domain object.
     * @extends EventEmitter
     */
    class ActionCollection extends EventEmitter<string | symbol, any> {
        /**
         * Creates an instance of ActionCollection.
         * @param {Object.<string, Action>} applicableActions - The actions applicable to the domain object.
         * @param {import('openmct').ObjectPath} objectPath - The path to the domain object.
         * @param {import('openmct').View} view - The view displaying the domain object.
         * @param {import('openmct').OpenMCT} openmct - The Open MCT API.
         * @param {boolean} skipEnvironmentObservers - Whether to skip setting up environment observers.
         */
        constructor(applicableActions: {
            [x: string]: Action;
        }, objectPath: import('openmct').ObjectPath, view: import('openmct').View, openmct: import('openmct').OpenMCT, skipEnvironmentObservers: boolean);
        applicableActions: {
            [x: string]: import("src/api/actions/ActionsAPI").Action;
        };
        openmct: import("src/MCT").MCT;
        objectPath: import("openmct").ObjectPath;
        view: import("src/ui/registries/ViewRegistry").View;
        skipEnvironmentObservers: boolean;
        objectUnsubscribes: any[];
        /**
         * Updates the applicable actions.
         * @private
         */
        private _updateActions;
        /**
         * Emits an update event with the current applicable actions.
         * @private
         */
        private _update;
        /**
         * Disables the specified actions.
         * @param {string[]} actionKeys - The keys of the actions to disable.
         */
        disable(actionKeys: string[]): void;
        /**
         * Enables the specified actions.
         * @param {string[]} actionKeys - The keys of the actions to enable.
         */
        enable(actionKeys: string[]): void;
        /**
         * Hides the specified actions.
         * @param {string[]} actionKeys - The keys of the actions to hide.
         */
        hide(actionKeys: string[]): void;
        /**
         * Shows the specified actions.
         * @param {string[]} actionKeys - The keys of the actions to show.
         */
        show(actionKeys: string[]): void;
        /**
         * Destroys the action collection, removing all listeners and observers.
         */
        destroy(): void;
        /**
         * Gets all visible actions.
         * @returns {Action[]} An array of visible actions.
         */
        getVisibleActions(): Action[];
        /**
         * Gets all actions that should be shown in the status bar.
         * @returns {Action[]} An array of status bar actions.
         */
        getStatusBarActions(): Action[];
        /**
         * Gets the object containing all applicable actions.
         * @returns {Object.<string, Action>} The object of applicable actions.
         */
        getActionsObject(): {
            [x: string]: Action;
        };
        /**
         * Sets up observers for the object path.
         * @private
         */
        private _observeObjectPath;
        /**
         * Merges old and new actions, preserving existing action states.
         * @param {Object.<string, Action>} oldActions - The existing actions.
         * @param {Object.<string, Action>} newActions - The new actions.
         * @returns {Object.<string, Action>} The merged actions.
         * @private
         */
        private _mergeOldAndNewActions;
    }
    import { EventEmitter } from "eventemitter3";
}
declare module "src/api/actions/ActionsAPI" {
    export default ActionsAPI;
    export type Action = {
        /**
         * - The display name of the action.
         */
        name: string;
        /**
         * - A unique identifier for the action.
         */
        key: string;
        /**
         * - A brief description of what the action does.
         */
        description: string;
        /**
         * - The CSS class for the action's icon.
         */
        cssClass: string;
        /**
         * - The group this action belongs to (e.g., 'action', 'import').
         */
        group?: string | undefined;
        /**
         * - The priority of the action within its group (controls the order of the actions in the menu).
         */
        priority?: number | undefined;
        /**
         * - Whether the action should be hidden from menus.
         */
        isHidden?: boolean | undefined;
        /**
         * - Executes the action.
         */
        invoke: (objectPath: import("openmct").ObjectPath, view: View) => void;
        /**
         * - Determines if the action is applicable to the given object path.
         */
        appliesTo: (objectPath: import("openmct").ObjectPath, view: View) => boolean;
    };
    export type ObjectPath = import("openmct").ObjectPath;
    export type View = import("openmct").View;
    /**
     * The ActionsAPI manages the registration and retrieval of actions in Open MCT.
     * @extends EventEmitter
     */
    class ActionsAPI extends EventEmitter<string | symbol, any> {
        /**
         * @param {import('openmct').OpenMCT} openmct - The Open MCT instance
         */
        constructor(openmct: import('openmct').OpenMCT);
        /** @type {Object<string, Action>} */
        _allActions: {
            [x: string]: Action;
        };
        /** @type {WeakMap<Object, ActionCollection>} */
        _actionCollections: WeakMap<any, ActionCollection>;
        /** @type {import('openmct').OpenMCT} */
        _openmct: import("openmct").OpenMCT;
        /** @type {string[]} */
        _groupOrder: string[];
        /**
         * Register an action with the API.
         * @param {Action} actionDefinition - The definition of the action to register
         */
        register(actionDefinition: Action): void;
        /**
         * Get or create an ActionCollection for a given object path and view.
         * @param {import('openmct').ObjectPath} objectPath - The path of the object
         * @param {import('openmct').View} [view] - The view object
         * @returns {ActionCollection} The ActionCollection for the given object path and view
         */
        getActionsCollection(objectPath: import('openmct').ObjectPath, view?: import("src/ui/registries/ViewRegistry").View | undefined): ActionCollection;
        /**
         * Get applicable actions for a given object path and view.
         * @param {import('openmct').ObjectPath} objectPath - The path of the object
         * @param {import('openmct').View} [view] - The view object
         * @returns {Object<string, Action>} A dictionary of applicable actions keyed by action key
         */
        _applicableActions(objectPath: import('openmct').ObjectPath, view?: import("src/ui/registries/ViewRegistry").View | undefined): {
            [x: string]: Action;
        };
        /**
         * Update cached ActionCollections when destroyed.
         * @param {import('openmct').View} view - The key (View object)of the destroyed ActionCollection
         */
        _updateCachedActionCollections(view: import('openmct').View): void;
        /**
         * Get an action by its key.
         * @param {string} key - The key of the action to retrieve
         * @returns {Action|undefined} The action definition, or undefined if not found
         */
        getAction(key: string): Action | undefined;
        /**
         * Update the order in which action groups are displayed.
         * @param {string[]} groupArray - An array of group names in the desired order
         */
        updateGroupOrder(groupArray: string[]): void;
        /**
         * Get a cached ActionCollection for a given view.
         * @param {import('openmct').ObjectPath} objectPath - The path of the object
         * @param {Object} view - The view object
         * @returns {ActionCollection|undefined} The cached ActionCollection, or undefined if not found
         */
        _getCachedActionCollection(objectPath: import('openmct').ObjectPath, view: any): ActionCollection | undefined;
        /**
         * Create a new ActionCollection.
         * @param {import('openmct').ObjectPath} objectPath - The path of the object
         * @param {import('openmct').View} [view] - The view object
         * @param {boolean} skipEnvironmentObservers - Whether to skip environment observers
         * @returns {ActionCollection} The new ActionCollection
         */
        _newActionCollection(objectPath: import('openmct').ObjectPath, view?: import("src/ui/registries/ViewRegistry").View | undefined, skipEnvironmentObservers: boolean): ActionCollection;
        /**
         * Cache an ActionCollection for a given view.
         * @param {import('openmct').View} view - The view object
         * @param {ActionCollection} actionCollection - The ActionCollection to cache
         */
        _cacheActionCollection(view: import('openmct').View, actionCollection: ActionCollection): void;
        /**
         * Group and sort actions based on their group and priority.
         * @param {Action[]|Object<string, Action>} actionsArray - An array or object of actions to group and sort
         * @returns {Action[][]} An array of grouped and sorted action arrays
         */
        _groupAndSortActions(actionsArray?: Action[] | {
            [x: string]: Action;
        }): Action[][];
    }
    import { EventEmitter } from "eventemitter3";
    import ActionCollection from "src/api/actions/ActionCollection";
}
declare module "src/api/api" {
    namespace _default {
        export { ActionsAPI };
        export { CompositionAPI };
        export { EditorAPI };
        export { FaultManagementAPI };
        export { FormsAPI };
        export { IndicatorAPI };
        export { MenuAPI };
        export { NotificationAPI };
        export { ObjectAPI };
        export { PriorityAPI };
        export { StatusAPI };
        export { TelemetryAPI };
        export { TimeAPI };
        export { TypeRegistry };
        export { UserAPI };
        export { AnnotationAPI };
    }
    export default _default;
    import ActionsAPI from "src/api/actions/ActionsAPI";
    import CompositionAPI from "src/api/composition/CompositionAPI";
    import EditorAPI from "src/api/Editor";
    import FaultManagementAPI from "src/api/faultmanagement/FaultManagementAPI";
    import FormsAPI from "src/api/forms/FormsAPI";
    import IndicatorAPI from "src/api/indicators/IndicatorAPI";
    import MenuAPI from "src/api/menu/MenuAPI";
    import NotificationAPI from "src/api/notifications/NotificationAPI";
    import ObjectAPI from "src/api/objects/ObjectAPI";
    import PriorityAPI from "src/api/priority/PriorityAPI";
    import StatusAPI from "src/api/status/StatusAPI";
    import TelemetryAPI from "src/api/telemetry/TelemetryAPI";
    import TimeAPI from "src/api/time/TimeAPI";
    import TypeRegistry from "src/api/types/TypeRegistry";
    import UserAPI from "src/api/user/UserAPI";
    import AnnotationAPI from "src/api/annotation/AnnotationAPI";
}
declare module "src/api/forms/toggle-check-box-mixin" {
    namespace _default {
        let emits: string[];
        function data(): {
            isChecked: boolean;
        };
        namespace methods {
            function toggleCheckBox(event: any): void;
        }
    }
    export default _default;
}
declare module "src/api/menu/mixins/popupMenuMixin" {
    namespace _default {
        namespace methods {
            /**
             * @private
             */
            function _calculatePopupPosition(menuElement: any): {
                x: any;
                y: any;
            };
            /**
             * @private
             */
            function _getMenuPositionBasedOnPlacement(menuDimensions: any): {
                x: any;
                y: any;
            };
            /**
             * @private
             */
            function _preventMenuOverflow(menuPosition: any, menuDimensions: any): {
                x: any;
                y: any;
            };
        }
        function mounted(): void;
        function data(): {
            top: string;
            left: string;
        };
        namespace computed {
            function styleObject(): {
                top: string;
                left: string;
            };
        }
    }
    export default _default;
}
declare module "src/api/time/IndependentTimeContext" {
    export default IndependentTimeContext;
    export type TimeAPI = import("src/api/time/TimeAPI").default;
    export type GlobalTimeContext = import("src/api/time/GlobalTimeContext").default;
    export type TimeSystem = import("src/api/time/TimeAPI").TimeSystem;
    export type Mode = import("src/api/time/TimeContext").Mode;
    export type TimeConductorBounds = import("src/api/time/TimeContext").TimeConductorBounds;
    export type ClockOffsets = import("src/api/time/TimeAPI").ClockOffsets;
    /**
     * @typedef {import('./TimeAPI.js').default} TimeAPI
     * @typedef {import('./GlobalTimeContext.js').default} GlobalTimeContext
     * @typedef {import('./TimeAPI.js').TimeSystem} TimeSystem
     * @typedef {import('./TimeContext.js').Mode} Mode
     * @typedef {import('./TimeContext.js').TimeConductorBounds} TimeConductorBounds
     * @typedef {import('./TimeAPI.js').ClockOffsets} ClockOffsets
     */
    /**
     * The IndependentTimeContext handles getting and setting time of the openmct application in general.
     * Views will use the GlobalTimeContext unless they specify an alternate/independent time context here.
     */
    class IndependentTimeContext extends TimeContext {
        /**
         * @param {import('openmct').OpenMCT} openmct - The Open MCT application instance.
         * @param {TimeAPI & GlobalTimeContext} globalTimeContext - The global time context.
         * @param {import('openmct').ObjectPath} objectPath - The path of objects.
         */
        constructor(openmct: import('openmct').OpenMCT, globalTimeContext: TimeAPI & GlobalTimeContext, objectPath: import('openmct').ObjectPath);
        /** @type {any} */
        openmct: any;
        /** @type {Function[]} */
        unlisteners: Function[];
        /** @type {TimeAPI & GlobalTimeContext | undefined} */
        globalTimeContext: (TimeAPI & GlobalTimeContext) | undefined;
        /** @type {TimeAPI & GlobalTimeContext | undefined} */
        upstreamTimeContext: (TimeAPI & GlobalTimeContext) | undefined;
        /** @type {Array<any>} */
        objectPath: Array<any>;
        /**
         * Refresh the time context, following any upstream time contexts as necessary
         * @param {string} [viewKey] The key of the view to refresh
         */
        refreshContext(viewKey?: string | undefined): void;
        /**
         * Reset the time context to the global time context
         */
        resetContext(): void;
        /**
         * Set the time context of a view to follow any upstream time contexts as necessary (defaulting to the global context)
         * This needs to be separate from refreshContext
         */
        removeIndependentContext(viewKey: any): void;
        /**
         * @deprecated
         * @override
         */
        override bounds(...args: any[]): import("src/api/time/TimeContext").TimeConductorBounds;
        /**
         * @override
         */
        override setBounds(...args: any[]): void;
        /**
         * @override
         */
        override tick(...args: any[]): void;
        /**
         * @override
         */
        override clockOffsets(...args: any[]): import("src/api/time/TimeContext").ClockOffsets;
        /**
         * @override
         */
        override setClockOffsets(...args: any[]): void;
        /**
         *
         * @param {number} newTOI
         * @returns {number}
         */
        timeOfInterest(newTOI: number, ...args: any[]): number;
        /**
         * Set the active clock. Tick source will be immediately subscribed to
         * and ticking will begin. Offsets from 'now' must also be provided.
         *
         * @param {Clock || string} keyOrClock The clock to activate, or its key
         * @param {ClockOffsets} offsets on each tick these will be used to calculate
         * the start and end bounds. This maintains a sliding time window of a fixed
         * width that automatically updates.
         * @fires module:openmct.TimeAPI~clock
         * @return {Clock} the currently active clock;
         */
        clock(keyOrClock: any, offsets: ClockOffsets, ...args: any[]): Clock;
        /**
         * Get the active clock.
         * @return {Clock} the currently active clock;
         */
        getClock(): Clock;
        /**
         * Set the active clock. Tick source will be immediately subscribed to
         * and the currently ticking will begin.
         * Offsets from 'now', if provided, will be used to set realtime mode offsets
         *
         * @param {Clock || string} keyOrClock The clock to activate, or its key
         * @fires module:openmct.TimeAPI~clock
         * @return {Clock} the currently active clock;
         */
        setClock(keyOrClock: any, ...args: any[]): Clock;
        /**
         * Set the mode to either fixed or realtime.
         *
         * @param {Mode} mode The mode to activate
         * @param {TimeConductorBounds | ClockOffsets} offsetsOrBounds A time window of a fixed width
         * @return {Mode | undefined} the currently active mode;
         */
        setMode(mode: Mode, offsetsOrBounds: TimeConductorBounds | ClockOffsets, ...args: any[]): Mode | undefined;
        /**
         * @returns {boolean}
         * @override
         */
        override isRealTime(...args: any[]): boolean;
        /**
         * @returns {number}
         * @override
         */
        override now(...args: any[]): number;
        /**
         * Causes this time context to follow another time context (either the global context, or another upstream time context)
         * This allows views to have their own time context which points to the appropriate upstream context as necessary, achieving nesting.
         */
        followTimeContext(): void;
        /**
         * Stops following any upstream time context
         */
        stopFollowingTimeContext(): void;
        /**
         * @returns {boolean} True if this time context has an independent context, false otherwise
         */
        hasOwnContext(): boolean;
        /**
         * Get the upstream time context of this time context
         * @returns {TimeAPI & GlobalTimeContext | undefined} The upstream time context
         */
        getUpstreamContext(): (TimeAPI & GlobalTimeContext) | undefined;
        #private;
    }
    import TimeContext from "src/api/time/TimeContext";
}
declare module "src/api/tooltips/tooltipMixins" {
    export default tooltipHelpers;
    namespace tooltipHelpers {
        namespace methods {
            function getTelemetryPathString(telemetryIdentifier: any): Promise<string | undefined>;
            function getObjectPath(objectIdentifier: any): Promise<any>;
            function buildToolTip(tooltipText: any, tooltipLocation: any, elementRef: any): void;
            function hideToolTip(): void;
        }
    }
}
declare module "src/api/user/ActiveRoleSynchronizer" {
    export default ActiveRoleSynchronizer;
    class ActiveRoleSynchronizer {
        constructor(openmct: any);
        openmct: any;
        setActiveRoleFromChannelMessage(event: any): void;
        subscribeToRoleChanges(callback: any): void;
        unsubscribeFromRoleChanges(callback: any): void;
        broadcastNewRole(role: any): false | undefined;
        destroy(): void;
        #private;
    }
}
//# sourceMappingURL=index.d.ts.map